(function() {

;(function(g){

  // summary: A simple feature detection function/framework.
  //
  // name: String
  //      The name of the feature to detect, as defined by the overall `has` tests.
  //      Tests can be registered via `has.add(testname, testfunction)`.
  //
  // example:
  //      mylibrary.bind = has("native-bind") ? function(fn, context){
  //          return fn.bind(context);
  //      } : function(fn, context){
  //          return function(){
  //              fn.apply(context, arguments);
  //          }
  //      }

  var NON_HOST_TYPES = { "boolean": 1, "number": 1, "string": 1, "undefined": 1 },
    VENDOR_PREFIXES = ["Webkit", "Moz", "O", "ms", "Khtml"],
    d = isHostType(g, "document") && g.document,
    el = d && isHostType(d, "createElement") && d.createElement("DiV"),
    freeExports = typeof exports == "object" && exports,
    freeModule = typeof module == "object" && module,
    testCache = {}
    ;

  function has(/* String */name){
    if(typeof testCache[name] == "function"){
      testCache[name] = testCache[name](g, d, el);
    }
    return testCache[name]; // Boolean
  }

  function add(/* String */name, /* Function */test, /* Boolean? */now){
    // summary: Register a new feature detection test for some named feature
    //
    // name: String
    //      The name of the feature to test.
    //
    // test: Function
    //      A test function to register. If a function, queued for testing until actually
    //      needed. The test function should return a boolean indicating
    //      the presence of a feature or bug.
    //
    // now: Boolean?
    //      Optional. Omit if `test` is not a function. Provides a way to immediately
    //      run the test and cache the result.
    // example:
    //      A redundant test, testFn with immediate execution:
    //  |       has.add("javascript", function(){ return true; }, true);
    //
    // example:
    //      Again with the redundantness. You can do this in your tests, but we should
    //      not be doing this in any internal has.js tests
    //  |       has.add("javascript", true);
    //
    // example:
    //      Three things are passed to the testFunction. `global`, `document`, and a generic element
    //      from which to work your test should the need arise.
    //  |       has.add("bug-byid", function(g, d, el){
    //  |           // g  == global, typically window, yadda yadda
    //  |           // d  == document object
    //  |           // el == the generic element. a `has` element.
    //  |           return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
    //  |       });
    testCache[name] = now ? test(g, d, el) : test;
  }

  // cssprop adapted from http://gist.github.com/598008 (thanks, ^pi)
  function cssprop(name, el){
    var supported = false,
      capitalized = name.charAt(0).toUpperCase() + name.slice(1),
      length = VENDOR_PREFIXES.length,
      style = el.style;

    if(typeof style[name] == "string"){
      supported = true;
    }else{
      while(length--){
        if(typeof style[VENDOR_PREFIXES[length] + capitalized] == "string"){
          supported = true;
          break;
        }
      }
    }
    return supported;
  }

  function clearElement(el){
    if(el){
      while(el.lastChild){
        el.removeChild(el.lastChild);
      }
    }
    return el;
  }

  // Host objects can return type values that are different from their actual
  // data type. The objects we are concerned with usually return non-primitive
  // types of object, function, or unknown.
  function isHostType(object, property){
    var type = typeof object[property];
    return type == "object" ? !!object[property] : !NON_HOST_TYPES[type];
  }

    has.add = add;
  has.clearElement = clearElement;
  has.cssprop = cssprop;
  has.isHostType = isHostType;
  has._tests = testCache;

  has.add("dom", function(g, d, el){
    return d && el && isHostType(g, "location") && isHostType(d, "documentElement") &&
           isHostType(d, "getElementById") && isHostType(d, "getElementsByName") &&
           isHostType(d, "getElementsByTagName") && isHostType(d, "createComment") &&
           isHostType(d, "createElement") && isHostType(d, "createTextNode") &&
           isHostType(el, "appendChild") && isHostType(el, "insertBefore") &&
           isHostType(el, "removeChild") && isHostType(el, "getAttribute") &&
           isHostType(el, "setAttribute") && isHostType(el, "removeAttribute") &&
           isHostType(el, "style") && typeof el.style.cssText == "string";
  });

  // Stop repeat background-image requests and reduce memory consumption in IE6 SP1
  // http://misterpixel.blogspot.com/2006/09/forensic-analysis-of-ie6.html
  // http://blogs.msdn.com/b/cwilso/archive/2006/11/07/ie-re-downloading-background-images.aspx?PageIndex=1
  // http://support.microsoft.com/kb/823727
  try{
    document.execCommand("BackgroundImageCache", false, true);
  }catch(e){}

  // Expose has()
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if(typeof define == "function" && typeof define.amd == "object" && define.amd){
    define("has", function(){
      return has;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if(freeExports){
    // in Node.js or RingoJS v0.8.0+
    if(freeModule && freeModule.exports == freeExports){
      (freeModule.exports = has).has = has;
    }
    // in Narwhal or RingoJS v0.7.0-
    else{
      freeExports.has = has;
    }
  }
  // in a browser or Rhino
  else{
    // use square bracket notation so Closure Compiler won't munge `has`
    // http://code.google.com/closure/compiler/docs/api-tutorial3.html#export
    g["has"] = has;
  }
})(this);
/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

// Copyright 2002-2014, University of Colorado Boulder

/*
 * Usage:
 * var assert = require( '<assert>' )( 'flagName' );
 *
 * assert && assert( <simple value or big computation>, "<message here>" );
 *
 * TODO: decide on usages and viability, and if so document further
 *
 * NOTE: for changing build, add has.js tests for 'assert.' + flagName
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'ASSERT/assert',[],function() {
  
  
  // CAUTION: if using the AST modifier for assertions, do not separate this out into its own 'assert' variable
  return function assert( name, excludeByDefault ) {
    var hasName = 'assert.' + name;
    
    var flagDefined = window.has && window.has( hasName ) !== undefined;
    var skipAssert = flagDefined ? !window.has( hasName ) : excludeByDefault;
    
    if ( skipAssert ) {
      return null;
    } else {
      return function( predicate, message ) {
        var result = typeof predicate === 'function' ? predicate() : predicate;
        
        if ( !result ) {

          //Log the stack trace to IE.  Just creating an Error is not enough, it has to be caught to get a stack.
          //TODO: What will this do for IE9?  Probably just print stack = undefined.
          if ( window.navigator && window.navigator.appName === 'Microsoft Internet Explorer' ) {
            try { throw new Error(); }
            catch( e ) { message = message + ", stack=\n" + e.stack; }
          }
          
          // TODO: custom error?
          throw new Error( 'Assertion failed: ' + message );
        }
      };
    }
  };
} );


// Copyright 2002-2014, University of Colorado Boulder

define( 'PHET_CORE/core',['require','ASSERT/assert','ASSERT/assert'],function( require ) {
  
  
  window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
  window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
  
  // no phetAllocation initialized, since we don't need it with just phet-core, and this file is required before that
  
  // will be filled in by other modules
  return {};
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Object instance allocation tracking, so we can cut down on garbage collection.
 *
 * Sample usage:
 * 1. Run the sim and set up the scenario that you wish to profile
 * 2. In the JS console, type: window.alloc={}
 * 3. Wait until you have taken enough data
 * 4. Type x = window.alloc; delete window.alloc;
 *
 * Now you can inspect the x variable which contains the allocation information.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/phetAllocation',['require','PHET_CORE/core'],function( require ) {
  

  var core = require( 'PHET_CORE/core' );

  var phetAllocation = core.phetAllocation = function phetAllocation( name ) {
    if ( window.alloc ) {
      var stack;
      try { throw new Error(); }
      catch( e ) { stack = e.stack; }

      if ( !window.alloc[name] ) {
        window.alloc[name] = { count: 0, stacks: {} };
      }
      var log = window.alloc[name];

      log.count++;
      if ( !log.stacks[stack] ) {
        log.stacks[stack] = 1;
      }
      else {
        log.stacks[stack] += 1;
      }
      log.report = function() {
        var stacks = Object.keys( log.stacks );
        stacks = _.sortBy( stacks, function( key ) { return log.stacks[key]; } );
        _.each( stacks, function( stack ) {
          console.log( log.stacks[stack] + ': ' + stack );
        } );
      };
    }
  };
  return phetAllocation;
} );

// Copyright 2002-2013, University of Colorado

/**
 * The main 'scenery' namespace object for the exported (non-Require.js) API. Used internally
 * since it prevents Require.js issues with circular dependencies.
 *
 * The returned scenery object namespace may be incomplete if not all modules are listed as
 * dependencies. Please use the 'main' module for that purpose if all of Scenery is desired.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/scenery',['require','ASSERT/assert','ASSERT/assert','PHET_CORE/phetAllocation'],function( require ) {
  
  
  window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
  window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
  
  window.sceneryLayerLog = null;
  window.sceneryEventLog = null;
  window.sceneryAccessibilityLog = null;
  
  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
  
  var scratchCanvas = document.createElement( 'canvas' );
  var scratchContext = scratchCanvas.getContext( '2d' );
  
  // will be filled in by other modules
  return {
    assert: assert,
    
    scratchCanvas: scratchCanvas,   // a canvas used for convenience functions (think of it as having arbitrary state)
    scratchContext: scratchContext, // a context used for convenience functions (think of it as having arbitrary state)
    
    svgns: 'http://www.w3.org/2000/svg',     // svg namespace
    xlinkns: 'http://www.w3.org/1999/xlink', // x-link namespace
    
    enableLayerLogging: function() {
      window.sceneryLayerLog = function( ob ) { console.log( ob ); };
    },
  
    disableLayerLogging: function() {
      window.sceneryLayerLog = null;
    },
    
    enableEventLogging: function() {
      window.sceneryEventLog = function( ob ) { console.log( ob ); };
    },
  
    disableEventLogging: function() {
      window.sceneryEventLog = null;
    },
    
    enableAccessibilityLogging: function() {
      window.sceneryAccessibilityLog = function( ob ) { console.log( ob ); };
    },
  
    disableAccessibilityLogging: function() {
      window.sceneryAccessibilityLog = null;
    },
    
    bitmaskAll:            0xFFFFFFF, // 28 bits for now (don't go over 31 bits, or we'll see a 32-bit platform slowdown!)
    bitmaskNodeDefault:    0x00001FF,
    bitmaskPaintedDefault: 0x0000000,
    
    bitmaskSupportsCanvas: 0x0000001,
    bitmaskSupportsSVG:    0x0000002,
    bitmaskSupportsDOM:    0x0000004,
    bitmaskSupportsWebGL:  0x0000008,
    // 10, 20, 40, 80 reserved for future renderers
    bitmaskNotPainted:     0x0000100
    // TODO: what else would we need?
  };
} );

// Copyright 2002-2013, University of Colorado

/**
 * A debugging version of the CanvasRenderingContext2D that will output all commands issued,
 * but can also forward them to a real context
 *
 * See the spec at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#2dcontext
 * Wrapping of the CanvasRenderingContext2D interface as of January 27th, 2013 (but not other interfaces like TextMetrics and Path)
 *
 * Shortcut to create:
 *    var context = new scenery.DebugContext( document.createElement( 'canvas' ).getContext( '2d' ) );
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/debug/DebugContext',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  // used to serialize arguments so that it displays exactly like the call would be executed
  function s( value ) {
    return JSON.stringify( value );
  }
  
  function log( message ) {
    console.log( 'context.' + message + ';' );
  }
  
  function attributeGet( name ) {
    log( name );
  }
  
  function attributeSet( name, value ) {
    log( name + ' = ' + s( value ) );
  }
  
  function command( name, args ) {
    if ( args === undefined || args.length === 0 ) {
      log( name + '()' );
    } else {
      log( name + '( ' + _.reduce( args, function( memo, arg ) {
        if ( memo.length > 0 ) {
          return memo + ', ' + s( arg );
        } else {
          return s( arg );
        }
      }, '' ) + ' )' );
    }
  }
  
  scenery.DebugContext = function DebugContext( context ) {
    this._context = context;
    
    // allow checking of context.ellipse for existence
    if ( context && !context.ellipse ) {
      this.ellipse = context.ellipse;
    }
  };
  var DebugContext = scenery.DebugContext;
  
  DebugContext.prototype = {
    constructor: DebugContext,
    
    get canvas() {
      attributeGet( 'canvas' );
      return this._context.canvas;
    },
    
    get width() {
      attributeGet( 'width' );
      return this._context.width;
    },
    
    get height() {
      attributeGet( 'height' );
      return this._context.height;
    },
    
    commit: function() {
      command( 'commit' );
      this._context.commit();
    },
    
    save: function() {
      command( 'save' );
      this._context.save();
    },
    
    restore: function() {
      command( 'restore' );
      this._context.restore();
    },
    
    get currentTransform() {
      attributeGet( 'currentTransform' );
      return this._context.currentTransform;
    },
    
    set currentTransform( transform ) {
      attributeSet( 'currentTransform', transform );
      this._context.currentTransform = transform;
    },
    
    scale: function( x, y ) {
      command( 'scale', [ x, y ] );
      this._context.scale( x, y );
    },
    
    rotate: function( angle ) {
      command( 'rotate', [ angle ] );
      this._context.rotate( angle );
    },
    
    translate: function( x, y ) {
      command( 'translate', [ x, y ] );
      this._context.translate( x, y );
    },
    
    transform: function( a, b, c, d, e, f ) {
      command( 'transform', [ a, b, c, d, e, f ] );
      this._context.transform( a, b, c, d, e, f );
    },
    
    setTransform: function( a, b, c, d, e, f ) {
      command( 'setTransform', [ a, b, c, d, e, f ] );
      this._context.setTransform( a, b, c, d, e, f );
    },
    
    resetTransform: function() {
      command( 'resetTransform' );
      this._context.resetTransform();
    },
    
    get globalAlpha() {
      attributeGet( 'globalAlpha' );
      return this._context.globalAlpha;
    },
    
    set globalAlpha( value ) {
      attributeSet( 'globalAlpha', value );
      this._context.globalAlpha = value;
    },
    
    get globalCompositeOperation() {
      attributeGet( 'globalCompositeOperation' );
      return this._context.globalCompositeOperation;
    },
    
    set globalCompositeOperation( value ) {
      attributeSet( 'globalCompositeOperation', value );
      this._context.globalCompositeOperation = value;
    },
    
    get imageSmoothingEnabled() {
      attributeGet( 'imageSmoothingEnabled' );
      return this._context.imageSmoothingEnabled;
    },
    
    set imageSmoothingEnabled( value ) {
      attributeSet( 'imageSmoothingEnabled', value );
      this._context.imageSmoothingEnabled = value;
    },
    
    get strokeStyle() {
      attributeGet( 'strokeStyle' );
      return this._context.strokeStyle;
    },
    
    set strokeStyle( value ) {
      attributeSet( 'strokeStyle', value );
      this._context.strokeStyle = value;
    },
    
    get fillStyle() {
      attributeGet( 'fillStyle' );
      return this._context.fillStyle;
    },
    
    set fillStyle( value ) {
      attributeSet( 'fillStyle', value );
      this._context.fillStyle = value;
    },
    
    createLinearGradient: function( x0, y0, x1, y1 ) {
      command( 'createLinearGradient', [ x0, y0, x1, y1 ] );
      return this._context.createLinearGradient( x0, y0, x1, y1 );
    },
    
    createRadialGradient: function( x0, y0, r0, x1, y1, r1 ) {
      command( 'createRadialGradient', [ x0, y0, r0, x1, y1, r1 ] );
      return this._context.createRadialGradient( x0, y0, r0, x1, y1, r1 );
    },
    
    createPattern: function( image, repetition ) {
      command( 'createPattern', [ image, repetition ] );
      return this._context.createPattern( image, repetition );
    },
    
    get shadowOffsetX() {
      attributeGet( 'shadowOffsetX' );
      return this._context.shadowOffsetX;
    },
    
    set shadowOffsetX( value ) {
      attributeSet( 'shadowOffsetX', value );
      this._context.shadowOffsetX = value;
    },
    
    get shadowOffsetY() {
      attributeGet( 'shadowOffsetY' );
      return this._context.shadowOffsetY;
    },
    
    set shadowOffsetY( value ) {
      attributeSet( 'shadowOffsetY', value );
      this._context.shadowOffsetY = value;
    },
    
    get shadowBlur() {
      attributeGet( 'shadowBlur' );
      return this._context.shadowBlur;
    },
    
    set shadowBlur( value ) {
      attributeSet( 'shadowBlur', value );
      this._context.shadowBlur = value;
    },
    
    get shadowColor() {
      attributeGet( 'shadowColor' );
      return this._context.shadowColor;
    },
    
    set shadowColor( value ) {
      attributeSet( 'shadowColor', value );
      this._context.shadowColor = value;
    },
    
    clearRect: function( x, y, w, h ) {
      command( 'clearRect', [ x, y, w, h ] );
      this._context.clearRect( x, y, w, h );
    },
    
    fillRect: function( x, y, w, h ) {
      command( 'fillRect', [ x, y, w, h ] );
      this._context.fillRect( x, y, w, h );
    },
    
    strokeRect: function( x, y, w, h ) {
      command( 'strokeRect', [ x, y, w, h ] );
      this._context.strokeRect( x, y, w, h );
    },
    
    get fillRule() {
      attributeGet( 'fillRule' );
      return this._context.fillRule;
    },
    
    set fillRule( value ) {
      attributeSet( 'fillRule', value );
      this._context.fillRule = value;
    },
    
    beginPath: function() {
      command( 'beginPath' );
      this._context.beginPath();
    },
    
    fill: function( path ) {
      command( 'fill', path ? [ path ] : undefined );
      this._context.fill( path );
    },
    
    stroke: function( path ) {
      command( 'stroke', path ? [ path ] : undefined );
      this._context.stroke( path );
    },
    
    drawSystemFocusRing: function( a, b ) {
      command( 'drawSystemFocusRing', b ? [ a, b ] : [ a ] );
      this._context.drawSystemFocusRing( a, b );
    },
    
    drawCustomFocusRing: function( a, b ) {
      command( 'drawCustomFocusRing', b ? [ a, b ] : [ a ] );
      return this._context.drawCustomFocusRing( a, b );
    },
    
    scrollPathIntoView: function( path ) {
      command( 'scrollPathIntoView', path ? [ path ] : undefined );
      this._context.scrollPathIntoView( path );
    },
    
    clip: function( path ) {
      command( 'clip', path ? [ path ] : undefined );
      this._context.clip( path );
    },
    
    resetClip: function() {
      command( 'resetClip' );
      this._context.resetClip();
    },
    
    isPointInPath: function( a, b, c ) {
      command( 'isPointInPath', c ? [ a, b, c ] : [ a, b ] );
      return this._context.isPointInPath( a, b, c );
    },
    
    fillText: function( text, x, y, maxWidth ) {
      command( 'fillText', maxWidth !== undefined ? [ text, x, y, maxWidth ] : [ text, x, y ] );
      this._context.fillText( text, x, y, maxWidth );
    },
    
    strokeText: function( text, x, y, maxWidth ) {
      command( 'strokeText', maxWidth !== undefined ? [ text, x, y, maxWidth ] : [ text, x, y ] );
      this._context.strokeText( text, x, y, maxWidth );
    },
    
    measureText: function( text ) {
      command( 'measureText', [ text ] );
      return this._context.measureText( text );
    },
    
    drawImage: function( image, a, b, c, d, e, f, g, h ) {
      command( 'drawImage', c !== undefined ? ( e !== undefined ? [ image, a, b, c, d, e, f, g, h ] : [ image, a, b, c, d ] ) : [ image, a, b ] );
      this._context.drawImage( image, a, b, c, d, e, f, g, h );
    },
    
    addHitRegion: function( options ) {
      command( 'addHitRegion', [ options ] );
      this._context.addHitRegion( options );
    },
    
    removeHitRegion: function( options ) {
      command( 'removeHitRegion', [ options ] );
      this._context.removeHitRegion( options );
    },
    
    createImageData: function( a, b ) {
      command( 'createImageData', b !== undefined ? [ a, b ] : [a] );
      return this._context.createImageData( a, b );
    },
    
    createImageDataHD: function( a, b ) {
      command( 'createImageDataHD', [ a, b ] );
      return this._context.createImageDataHD( a, b );
    },
    
    getImageData: function( sx, sy, sw, sh ) {
      command( 'getImageData', [ sx, sy, sw, sh ] );
      return this._context.getImageData( sx, sy, sw, sh );
    },
    
    getImageDataHD: function( sx, sy, sw, sh ) {
      command( 'getImageDataHD', [ sx, sy, sw, sh ] );
      return this._context.getImageDataHD( sx, sy, sw, sh );
    },
    
    putImageData: function( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ) {
      command( 'putImageData', dirtyX !== undefined ? [ imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ] : [ imageData, dx, dy ] );
      this._context.putImageData( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight );
    },
    
    putImageDataHD: function( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ) {
      command( 'putImageDataHD', dirtyX !== undefined ? [ imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight ] : [ imageData, dx, dy ] );
      this._context.putImageDataHD( imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight );
    },
    
    /*---------------------------------------------------------------------------*
    * CanvasDrawingStyles
    *----------------------------------------------------------------------------*/
    
    get lineWidth() {
      attributeGet( 'lineWidth' );
      return this._context.lineWidth;
    },
    
    set lineWidth( value ) {
      attributeSet( 'lineWidth', value );
      this._context.lineWidth = value;
    },
    
    get lineCap() {
      attributeGet( 'lineCap' );
      return this._context.lineCap;
    },
    
    set lineCap( value ) {
      attributeSet( 'lineCap', value );
      this._context.lineCap = value;
    },
    
    get lineJoin() {
      attributeGet( 'lineJoin' );
      return this._context.lineJoin;
    },
    
    set lineJoin( value ) {
      attributeSet( 'lineJoin', value );
      this._context.lineJoin = value;
    },
    
    get miterLimit() {
      attributeGet( 'miterLimit' );
      return this._context.miterLimit;
    },
    
    set miterLimit( value ) {
      attributeSet( 'miterLimit', value );
      this._context.miterLimit = value;
    },
    
    setLineDash: function( segments ) {
      command( 'setLineDash', [ segments ] );
      this._context.setLineDash( segments );
    },
    
    getLineDash: function() {
      command( 'getLineDash' );
      return this._context.getLineDash();
    },
    
    get lineDashOffset() {
      attributeGet( 'lineDashOffset' );
      return this._context.lineDashOffset;
    },
    
    set lineDashOffset( value ) {
      attributeSet( 'lineDashOffset', value );
      this._context.lineDashOffset = value;
    },
    
    get font() {
      attributeGet( 'font' );
      return this._context.font;
    },
    
    set font( value ) {
      attributeSet( 'font', value );
      this._context.font = value;
    },
    
    get textAlign() {
      attributeGet( 'textAlign' );
      return this._context.textAlign;
    },
    
    set textAlign( value ) {
      attributeSet( 'textAlign', value );
      this._context.textAlign = value;
    },
    
    get textBaseline() {
      attributeGet( 'textBaseline' );
      return this._context.textBaseline;
    },
    
    set textBaseline( value ) {
      attributeSet( 'textBaseline', value );
      this._context.textBaseline = value;
    },
    
    get direction() {
      attributeGet( 'direction' );
      return this._context.direction;
    },
    
    set direction( value ) {
      attributeSet( 'direction', value );
      this._context.direction = value;
    },
    
    /*---------------------------------------------------------------------------*
    * CanvasPathMethods
    *----------------------------------------------------------------------------*/
    
    closePath: function() {
      command( 'closePath' );
      this._context.closePath();
    },
    
    moveTo: function( x, y ) {
      command( 'moveTo', [ x, y ] );
      this._context.moveTo( x, y );
    },
    
    lineTo: function( x, y ) {
      command( 'lineTo', [ x, y ] );
      this._context.lineTo( x, y );
    },
    
    quadraticCurveTo: function( cpx, cpy, x, y ) {
      command( 'quadraticCurveTo', [ cpx, cpy, x, y ] );
      this._context.quadraticCurveTo( cpx, cpy, x, y );
    },
    
    bezierCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) {
      command( 'bezierCurveTo', [ cp1x, cp1y, cp2x, cp2y, x, y ] );
      this._context.bezierCurveTo( cp1x, cp1y, cp2x, cp2y, x, y );
    },
    
    arcTo: function( x1, y1, x2, y2, radiusX, radiusY, rotation ) {
      command( 'arcTo', radiusY !== undefined ? [ x1, y1, x2, y2, radiusX, radiusY, rotation ] : [ x1, y1, x2, y2, radiusX ] );
      this._context.arcTo( x1, y1, x2, y2, radiusX, radiusY, rotation );
    },
    
    rect: function( x, y, w, h ) {
      command( 'rect', [ x, y, w, h ] );
      this._context.rect( x, y, w, h );
    },
    
    arc: function( x, y, radius, startAngle, endAngle, anticlockwise ) {
      command( 'arc', [ x, y, radius, startAngle, endAngle, anticlockwise ] );
      this._context.arc( x, y, radius, startAngle, endAngle, anticlockwise );
    },
    
    ellipse: function( x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      command( 'ellipse', [ x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ] );
      this._context.ellipse( x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    }
  };
  
  return DebugContext;
} );



// Copyright 2002-2014, University of Colorado Boulder

/**
 * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.
 *
 * See https://github.com/documentcloud/underscore/pull/986.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/extend',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  var extend = core.extend = function extend( obj ) {
    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
      if ( source ) {
        for ( var prop in source ) {
          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
        }
      }
    });
    return obj;
  };
  return extend;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Experimental prototype inheritance
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/inherit',['require','PHET_CORE/core','PHET_CORE/extend'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  var extend = require( 'PHET_CORE/extend' );
  
  /**
   * Experimental inheritance prototype, similar to Inheritance.inheritPrototype, but maintains
   * supertype.prototype.constructor while properly copying ES5 getters and setters.
   *
   * TODO: find problems with this! It's effectively what is being used by Scenery
   * TODO: consider inspecting arguments to see whether they are functions or just objects, to support
   *       something like inherit( subtype, supertypeA, supertypeB, properties )
   *
   * Usage:
   * function A() { scenery.Node.call( this ); };
   * inherit( scenery.Node, A, {
   *   customBehavior: function() { ... },
   *   isAnA: true
   * } );
   * new A().isAnA // true
   * new scenery.Node().isAnA // undefined
   * new A().constructor.name // 'A'
   *
   * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )
   * @param supertype           Constructor for the supertype.
   * @param prototypeProperties [optional] object containing properties that will be set on the prototype.
   * @param staticProperties [optional] object containing properties that will be set on the constructor function itself
   */
  var inherit = core.inherit = function inherit( supertype, subtype, prototypeProperties, staticProperties ) {
    assert && assert( typeof supertype === 'function' );
    
    function F() {}
    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype
    
    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy
      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely
      { constructor: subtype }, // overrides the constructor properly
      prototypeProperties       // [optional] additional properties for the prototype, as an object.
    );

    //Copy the static properties onto the subtype constructor so they can be accessed 'statically'
    extend( subtype, staticProperties );
    
    return subtype; // pass back the subtype so it can be returned immediately as a module export
  };

  return inherit;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A generic display block (TODO more docs once finished)
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/display/Block',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  scenery.Block = function Block() {
    
  };
  var Block = scenery.Block;
  
  inherit( Object, Block, {
    
  } );
  
  return Block;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A "backbone" block that controls a DOM element (usually a div) that contains other blocks with DOM/SVG/Canvas/WebGL content
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/display/BackboneBlock',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );
  
  scenery.BackboneBlock = function BackboneBlock() {
    this._domElement = document.createElement( 'div' );
  };
  var BackboneBlock = scenery.BackboneBlock;
  
  inherit( Block, BackboneBlock, {
    getDomElement: function() {
      return this._domElement;
    }
  } );
  
  return BackboneBlock;
} );


// Copyright 2002-2014, University of Colorado Boulder

define( 'DOT/dot',['require','ASSERT/assert','ASSERT/assert','PHET_CORE/phetAllocation'],function( require ) {
  
  
  window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
  window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
  
  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
  
  var dot = function dot() {
    switch ( arguments.length ) {
      case 2:
        return new dot.Vector2( arguments[0], arguments[1] );
      case 3:
        return new dot.Vector3( arguments[0], arguments[1], arguments[2] );
      case 4:
        return new dot.Vector4( arguments[0], arguments[1], arguments[2], arguments[3] );
      default:
        throw new Error( 'dot takes 2-4 arguments' );
    }
  };
  
  // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.
  dot.FastArray = window.Float64Array ? window.Float64Array : window.Array;
  
  // will be filled in by other modules
  return dot;
} );

// Copyright 2002-2014, University of Colorado

/**
 * Experimental object pooling mix-in
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/Poolable',['require','PHET_CORE/core','PHET_CORE/extend'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  var extend = require( 'PHET_CORE/extend' );
  
  /*
   * For option details, please see documentation inside this constructor body for now
   */
  var Poolable = core.Poolable = function Poolable( type, options ) {
    var proto = type.prototype;
    
    // defaults
    options = extend( {
      maxPoolSize: 50, // since we don't want to blow too much memory
      initialSize: 0
    }, options );
    
    var pool = type.pool = [];
    
    /*
     * For example: defaultFactory: function() { return new Vector2(); }
     */
    if ( options.defaultFactory ) {
      type.dirtyFromPool = function() {
        if ( pool.length ) {
          // return an instance in an arbitrary (dirty) state
          return pool.pop();
        } else {
          // else return a new default instance
          return options.defaultFactory();
        }
      };
      
      // fills the object pool up to n instances
      type.fillPool = function( n ) {
        // fill up the object pool to the initial size
        while ( pool.length < n ) {
          pool.push( options.defaultFactory() );
        }
      };
      
      // fill the pool initially to the initial size
      type.fillPool( options.initialSize );
    }
    
    /*
     * For example: constructorDuplicateFactory:
     *                function( pool ) {
     *                  return function( x, y ) {
     *                    if ( pool.length ) {
     *                      return pool.pop().set( x, y );
     *                    } else {
     *                      return new Vector2( x, y );
     *                    }
     *                  }
     *                }
     * It allows arbitrary creation (from the constructor / etc) or mutation (from the pooled instance).
     */
    if ( options.constructorDuplicateFactory ) {
      type.createFromPool = options.constructorDuplicateFactory( pool );
    }
    
    /*
     * Frees the object to the pool (instance.freeToPool())
     */
    proto.freeToPool = function() {
      if ( pool.length < options.maxPoolSize ) {
        pool.push( this );
      }
    };
  };
  return Poolable;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Utility functions for Dot, placed into the dot.X namespace.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Util',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference
  
  dot.Util = {
    testAssert: function() {
      return 'assert.dot: ' + ( assert ? 'true' : 'false' );
    },
    
    clamp: function( value, min, max ) {
      if ( value < min ) {
        return min;
      }
      else if ( value > max ) {
        return max;
      }
      else {
        return value;
      }
    },
    
    // returns a number between [min,max) with the same equivalence class as value mod (max-min)
    moduloBetweenDown: function( value, min, max ) {
      assert && assert( max > min, 'max > min required for moduloBetween' );
      
      var divisor = max - min;
      
      // get a partial result of value-min between [0,divisor)
      var partial = ( value - min ) % divisor;
      if ( partial < 0 ) {
        // since if value-min < 0, the remainder will give us a negative number
        partial += divisor;
      }
      
      return partial + min; // add back in the minimum value
    },
    
    // returns a number between (min,max] with the same equivalence class as value mod (max-min)
    moduloBetweenUp: function( value, min, max ) {
      return -Util.moduloBetweenDown( -value, -max, -min );
    },
    
    // Returns an array of integers from A to B (including both A to B)
    rangeInclusive: function( a, b ) {
      if ( b < a ) {
        return [];
      }
      var result = new Array( b - a + 1 );
      for ( var i = a; i <= b; i++ ) {
        result[i-a] = i;
      }
      return result;
    },
    
    // Returns an array of integers between A and B (excluding both A to B)
    rangeExclusive: function( a, b ) {
      return Util.rangeInclusive( a + 1, b - 1 );
    },
    
    toRadians: function( degrees ) {
      return Math.PI * degrees / 180;
    },
    
    toDegrees: function( radians ) {
      return 180 * radians / Math.PI;
    },
    
    // intersection between the line from p1-p2 and the line from p3-p4
    lineLineIntersection: function( p1, p2, p3, p4 ) {
      var x12 = p1.x - p2.x;
      var x34 = p3.x - p4.x;
      var y12 = p1.y - p2.y;
      var y34 = p3.y - p4.y;
      
      var denom = x12 * y34 - y12 * x34;
      
      var a = p1.x * p2.y - p1.y * p2.x;
      var b = p3.x * p4.y - p3.y * p4.x;
      
      return new dot.Vector2(
        ( a * x34 - x12 * b ) / denom,
        ( a * y34 - y12 * b ) / denom
      );
    },
    
    // assumes a sphere with the specified radius, centered at the origin
    sphereRayIntersection: function( radius, ray, epsilon ) {
      epsilon = epsilon === undefined ? 1e-5 : epsilon;

      // center is the origin for now, but leaving in computations so that we can change that in the future. optimize away if needed
      var center = new dot.Vector3();

      var rayDir = ray.dir;
      var pos = ray.pos;
      var centerToRay = pos.minus( center );

      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)
      var tmp = rayDir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - radius * radius );
      if ( det < epsilon ) {
        // ray misses sphere entirely
        return null;
      }

      var base = rayDir.dot( center ) - rayDir.dot( pos );
      var sqt = Math.sqrt( det ) / 2;

      // the "first" entry point distance into the sphere. if we are inside the sphere, it is behind us
      var ta = base - sqt;

      // the "second" entry point distance
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // sphere is behind ray, so don't return an intersection
        return null;
      }

      var hitPositionB = ray.pointAtDistance( tb );
      var normalB = hitPositionB.minus( center ).normalized();

      if ( ta < epsilon ) {
        // we are inside the sphere
        // in => out
        return {
          distance: tb,
          hitPoint: hitPositionB,
          normal: normalB.negated(),
          fromOutside: false
        };
      }
      else {
        // two possible hits
        var hitPositionA = ray.pointAtDistance( ta );
        var normalA = hitPositionA.minus( center ).normalized();

        // close hit, we have out => in
        return {
          distance: ta,
          hitPoint: hitPositionA,
          normal: normalA,
          fromOutside: true
        };
      }
    },
    
    // return an array of real roots of ax^2 + bx + c = 0
    solveQuadraticRootsReal: function( a, b, c ) {
      var epsilon = 1E7;
      
      //We need to test whether a is several orders of magnitude less than b or c. If so, return the result as a solution to the linear (easy) equation
      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon ) {
        return [ -c / b ];
      }
      
      var discriminant = b * b - 4 * a * c;
      if ( discriminant < 0 ) {
        return [];
      }
      var sqrt = Math.sqrt( discriminant );
      // TODO: how to handle if discriminant is 0? give unique root or double it?
      // TODO: probably just use Complex for the future
      return [
        ( -b - sqrt ) / ( 2 * a ),
        ( -b + sqrt ) / ( 2 * a )
      ];
    },
    
    // return an array of real roots of ax^3 + bx^2 + cx + d = 0
    solveCubicRootsReal: function( a, b, c, d ) {
      // TODO: a Complex type!
      
      //We need to test whether a is several orders of magnitude less than b, c, d
      var epsilon = 1E7;
      
      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {
        return Util.solveQuadraticRootsReal( b, c, d );
      }
      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {
        return Util.solveQuadraticRootsReal( a, b, c );
      }
      
      b /= a;
      c /= a;
      d /= a;
      
      var q = ( 3.0 * c - ( b * b ) ) / 9;
      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;
      var discriminant = q  * q  * q + r  * r;
      var b3 = b / 3;
      
      if ( discriminant > 0 ) {
        // a single real root
        var dsqrt = Math.sqrt( discriminant );
        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];
      }
      
      // three real roots
      if ( discriminant === 0 ) {
        // contains a double root
        var rsqrt = Util.cubeRoot( r );
        var doubleRoot = b3 - rsqrt;
        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];
      } else {
        // all unique
        var qX = -q * q * q;
        qX = Math.acos( r / Math.sqrt( qX ) );
        var rr = 2 * Math.sqrt( -q );
        return [
          -b3 + rr * Math.cos( qX / 3 ),
          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),
          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )
        ];
      }
    },
    
    cubeRoot: function( x ) {
      return x >= 0 ? Math.pow( x, 1/3 ) : -Math.pow( -x, 1/3 );
    },

    // Linearly interpolate two points and evaluate the line equation for a third point
    // f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>
    linear: function( a1, a2, b1, b2, a3 ) {
      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;
    },

    /**
     * A predictable implementation of toFixed.
     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,
     * because the spec doesn't specify whether to round or floor.
     * @param {number} number
     * @param {number} decimalPlaces
     * @returns {string}
     */
    toFixed: function( number, decimalPlaces ) {
      var multiplier = Math.pow( 10, decimalPlaces );
      var value = Math.round( number * multiplier ) / multiplier;
      return value.toFixed( decimalPlaces );
    },

    // Convenience for returning a number instead of a string.
    toFixedNumber: function( number, decimalPlaces ) {
      return parseFloat( Util.toFixed( number, decimalPlaces ) );
    },

    isInteger: function( number ) {
      return Math.floor( number ) === number;
    },

    /*
     * Computes the intersection of two line segments. Algorithm taked from Paul Bourke, 1989:
     * http://astronomy.swin.edu.au/~pbourke/geometry/lineline2d/
     * Ported from MathUtil.java on 9/20/2013 by @samreid
     * line a goes from point 1->2 and line b goes from 3->4
     * @returns a Vector2 of the intersection point, or null if no intersection
     */
    lineSegmentIntersection: function( x1, y1, x2, y2, x3, y3, x4, y4 ) {
      var numA = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );
      var numB = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );
      var denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );

      // If denominator is 0, the lines are parallel or coincident
      if ( denom === 0 ) {
        return null;
      }
      else {
        var ua = numA / denom;
        var ub = numB / denom;

        // ua and ub must both be in the range 0 to 1 for the segments to have an intersection pt.
        if ( !( ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1 ) ) {
          return null;
        }
        else {
          var x = x1 + ua * ( x2 - x1 );
          var y = y1 + ua * ( y2 - y1 );
          return new dot.Vector2( x, y );
        }
      }
    },

    /**
     * Squared distance from a point to a line segment squared.
     * See http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
     *
     * @param point the point
     * @param a start point of a line segment
     * @param b end point of a line segment
     * @returns {Number}
     */
    distToSegmentSquared: function( point, a, b ) {
      var segmentLength = a.distanceSquared( b );
      if ( segmentLength === 0 ) { return point.distanceSquared( a ); }
      var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / segmentLength;
      return t < 0 ? point.distanceSquared( a ) :
             t > 1 ? point.distanceSquared( b ) :
             point.distanceSquared( new dot.Vector2( a.x + t * (b.x - a.x), a.y + t * (b.y - a.y) ) );
    },

    /**
     * Squared distance from a point to a line segment squared.
     * @param point the point
     * @param a start point of a line segment
     * @param b end point of a line segment
     * @returns {Number}
     */
    distToSegment: function( point, a, b ) { return Math.sqrt( this.distToSegmentSquared( point, a, b ) ); },
    
    arePointsCollinear: function( a, b, c, epsilon ) {
      if ( epsilon === undefined ) {
        epsilon = 0;
      }
      return Util.triangleArea( a, b, c ) <= epsilon;
    },
    
    triangleArea: function( a, b, c ) {
      return Math.abs( Util.triangleAreaSigned( a, b, c ) );
    },
    
    // TODO: investigate which way we want the sign (Canvas or WebGL style)
    triangleAreaSigned: function( a, b, c ) {
      return a.x * ( b.y - c.y ) + b.x * ( c.y - a.y ) + c.x * ( a.y - b.y );
    },

    log10: function( val ) {
      return Math.log( val ) / Math.LN10;
    }
  };
  var Util = dot.Util;
  
  // make these available in the main namespace directly (for now)
  dot.testAssert = Util.testAssert;
  dot.clamp = Util.clamp;
  dot.moduloBetweenDown = Util.moduloBetweenDown;
  dot.moduloBetweenUp = Util.moduloBetweenUp;
  dot.rangeInclusive = Util.rangeInclusive;
  dot.rangeExclusive = Util.rangeExclusive;
  dot.toRadians = Util.toRadians;
  dot.toDegrees = Util.toDegrees;
  dot.lineLineIntersection = Util.lineLineIntersection;
  dot.sphereRayIntersection = Util.sphereRayIntersection;
  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
  dot.solveCubicRootsReal = Util.solveCubicRootsReal;
  dot.cubeRoot = Util.cubeRoot;
  dot.linear = Util.linear;
  
  return Util;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Basic 2-dimensional vector
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Util' );
  // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency
  
  dot.Vector2 = function Vector2( x, y ) {
    // allow optional parameters
    this.x = x || 0;
    this.y = y || 0;
    
    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    
    phetAllocation && phetAllocation( 'Vector2' );
  };
  var Vector2 = dot.Vector2;
  
  Vector2.createPolar = function( magnitude, angle ) {
    return new Vector2().setPolar( magnitude, angle );
  };
  
  Vector2.prototype = {
    constructor: Vector2,
    isVector2: true,
    dimension: 2,
    
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },
    
    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y;
    },
    
    // the distance between this vector (treated as a point) and another point
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },

    // the distance between this vector (treated as a point) and another point specified as x:Number, y:Number
    distanceXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return Math.sqrt( dx * dx + dy * dy );
    },
    
    // the squared distance between this vector (treated as a point) and another point
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      return dx * dx + dy * dy;
    },

    // the squared distance between this vector (treated as a point) and another point as (x,y)
    distanceSquaredXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return dx * dx + dy * dy ;
    },
    
    dot: function( v ) {
      return this.x * v.x + this.y * v.y;
    },

    dotXY: function( vx, vy ) {
      return this.x * vx + this.y * vy;
    },
    
    equals: function( other ) {
      return this.x === other.x && this.y === other.y;
    },
    
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;
    },
    
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y );
    },
    
    /*---------------------------------------------------------------------------*
     * Immutables
     *----------------------------------------------------------------------------*/
    
    // create a copy, or if a vector is passed in, set that vector to our value
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      } else {
        return new Vector2( this.x, this.y );
      }
    },
    
    // z component of the equivalent 3-dimensional cross product (this.x, this.y,0) x (v.x, v.y, 0)
    crossScalar: function( v ) {
      return this.x * v.y - this.y * v.x;
    },
    
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( "Cannot normalize a zero-magnitude vector" );
      } else {
        return new Vector2( this.x / mag, this.y / mag );
      }
    },
    
    timesScalar: function( scalar ) {
      return new Vector2( this.x * scalar, this.y * scalar );
    },
    
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },
    
    componentTimes: function( v ) {
      return new Vector2( this.x * v.x, this.y * v.y );
    },
    
    plus: function( v ) {
      return new Vector2( this.x + v.x, this.y + v.y );
    },

    plusXY: function( x, y ) {
      return new Vector2( this.x + x, this.y + y );
    },

    plusScalar: function( scalar ) {
      return new Vector2( this.x + scalar, this.y + scalar );
    },
    
    minus: function( v ) {
      return new Vector2( this.x - v.x, this.y - v.y );
    },

    minusXY: function( x,y ) {
      return new Vector2( this.x - x, this.y - y );
    },
    
    minusScalar: function( scalar ) {
      return new Vector2( this.x - scalar, this.y - scalar );
    },
    
    dividedScalar: function( scalar ) {
      return new Vector2( this.x / scalar, this.y / scalar );
    },
    
    negated: function() {
      return new Vector2( -this.x, -this.y );
    },
    
    angle: function() {
      return Math.atan2( this.y, this.x );
    },
    
    // equivalent to a -PI/2 rotation (right hand rotation)
    perpendicular: function() {
      return new Vector2( this.y, -this.x );
    },
    
    angleBetween: function( v ) {
      var thisMagnitude = this.magnitude();
      var vMagnitude = v.magnitude();
      return Math.acos( dot.clamp( ( this.x * v.x + this.y * v.y ) / ( thisMagnitude * vMagnitude ), -1, 1 ) );
    },
    
    rotated: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return new Vector2( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },
    
    // linear interpolation from this (ratio=0) to vector (ratio=1)
    blend: function( vector, ratio ) {
      return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );
    },
    
    // average position between this and the provided vector
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },
    
    toString: function() {
      return 'Vector2(' + this.x + ', ' + this.y + ')';
    },
    
    toVector3: function() {
      return new dot.Vector3( this.x, this.y );
    },
    
    /*---------------------------------------------------------------------------*
     * Mutables
     *----------------------------------------------------------------------------*/
    
    // our core three functions which all mutation should go through
    setXY: function( x, y ) {
      this.x = x;
      this.y = y;
      return this;
    },
    setX: function( x ) {
      this.x = x;
      return this;
    },
    setY: function( y ) {
      this.y = y;
      return this;
    },
    
    set: function( v ) {
      return this.setXY( v.x, v.y );
    },

    //Sets the magnitude of the vector, keeping the same direction (though a negative magnitude will flip the vector direction)
    setMagnitude: function( m ) {
      var scale = m / this.magnitude();
      return this.multiplyScalar( scale );
    },
    
    add: function( v ) {
      return this.setXY( this.x + v.x, this.y + v.y );
    },

    addXY: function( x, y ) {
      return this.setXY( this.x + x, this.y + y );
    },
    
    addScalar: function( scalar ) {
      return this.setXY( this.x + scalar, this.y + scalar );
    },
    
    subtract: function( v ) {
      return this.setXY( this.x - v.x, this.y - v.y );
    },
    
    subtractScalar: function( scalar ) {
      return this.setXY( this.x - scalar, this.y - scalar );
    },
    
    multiplyScalar: function( scalar ) {
      return this.setXY( this.x * scalar, this.y * scalar );
    },
    
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },
    
    componentMultiply: function( v ) {
      return this.setXY( this.x * v.x, this.y * v.y );
    },
    
    divideScalar: function( scalar ) {
      return this.setXY( this.x / scalar, this.y / scalar );
    },
    
    negate: function() {
      return this.setXY( -this.x, -this.y );
    },
    
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( "Cannot normalize a zero-magnitude vector" );
      } else {
        return this.divideScalar( mag );
      }
    },
    
    setPolar: function( magnitude, angle ) {
      return this.setXY( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );
    }
    
  };
  
  // experimental object pooling
  /* jshint -W064 */
  Poolable( Vector2, {
    defaultFactory: function() { return new Vector2(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y );
        } else {
          return new Vector2( x, y );
        }
      };
    }
  } );
  
  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *----------------------------------------------------------------------------*/
  Vector2.Immutable = function ImmutableVector2( x, y ) {
    Vector2.call( this, x, y );
  };
  var Immutable = Vector2.Immutable;
  
  inherit( Vector2, Immutable );
  
  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[mutableFunctionName] = function() {
      throw new Error( "Cannot call mutable method '" + mutableFunctionName + "' on immutable Vector2" );
    };
  };
  
  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXY' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  
  // helpful immutable constants
  Vector2.ZERO = new Immutable( 0, 0 );
  Vector2.X_UNIT = new Immutable( 1, 0 );
  Vector2.Y_UNIT = new Immutable( 0, 1 );
  
  return Vector2;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Basic 4-dimensional vector
 *
 * TODO: sync with Vector2 changes
 * TODO: add quaternion extension
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector4',['require','DOT/dot','DOT/Util'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  require( 'DOT/Util' );
  // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency
  
  dot.Vector4 = function Vector4( x, y, z, w ) {
    // allow optional parameters
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1; // since w could be zero!
  };
  var Vector4 = dot.Vector4;
  
  Vector4.prototype = {
    constructor: Vector4,
    isVector4: true,
    dimension: 4,

    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    magnitudeSquared: function() {
      this.dot( this );
    },
    
    // the distance between this vector (treated as a point) and another point
    distance: function( point ) {
      return this.minus( point ).magnitude();
    },
    
    // the squared distance between this vector (treated as a point) and another point
    distanceSquared: function( point ) {
      return this.minus( point ).magnitudeSquared();
    },

    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );
    },
    
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
    },
    
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *----------------------------------------------------------------------------*/
    
    // create a copy, or if a vector is passed in, set that vector to our value
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      } else {
        return new Vector4( this.x, this.y, this.z, this.w );
      }
    },
    
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( "Cannot normalize a zero-magnitude vector" );
      }
      else {
        return new Vector4( this.x / mag, this.y / mag, this.z / mag, this.w / mag );
      }
    },

    timesScalar: function( scalar ) {
      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },

    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    componentTimes: function( v ) {
      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },

    plus: function( v ) {
      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },

    plusScalar: function( scalar ) {
      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },

    minus: function( v ) {
      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },

    minusScalar: function( scalar ) {
      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },

    dividedScalar: function( scalar ) {
      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },

    negated: function() {
      return new Vector4( -this.x, -this.y, -this.z, -this.w );
    },

    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },
    
    // linear interpolation from this (ratio=0) to vector (ratio=1)
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },
    
    // average position between this and the provided vector
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    toString: function() {
      return "Vector4(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
    },

    toVector3: function() {
      return new dot.Vector3( this.x, this.y, this.z );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     *----------------------------------------------------------------------------*/
    
    // our core mutables (all mutation should go through these)
    setXYZW: function( x, y, z, w ) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },
    setX: function( x ) {
      this.x = x;
      return this;
    },
    setY: function( y ) {
      this.y = y;
      return this;
    },
    setZ: function( z ) {
      this.z = z;
      return this;
    },
    setW: function( w ) {
      this.w = w;
      return this;
    },
    
    set: function( v ) {
      return this.setXYZW( v.x, v.y, v.z, v.w );
    },

    add: function( v ) {
      return this.setXYZW( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },

    addScalar: function( scalar ) {
      return this.setXYZW( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },

    subtract: function( v ) {
      return this.setXYZW( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },

    subtractScalar: function( scalar ) {
      return this.setXYZW( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },
    
    multiplyScalar: function( scalar ) {
      return this.setXYZW( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },
    
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    componentMultiply: function( v ) {
      return this.setXYZW( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },

    divideScalar: function( scalar ) {
      return this.setXYZW( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },

    negate: function() {
      return this.setXYZW( -this.x, -this.y, -this.z, -this.w );
    },
    
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( "Cannot normalize a zero-magnitude vector" );
      } else {
        return this.divideScalar( mag );
      }
      return this;
    }
  };

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *----------------------------------------------------------------------------*/
  Vector4.Immutable = function( x, y, z, w ) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1;
  };
  var Immutable = Vector4.Immutable;

  Immutable.prototype = new Vector4();
  Immutable.prototype.constructor = Immutable;

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[mutableFunctionName] = function() {
      throw new Error( "Cannot call mutable method '" + mutableFunctionName + "' on immutable Vector4" );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXYZW' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );
  Immutable.mutableOverrideHelper( 'setW' );

  // helpful immutable constants
  Vector4.ZERO = new Immutable( 0, 0, 0, 0 );
  Vector4.X_UNIT = new Immutable( 1, 0, 0, 0 );
  Vector4.Y_UNIT = new Immutable( 0, 1, 0, 0 );
  Vector4.Z_UNIT = new Immutable( 0, 0, 1, 0 );
  Vector4.W_UNIT = new Immutable( 0, 0, 0, 1 );
  
  return Vector4;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Basic 3-dimensional vector
 *
 * TODO: sync with Vector2 changes
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector3',['require','DOT/dot','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  require( 'DOT/Util' );
  require( 'DOT/Vector2' );
  require( 'DOT/Vector4' );

  dot.Vector3 = function Vector3( x, y, z ) {
    // allow optional parameters
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  };
  var Vector3 = dot.Vector3;

  Vector3.prototype = {
    constructor: Vector3,
    isVector3: true,
    dimension: 3,

    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    magnitudeSquared: function() {
      return this.dot( this );
    },
    
    // the distance between this vector (treated as a point) and another point
    distance: function( point ) {
      return this.minus( point ).magnitude();
    },
    
    // the squared distance between this vector (treated as a point) and another point
    distanceSquared: function( point ) {
      return this.minus( point ).magnitudeSquared();
    },

    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );
    },
    
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z;
    },
    
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *----------------------------------------------------------------------------*/
    
    // create a copy, or if a vector is passed in, set that vector to our value
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      } else {
        return new Vector3( this.x, this.y, this.z );
      }
    },

    cross: function( v ) {
      return new Vector3(
          this.y * v.z - this.z * v.y,
          this.z * v.x - this.x * v.z,
          this.x * v.y - this.y * v.x
      );
    },

    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( "Cannot normalize a zero-magnitude vector" );
      }
      else {
        return new Vector3( this.x / mag, this.y / mag, this.z / mag );
      }
    },

    timesScalar: function( scalar ) {
      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );
    },

    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    componentTimes: function( v ) {
      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );
    },

    plus: function( v ) {
      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );
    },

    plusScalar: function( scalar ) {
      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );
    },

    minus: function( v ) {
      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );
    },

    minusScalar: function( scalar ) {
      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );
    },

    dividedScalar: function( scalar ) {
      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );
    },

    negated: function() {
      return new Vector3( -this.x, -this.y, -this.z );
    },

    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },
    
    // linear interpolation from this (ratio=0) to vector (ratio=1)
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },
    
    // average position between this and the provided vector
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    toString: function() {
      return "Vector3(" + this.x + ", " + this.y + ", " + this.z + ")";
    },

    toVector2: function() {
      return new dot.Vector2( this.x, this.y );
    },

    toVector4: function() {
      return new dot.Vector4( this.x, this.y, this.z );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     *----------------------------------------------------------------------------*/
    
    // our core mutables, all mutation should go through these
    setXYZ: function( x, y, z ) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },
    setX: function( x ) {
      this.x = x;
      return this;
    },
    setY: function( y ) {
      this.y = y;
      return this;
    },
    setZ: function( z ) {
      this.z = z;
      return this;
    },
    
    set: function( v ) {
      return this.setXYZ( v.x, v.y, v.z );
    },

    add: function( v ) {
      return this.setXYZ( this.x + v.x, this.y + v.y, this.z + v.z );
    },

    addScalar: function( scalar ) {
      return this.setXYZ( this.x + scalar, this.y + scalar, this.z + scalar );
    },

    subtract: function( v ) {
      return this.setXYZ( this.x - v.x, this.y - v.y, this.z - v.z );
    },

    subtractScalar: function( scalar ) {
      return this.setXYZ( this.x - scalar, this.y - scalar, this.z - scalar );
    },
    
    multiplyScalar: function( scalar ) {
      return this.setXYZ( this.x * scalar, this.y * scalar, this.z * scalar );
    },
    
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    componentMultiply: function( v ) {
      return this.setXYZ( this.x * v.x, this.y * v.y, this.z * v.z );
    },

    divideScalar: function( scalar ) {
      return this.setXYZ( this.x / scalar, this.y / scalar, this.z / scalar );
    },

    negate: function() {
      return this.setXYZ( -this.x, -this.y, -this.z );
    },
    
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( "Cannot normalize a zero-magnitude vector" );
      } else {
        return this.divideScalar( mag );
      }
    }
  };

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *----------------------------------------------------------------------------*/
  Vector3.Immutable = function( x, y, z ) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  };
  var Immutable = Vector3.Immutable;

  Immutable.prototype = new Vector3();
  Immutable.prototype.constructor = Immutable;

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[mutableFunctionName] = function() {
      throw new Error( "Cannot call mutable method '" + mutableFunctionName + "' on immutable Vector3" );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXYZ' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );

  // helpful immutable constants
  Vector3.ZERO = new Immutable( 0, 0, 0 );
  Vector3.X_UNIT = new Immutable( 1, 0, 0 );
  Vector3.Y_UNIT = new Immutable( 0, 1, 0 );
  Vector3.Z_UNIT = new Immutable( 0, 0, 1 );
  
  return Vector3;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * 4-dimensional Matrix
 *
 * TODO: consider adding affine flag if it will help performance (a la Matrix3)
 * TODO: get rotation angles
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  require( 'DOT/Vector3' );
  require( 'DOT/Vector4' );
  
  var Float32Array = window.Float32Array || Array;
  
  dot.Matrix4 = function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {

    // entries stored in column-major format
    this.entries = new Float32Array( 16 );

    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0, v03 || 0,
             v10 || 0, v11 === undefined ? 1 : v11, v12 || 0, v13 || 0,
             v20 || 0, v21 || 0, v22 === undefined ? 1 : v22, v23 || 0,
             v30 || 0, v31 || 0, v32 || 0, v33 === undefined ? 1 : v33,
             type );
  };
  var Matrix4 = dot.Matrix4;

  Matrix4.Types = {
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_3D: 2,
    SCALING: 3,
    AFFINE: 4

    // TODO: possibly add rotations
  };

  var Types = Matrix4.Types;

  Matrix4.identity = function() {
    return new Matrix4( 1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1,
              Types.IDENTITY );
  };

  Matrix4.translation = function( x, y, z ) {
    return new Matrix4( 1, 0, 0, x,
              0, 1, 0, y,
              0, 0, 1, z,
              0, 0, 0, 1,
              Types.TRANSLATION_3D );
  };

  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };

  Matrix4.scaling = function( x, y, z ) {
    // allow using one parameter to scale everything
    y = y === undefined ? x : y;
    z = z === undefined ? x : z;

    return new Matrix4( x, 0, 0, 0,
              0, y, 0, 0,
              0, 0, z, 0,
              0, 0, 0, 1,
              Types.SCALING );
  };

  // axis is a normalized Vector3, angle in radians.
  Matrix4.rotationAxisAngle = function( axis, angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var C = 1 - c;

    return new Matrix4( axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,
              axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,
              axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,
              0, 0, 0, 1,
              Types.AFFINE );
  };

  // TODO: add in rotation from quaternion, and from quat + translation

  Matrix4.rotationX = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4( 1, 0, 0, 0,
              0, c, -s, 0,
              0, s, c, 0,
              0, 0, 0, 1,
              Types.AFFINE );
  };

  Matrix4.rotationY = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4( c, 0, s, 0,
              0, 1, 0, 0,
              -s, 0, c, 0,
              0, 0, 0, 1,
              Types.AFFINE );
  };

  Matrix4.rotationZ = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4( c, -s, 0, 0,
              s, c, 0, 0,
              0, 0, 1, 0,
              0, 0, 0, 1,
              Types.AFFINE );
  };

  // aspect === width / height
  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {
    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );

    return new Matrix4( cotangent / aspect, 0, 0, 0,
              0, cotangent, 0, 0,
              0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),
              0, 0, -1, 0 );
  };

  Matrix4.prototype = {
    constructor: Matrix4,

    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
      this.entries[0] = v00;
      this.entries[1] = v10;
      this.entries[2] = v20;
      this.entries[3] = v30;
      this.entries[4] = v01;
      this.entries[5] = v11;
      this.entries[6] = v21;
      this.entries[7] = v31;
      this.entries[8] = v02;
      this.entries[9] = v12;
      this.entries[10] = v22;
      this.entries[11] = v32;
      this.entries[12] = v03;
      this.entries[13] = v13;
      this.entries[14] = v23;
      this.entries[15] = v33;
      
      // TODO: consider performance of the affine check here
      this.type = type === undefined ? ( ( v30 === 0 && v31 === 0 && v32 === 0 && v33 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },

    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {
      return this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );
    },

    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
    m00: function() { return this.entries[0]; },
    m01: function() { return this.entries[4]; },
    m02: function() { return this.entries[8]; },
    m03: function() { return this.entries[12]; },
    m10: function() { return this.entries[1]; },
    m11: function() { return this.entries[5]; },
    m12: function() { return this.entries[9]; },
    m13: function() { return this.entries[13]; },
    m20: function() { return this.entries[2]; },
    m21: function() { return this.entries[6]; },
    m22: function() { return this.entries[10]; },
    m23: function() { return this.entries[14]; },
    m30: function() { return this.entries[3]; },
    m31: function() { return this.entries[7]; },
    m32: function() { return this.entries[11]; },
    m33: function() { return this.entries[15]; },
    
    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m03() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m13() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() ) &&
             isFinite( this.m23() ) &&
             isFinite( this.m30() ) &&
             isFinite( this.m31() ) &&
             isFinite( this.m32() ) &&
             isFinite( this.m33() );
    },
    
    // the 3D translation, assuming multiplication with a homogeneous vector
    getTranslation: function() {
      return new dot.Vector3( this.m03(), this.m13(), this.m23() );
    },
    get translation() { return this.getTranslation(); },
    
    // returns a vector that is equivalent to ( T(1,0,0).magnitude(), T(0,1,0).magnitude(), T(0,0,1).magnitude() )
    // where T is a relative transform
    getScaleVector: function() {
      var m0003 = this.m00() + this.m03();
      var m1013 = this.m10() + this.m13();
      var m2023 = this.m20() + this.m23();
      var m3033 = this.m30() + this.m33();
      var m0103 = this.m01() + this.m03();
      var m1113 = this.m11() + this.m13();
      var m2123 = this.m21() + this.m23();
      var m3133 = this.m31() + this.m33();
      var m0203 = this.m02() + this.m03();
      var m1213 = this.m12() + this.m13();
      var m2223 = this.m22() + this.m23();
      var m3233 = this.m32() + this.m33();
      return new dot.Vector3( Math.sqrt( m0003 * m0003 + m1013 * m1013 + m2023 * m2023 + m3033 * m3033 ),
                              Math.sqrt( m0103 * m0103 + m1113 * m1113 + m2123 * m2123 + m3133 * m3133 ),
                              Math.sqrt( m0203 * m0203 + m1213 * m1213 + m2223 * m2223 + m3233 * m3233 ) );
    },
    get scaleVector() { return this.getScaleVector(); },
    
    getCSSTransform: function() {
      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility
      
      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
      
      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
      // NOTE: the toFixed calls are inlined for performance reasons
      return 'matrix3d(' + this.entries[0].toFixed( 20 ) + ',' +
                           this.entries[1].toFixed( 20 ) + ',' +
                           this.entries[2].toFixed( 20 ) + ',' +
                           this.entries[3].toFixed( 20 ) + ',' +
                           this.entries[4].toFixed( 20 ) + ',' +
                           this.entries[5].toFixed( 20 ) + ',' +
                           this.entries[6].toFixed( 20 ) + ',' +
                           this.entries[7].toFixed( 20 ) + ',' +
                           this.entries[8].toFixed( 20 ) + ',' +
                           this.entries[9].toFixed( 20 ) + ',' +
                           this.entries[10].toFixed( 20 ) + ',' +
                           this.entries[11].toFixed( 20 ) + ',' +
                           this.entries[12].toFixed( 20 ) + ',' +
                           this.entries[13].toFixed( 20 ) + ',' +
                           this.entries[14].toFixed( 20 ) + ',' +
                           this.entries[15].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },
    
    // exact equality
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() && this.m03() === m.m03() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() && this.m13() === m.m13() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22() && this.m23() === m.m23() &&
             this.m30() === m.m30() && this.m31() === m.m31() && this.m32() === m.m32() && this.m33() === m.m33();
    },
    
    // equality within a margin of error
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon &&
             Math.abs( this.m01() - m.m01() ) < epsilon &&
             Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m03() - m.m03() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon &&
             Math.abs( this.m11() - m.m11() ) < epsilon &&
             Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m13() - m.m13() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon &&
             Math.abs( this.m21() - m.m21() ) < epsilon &&
             Math.abs( this.m22() - m.m22() ) < epsilon &&
             Math.abs( this.m23() - m.m23() ) < epsilon &&
             Math.abs( this.m30() - m.m30() ) < epsilon &&
             Math.abs( this.m31() - m.m31() ) < epsilon &&
             Math.abs( this.m32() - m.m32() ) < epsilon &&
             Math.abs( this.m33() - m.m33() ) < epsilon;
    },
    
    /*---------------------------------------------------------------------------*
    * Immutable operations (returning a new matrix)
    *----------------------------------------------------------------------------*/
    
    copy: function() {
      return new Matrix4(
        this.m00(), this.m01(), this.m02(), this.m03(),
        this.m10(), this.m11(), this.m12(), this.m13(),
        this.m20(), this.m21(), this.m22(), this.m23(),
        this.m30(), this.m31(), this.m32(), this.m33(),
        this.type
      );
    },
    
    plus: function( m ) {
      return new Matrix4(
          this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),
          this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),
          this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),
          this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()
      );
    },

    minus: function( m ) {
      return new Matrix4(
          this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),
          this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),
          this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),
          this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()
      );
    },

    transposed: function() {
      return new Matrix4( this.m00(), this.m10(), this.m20(), this.m30(),
                this.m01(), this.m11(), this.m21(), this.m31(),
                this.m02(), this.m12(), this.m22(), this.m32(),
                this.m03(), this.m13(), this.m23(), this.m33() );
    },

    negated: function() {
      return new Matrix4( -this.m00(), -this.m01(), -this.m02(), -this.m03(),
                -this.m10(), -this.m11(), -this.m12(), -this.m13(),
                -this.m20(), -this.m21(), -this.m22(), -this.m23(),
                -this.m30(), -this.m31(), -this.m32(), -this.m33() );
    },

    inverted: function() {
      switch ( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_3D:
          return new Matrix4( 1, 0, 0, -this.m03(),
                              0, 1, 0, -this.m13(),
                              0, 0, 1, -this.m23(),
                              0, 0, 0, 1, Types.TRANSLATION_3D );
        case Types.SCALING:
          return new Matrix4( 1 / this.m00(), 0, 0, 0,
                              0, 1 / this.m11(), 0, 0,
                              0, 0, 1 / this.m22(), 0,
                              0, 0, 0, 1 / this.m33(), Types.SCALING );
        case Types.AFFINE:
        case Types.OTHER:
          var det = this.getDeterminant();
          if ( det !== 0 ) {
            return new Matrix4(
                ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,
                ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,
                ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,
                ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,
                ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,
                ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,
                ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,
                ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,
                ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,
                ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,
                ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,
                ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,
                ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,
                ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,
                ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,
                ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det
            );
          } else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break; // because JSHint totally can't tell that this can't be reached
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    timesMatrix: function( m ) {
      // I * M === M * I === I (the identity)
      if( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }
      
      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_3D ) {
          // faster combination of translations
          return new Matrix4( 1, 0, 0, this.m03() + m.m02(),
                              0, 1, 0, this.m13() + m.m12(),
                              0, 0, 1, this.m23() + m.m23(),
                              0, 0, 0, 1, Types.TRANSLATION_3D );
        } else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return new Matrix4( this.m00() * m.m00(), 0, 0, 0,
                              0, this.m11() * m.m11(), 0, 0,
                              0, 0, this.m22() * m.m22(), 0,
                              0, 0, 0, 1, Types.SCALING );
        }
      }
      
      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine
        
        // affine case
        return new Matrix4( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
                            this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
                            this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
                            this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03(),
                            this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
                            this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
                            this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
                            this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13(),
                            this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
                            this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
                            this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22(),
                            this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23(),
                            0, 0, 0, 1, Types.AFFINE );
      }
      
      // general case
      return new Matrix4( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),
                this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),
                this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),
                this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),
                this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),
                this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),
                this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),
                this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),
                this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),
                this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),
                this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),
                this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),
                this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),
                this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),
                this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),
                this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33() );
    },

    timesVector4: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;
      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },

    timesVector3: function( v ) {
      return this.timesVector4( v.toVector4() ).toVector3();
    },

    timesTransposeVector4: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;
      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;
      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;
      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },

    timesTransposeVector3: function( v ) {
      return this.timesTransposeVector4( v.toVector4() ).toVector3();
    },

    timesRelativeVector3: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;
      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;
      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },

    getDeterminant: function() {
      return this.m03() * this.m12() * this.m21() * this.m30() -
          this.m02() * this.m13() * this.m21() * this.m30() -
          this.m03() * this.m11() * this.m22() * this.m30() +
          this.m01() * this.m13() * this.m22() * this.m30() +
          this.m02() * this.m11() * this.m23() * this.m30() -
          this.m01() * this.m12() * this.m23() * this.m30() -
          this.m03() * this.m12() * this.m20() * this.m31() +
          this.m02() * this.m13() * this.m20() * this.m31() +
          this.m03() * this.m10() * this.m22() * this.m31() -
          this.m00() * this.m13() * this.m22() * this.m31() -
          this.m02() * this.m10() * this.m23() * this.m31() +
          this.m00() * this.m12() * this.m23() * this.m31() +
          this.m03() * this.m11() * this.m20() * this.m32() -
          this.m01() * this.m13() * this.m20() * this.m32() -
          this.m03() * this.m10() * this.m21() * this.m32() +
          this.m00() * this.m13() * this.m21() * this.m32() +
          this.m01() * this.m10() * this.m23() * this.m32() -
          this.m00() * this.m11() * this.m23() * this.m32() -
          this.m02() * this.m11() * this.m20() * this.m33() +
          this.m01() * this.m12() * this.m20() * this.m33() +
          this.m02() * this.m10() * this.m21() * this.m33() -
          this.m00() * this.m12() * this.m21() * this.m33() -
          this.m01() * this.m10() * this.m22() * this.m33() +
          this.m00() * this.m11() * this.m22() * this.m33();
    },
    get determinant() { return this.getDeterminant(); },

    toString: function() {
      return this.m00() + " " + this.m01() + " " + this.m02() + " " + this.m03() + "\n" +
           this.m10() + " " + this.m11() + " " + this.m12() + " " + this.m13() + "\n" +
           this.m20() + " " + this.m21() + " " + this.m22() + " " + this.m23() + "\n" +
           this.m30() + " " + this.m31() + " " + this.m32() + " " + this.m33();
    },

    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( "Cannot modify immutable matrix" );
      };
    }
  };

  // create an immutable
  Matrix4.IDENTITY = new Matrix4();
  Matrix4.IDENTITY.makeImmutable();
  
  return Matrix4;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * 3-dimensional Matrix
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix3',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  var FastArray = dot.FastArray;
  
  require( 'DOT/Vector2' );
  require( 'DOT/Vector3' );
  require( 'DOT/Matrix4' );

  var identityFastArray = new FastArray( 9 );
  identityFastArray[0] = 1;
  identityFastArray[4] = 1;
  identityFastArray[8] = 1;

  var createIdentityArray = FastArray === Array ?
                            function() {
                              return [1, 0, 0, 0, 1, 0, 0, 0, 1];
                            } :
                            function() {
                              return new FastArray( identityFastArray );
                            };

  //Create an identity matrix
  dot.Matrix3 = function Matrix3( argumentsShouldNotExist ) {

    //Make sure no clients are expecting to create a matrix with non-identity values
    assert && assert( !argumentsShouldNotExist, 'Matrix3 constructor should not be called with any arguments.  Use Matrix3.createFromPool()/Matrix3.identity()/etc.' );

    // entries stored in column-major format
    this.entries = createIdentityArray();

//    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0,
//        v10 || 0, v11 === undefined ? 1 : v11, v12 || 0,
//        v20 || 0, v21 || 0, v22 === undefined ? 1 : v22,
//      type );

    phetAllocation && phetAllocation( 'Matrix3' );
    this.type = Types.IDENTITY;
  };
  var Matrix3 = dot.Matrix3;
  
  Matrix3.Types = {
    // NOTE: if an inverted matrix of a type is not that type, change inverted()!
    // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!
    // NOTE: on adding a type, exaustively check all type usage
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_2D: 2,
    SCALING: 3,
    AFFINE: 4

    // TODO: possibly add rotations
  };

  var Types = Matrix3.Types;

  Matrix3.identity = function() { return Matrix3.dirtyFromPool().setToIdentity(); };
  Matrix3.translation = function( x, y ) { return Matrix3.dirtyFromPool().setToTranslation( x, y ); };
  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };
  Matrix3.scaling = function( x, y ) { return Matrix3.dirtyFromPool().setToScale( x, y ); };
  Matrix3.scale = Matrix3.scaling;
  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) { return Matrix3.dirtyFromPool().setToAffine( m00, m01, m02, m10, m11, m12 ); };
  Matrix3.rowMajor = function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) { return Matrix3.dirtyFromPool().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ); };

  // axis is a normalized Vector3, angle in radians.
  Matrix3.rotationAxisAngle = function( axis, angle ) { return Matrix3.dirtyFromPool().setToRotationAxisAngle( axis, angle ); };

  Matrix3.rotationX = function( angle ) { return Matrix3.dirtyFromPool().setToRotationX( angle ); };
  Matrix3.rotationY = function( angle ) { return Matrix3.dirtyFromPool().setToRotationY( angle ); };
  Matrix3.rotationZ = function( angle ) { return Matrix3.dirtyFromPool().setToRotationZ( angle ); };
  
  // standard 2d rotation
  Matrix3.rotation2 = Matrix3.rotationZ;
  
  Matrix3.rotationAround = function( angle, x, y ) {
    return Matrix3.translation( x, y ).timesMatrix( Matrix3.rotation2( angle ) ).timesMatrix( Matrix3.translation( -x, -y ) );
  };
  
  Matrix3.rotationAroundPoint = function( angle, point ) {
    return Matrix3.rotationAround( angle, point.x, point.y );
  };

  Matrix3.fromSVGMatrix = function( svgMatrix ) { return Matrix3.dirtyFromPool().setToSVGMatrix( svgMatrix ); };

  // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
  Matrix3.rotateAToB = function( a, b ) { return Matrix3.dirtyFromPool().setRotationAToB( a, b ); };

  Matrix3.prototype = {
    constructor: Matrix3,
    
    /*---------------------------------------------------------------------------*
    * "Properties"
    *----------------------------------------------------------------------------*/
    
    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
    m00: function() { return this.entries[0]; },
    m01: function() { return this.entries[3]; },
    m02: function() { return this.entries[6]; },
    m10: function() { return this.entries[1]; },
    m11: function() { return this.entries[4]; },
    m12: function() { return this.entries[7]; },
    m20: function() { return this.entries[2]; },
    m21: function() { return this.entries[5]; },
    m22: function() { return this.entries[8]; },
    
    isIdentity: function() {
      return this.type === Types.IDENTITY || this.equals( Matrix3.IDENTITY );
    },
    
    isAffine: function() {
      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );
    },
    
    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() );
    },
    
    getDeterminant: function() {
      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();
    },
    get determinant() { return this.getDeterminant(); },
    
    // the 2D translation, assuming multiplication with a homogeneous vector
    getTranslation: function() {
      return new dot.Vector2( this.m02(), this.m12() );
    },
    get translation() { return this.getTranslation(); },
    
    // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform
    getScaleVector: function() {
      return new dot.Vector2( Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),
                              Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );
    },
    get scaleVector() { return this.getScaleVector(); },
    
    // angle in radians for the 2d rotation from this matrix, between pi, -pi
    getRotation: function() {
      var transformedVector = this.timesVector2( dot.Vector2.X_UNIT ).minus( this.timesVector2( dot.Vector2.ZERO ) );
      return Math.atan2( transformedVector.y, transformedVector.x );
    },
    get rotation() { return this.getRotation(); },
    
    toMatrix4: function() {
      return new dot.Matrix4( this.m00(), this.m01(), this.m02(), 0,
                              this.m10(), this.m11(), this.m12(), 0,
                              this.m20(), this.m21(), this.m22(), 0,
                              0, 0, 0, 1 );
    },
    
    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22();
    },
    
    toSVGMatrix: function() {
      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();
      
      // top two rows
      result.a = this.m00();
      result.b = this.m10();
      result.c = this.m01();
      result.d = this.m11();
      result.e = this.m02();
      result.f = this.m12();
      
      return result;
    },
    
    getCSSTransform: function() {
      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility
      
      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
      
      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
      // NOTE: the toFixed calls are inlined for performance reasons
      return 'matrix(' + this.entries[0].toFixed( 20 ) + ',' + this.entries[1].toFixed( 20 ) + ',' + this.entries[3].toFixed( 20 ) + ',' + this.entries[4].toFixed( 20 ) + ',' + this.entries[6].toFixed( 20 ) + ',' + this.entries[7].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },
    
    getSVGTransform: function() {
      // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute
      
      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      function svgNumber( number ) {
        // largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
        return number.toFixed( 20 );
      }
      
      switch( this.type ) {
        case Types.IDENTITY:
          return '';
        case Types.TRANSLATION_2D:
          return 'translate(' + svgNumber( this.entries[6] ) + ',' + this.entries[7] + ')';
        case Types.SCALING:
          return 'scale(' + svgNumber( this.entries[0] ) + ( this.entries[0] === this.entries[4] ? '' : ',' + svgNumber( this.entries[4] ) ) + ')';
        default:
          return 'matrix(' + svgNumber( this.entries[0] ) + ',' + svgNumber( this.entries[1] ) + ',' + svgNumber( this.entries[3] ) + ',' + svgNumber( this.entries[4] ) + ',' + svgNumber( this.entries[6] ) + ',' + svgNumber( this.entries[7] ) + ')';
      }
    },
    get svgTransform() { return this.getSVGTransform(); },
    
    // returns a parameter object suitable for use with jQuery's .css()
    getCSSTransformStyles: function() {
      var transformCSS = this.getCSSTransform();
      
      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/
      return {
        // force iOS hardware acceleration
        '-webkit-perspective': 1000,
        '-webkit-backface-visibility': 'hidden',
        
        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-ms-transform': transformCSS,
        '-o-transform': transformCSS,
        'transform': transformCSS,
        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin
        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?
      };
    },
    get cssTransformStyles() { return this.getCSSTransformStyles(); },
    
    // exact equality
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();
    },
    
    // equality within a margin of error
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;
    },
    
    /*---------------------------------------------------------------------------*
    * Immutable operations (returns a new matrix)
    *----------------------------------------------------------------------------*/
    
    copy: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m01(), this.m02(),
        this.m10(), this.m11(), this.m12(),
        this.m20(), this.m21(), this.m22(),
        this.type
      );
    },
    
    plus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },
    
    minus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },
    
    transposed: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },
    
    negated: function() {
      return Matrix3.createFromPool(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },
    
    inverted: function() {
      var det;
      
      switch ( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return Matrix3.createFromPool( 1, 0, -this.m02(),
                              0, 1, -this.m12(),
                              0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return Matrix3.createFromPool( 1 / this.m00(), 0, 0,
                              0, 1 / this.m11(), 0,
                              0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          } else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break; // because JSHint totally can't tell that this can't be reached
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          } else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break; // because JSHint totally can't tell that this can't be reached
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },
    
    timesMatrix: function( m ) {
      // I * M === M * I === M (the identity)
      if( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }
      
      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_2D ) {
          // faster combination of translations
          return Matrix3.createFromPool( 1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        } else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return Matrix3.createFromPool( this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }
      
      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine
        
        // affine case
        return Matrix3.createFromPool( this.m00() * m.m00() + this.m01() * m.m10(),
            this.m00() * m.m01() + this.m01() * m.m11(),
            this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
            this.m10() * m.m00() + this.m11() * m.m10(),
            this.m10() * m.m01() + this.m11() * m.m11(),
            this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }
      
      // general case
      return Matrix3.createFromPool( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
                          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
                          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
                          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
                          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
                          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
                          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
                          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
                          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },
    
    /*---------------------------------------------------------------------------*
    * Immutable operations (returns new form of a parameter)
    *----------------------------------------------------------------------------*/
    
    timesVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02();
      var y = this.m10() * v.x + this.m11() * v.y + this.m12();
      return new dot.Vector2( x, y );
    },
    
    timesVector3: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },
    
    timesTransposeVector2: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y;
      var y = this.m01() * v.x + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },
    
    // TODO: this operation seems to not work for transformDelta2, should be vetted
    timesRelativeVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y;
      var y = this.m10() * v.y + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },
    
    /*---------------------------------------------------------------------------*
    * Mutable operations (changes this matrix)
    *----------------------------------------------------------------------------*/
    
    // every mutable method goes through rowMajor
    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
      this.entries[0] = v00;
      this.entries[1] = v10;
      this.entries[2] = v20;
      this.entries[3] = v01;
      this.entries[4] = v11;
      this.entries[5] = v21;
      this.entries[6] = v02;
      this.entries[7] = v12;
      this.entries[8] = v22;
      
      // TODO: consider performance of the affine check here
      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },
    
    set: function( matrix ) {
      return this.rowMajor( matrix.m00(), matrix.m01(), matrix.m02(),
                            matrix.m10(), matrix.m11(), matrix.m12(),
                            matrix.m20(), matrix.m21(), matrix.m22(),
                            matrix.type );
    },
    
    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
      return this;
    },
    
    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {
      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
    },
    
    add: function( m ) {
      return this.rowMajor(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },
    
    subtract: function( m ) {
      return this.rowMajor(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },
    
    transpose: function() {
      return this.rowMajor(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(),
        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },
    
    negate: function() {
      return this.rowMajor(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },
    
    invert: function() {
      var det;
      
      switch ( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return this.rowMajor( 1, 0, -this.m02(),
                                0, 1, -this.m12(),
                                0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return this.rowMajor( 1 / this.m00(), 0, 0,
                                0, 1 / this.m11(), 0,
                                0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          } else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break; // because JSHint totally can't tell that this can't be reached
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          } else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
          break; // because JSHint totally can't tell that this can't be reached
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },
    
    multiplyMatrix: function( m ) {
      // M * I === M (the identity)
      if ( m.type === Types.IDENTITY ) {
        // no change needed
        return this;
      }
      
      // I * M === M (the identity)
      if ( this.type === Types.IDENTITY ) {
        // copy the other matrix to us
        return this.set( m );
      }
      
      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_2D ) {
          // faster combination of translations
          return this.rowMajor( 1, 0, this.m02() + m.m02(),
                                0, 1, this.m12() + m.m12(),
                                0, 0, 1, Types.TRANSLATION_2D );
        } else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return this.rowMajor( this.m00() * m.m00(), 0, 0,
                                0, this.m11() * m.m11(), 0,
                                0, 0, 1, Types.SCALING );
        }
      }
      
      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine
        
        // affine case
        return this.rowMajor( this.m00() * m.m00() + this.m01() * m.m10(),
                              this.m00() * m.m01() + this.m01() * m.m11(),
                              this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
                              this.m10() * m.m00() + this.m11() * m.m10(),
                              this.m10() * m.m01() + this.m11() * m.m11(),
                              this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
                              0, 0, 1, Types.AFFINE );
      }
      
      // general case
      return this.rowMajor( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
                            this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
                            this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
                            this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
                            this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
                            this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
                            this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
                            this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
                            this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },
    
    setToIdentity: function() {
      return this.rowMajor( 1, 0, 0,
                            0, 1, 0,
                            0, 0, 1,
                            Types.IDENTITY );
    },
    
    setToTranslation: function( x, y ) {
      return this.rowMajor( 1, 0, x,
                            0, 1, y,
                            0, 0, 1,
                            Types.TRANSLATION_2D );
    },
    
    setToScale: function( x, y ) {
      // allow using one parameter to scale everything
      y = y === undefined ? x : y;

      return this.rowMajor( x, 0, 0,
                            0, y, 0,
                            0, 0, 1,
                            Types.SCALING );
    },
    
    // row major
    setToAffine: function( m00, m01, m02, m10, m11, m12 ) {
      return this.rowMajor( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );
    },
    
    // axis is a normalized Vector3, angle in radians.
    setToRotationAxisAngle: function( axis, angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      var C = 1 - c;

      return this.rowMajor( axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,
                            axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,
                            axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,
                            Types.OTHER );
    },
    
    setToRotationX: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor( 1, 0, 0,
                            0, c, -s,
                            0, s, c,
                            Types.OTHER );
    },
    
    setToRotationY: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor( c, 0, s,
                            0, 1, 0,
                            -s, 0, c,
                            Types.OTHER );
    },
    
    setToRotationZ: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor( c, -s, 0,
                            s, c, 0,
                            0, 0, 1,
                            Types.AFFINE );
    },
    
    setToSVGMatrix: function( svgMatrix ) {
      return this.rowMajor( svgMatrix.a, svgMatrix.c, svgMatrix.e,
                            svgMatrix.b, svgMatrix.d, svgMatrix.f,
                            0, 0, 1,
                            Types.AFFINE );
    },
    
    // a rotation matrix that rotates A to B (Vector3 instances), by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
    setRotationAToB: function( a, b ) {
      // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation
      var start = a;
      var end = b;

      var epsilon = 0.0001;

      var e, h, f;

      var v = start.cross( end );
      e = start.dot( end );
      f = ( e < 0 ) ? -e : e;

      // if "from" and "to" vectors are nearly parallel
      if ( f > 1.0 - epsilon ) {
        var c1, c2, c3;

        var x = new dot.Vector3(
          ( start.x > 0.0 ) ? start.x : -start.x,
          ( start.y > 0.0 ) ? start.y : -start.y,
          ( start.z > 0.0 ) ? start.z : -start.z
        );

        if ( x.x < x.y ) {
          if ( x.x < x.z ) {
            x = dot.Vector3.X_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }
        else {
          if ( x.y < x.z ) {
            x = dot.Vector3.Y_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }

        var u = x.minus( start );
        v = x.minus( end );

        c1 = 2.0 / u.dot( u );
        c2 = 2.0 / v.dot( v );
        c3 = c1 * c2 * u.dot( v );

        return this.rowMajor(
          -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x + 1,
          -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,
          -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,
          -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,
          -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y + 1,
          -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,
          -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,
          -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,
          -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z + 1
        );
      }
      else {
        // the most common case, unless "start"="end", or "start"=-"end"
        var hvx, hvz, hvxy, hvxz, hvyz;
        h = 1.0 / ( 1.0 + e );
        hvx = h * v.x;
        hvz = h * v.z;
        hvxy = hvx * v.y;
        hvxz = hvx * v.z;
        hvyz = hvz * v.y;

        return this.rowMajor(
          e + hvx * v.x, hvxy - v.z,        hvxz + v.y,
          hvxy + v.z,    e + h * v.y * v.y, hvyz - v.x,
          hvxz - v.y,    hvyz + v.x,        e + hvz * v.z
        );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * Mutable operations (changes the parameter)
    *----------------------------------------------------------------------------*/
    
    multiplyVector2: function( v ) {
      return v.setXY( this.m00() * v.x + this.m01() * v.y + this.m02(),
                      this.m10() * v.x + this.m11() * v.y + this.m12() );
    },
    
    multiplyVector3: function( v ) {
      return v.setXYZ( this.m00() * v.x + this.m01() * v.y + this.m02() * v.z,
                       this.m10() * v.x + this.m11() * v.y + this.m12() * v.z,
                       this.m20() * v.x + this.m21() * v.y + this.m22() * v.z );
    },
    
    multiplyTransposeVector2: function( v ) {
      return v.setXY( this.m00() * v.x + this.m10() * v.y,
                      this.m01() * v.x + this.m11() * v.y );
    },
    
    multiplyRelativeVector2: function( v ) {
      return v.setXY( this.m00() * v.x + this.m01() * v.y,
                      this.m10() * v.y + this.m11() * v.y );
    },
    
    // sets the transform of a Canvas 2D rendering context to the affine part of this matrix
    canvasSetTransform: function( context ) {
      context.setTransform(
        // inlined array entries
        this.entries[0],
        this.entries[1],
        this.entries[3],
        this.entries[4],
        this.entries[6],
        this.entries[7]
      );
    },
    
    // appends the affine part of this matrix to the Canvas 2D rendering context
    canvasAppendTransform: function( context ) {
      if ( this.type !== Types.IDENTITY ) {
        context.transform(
          // inlined array entries
          this.entries[0],
          this.entries[1],
          this.entries[3],
          this.entries[4],
          this.entries[6],
          this.entries[7]
        );
      }
    }
  };
  
  /* jshint -W064 */
  Poolable( Matrix3, {

    //The default factory creates an identity matrix
    defaultFactory: function() { return new Matrix3(); },

    constructorDuplicateFactory: function( pool ) {
      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
        var instance = pool.length ? pool.pop() : new Matrix3();
        return instance.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
      };
    }
  } );
  
  // create an immutable
  Matrix3.IDENTITY = Matrix3.identity();
  Matrix3.IDENTITY.makeImmutable();

  Matrix3.X_REFLECTION = Matrix3.createFromPool( -1, 0, 0,
    0, 1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.X_REFLECTION.makeImmutable();

  Matrix3.Y_REFLECTION = Matrix3.createFromPool( 1, 0, 0,
    0, -1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.Y_REFLECTION.makeImmutable();
  
  //Shortcut for translation times a matrix (without allocating a translation matrix), see scenery#119
  Matrix3.translationTimesMatrix = function( x, y, m ) {
    var type;
    if ( m.type === Types.IDENTITY || m.type === Types.TRANSLATION_2D ) {
      return Matrix3.createFromPool( 1, 0, m.m02() + x,
                          0, 1, m.m12() + y,
                          0, 0, 1,
                          Types.TRANSLATION_2D );
    } else if ( m.type === Types.OTHER ) {
      type = Types.OTHER;
    } else {
      type = Types.AFFINE;
    }
    return Matrix3.createFromPool( m.m00(), m.m01(), m.m02() + x,
      m.m10(), m.m11(), m.m12() + y,
      m.m20(), m.m21(), m.m22(),
      type );
  };
  
  Matrix3.printer = {
    print: function( matrix ) {
      console.log( matrix.toString() );
    }
  };
  
  return Matrix3;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * 2-dimensional ray
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Ray2',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );

  dot.Ray2 = function Ray2( pos, dir ) {
    this.pos = pos;
    this.dir = dir;
    
    assert && assert( Math.abs( dir.magnitude() - 1 ) < 0.01 );
    
    phetAllocation && phetAllocation( 'Ray2' );
  };
  var Ray2 = dot.Ray2;

  Ray2.prototype = {
    constructor: Ray2,

    shifted: function( distance ) {
      return new Ray2( this.pointAtDistance( distance ), this.dir );
    },

    pointAtDistance: function( distance ) {
      return this.pos.plus( this.dir.timesScalar( distance ) );
    },

    toString: function() {
      return this.pos.toString() + " => " + this.dir.toString();
    }
  };
  
  return Ray2;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Forward and inverse transforms with 3x3 matrices
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Transform3',['require','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {
  

  var dot = require( 'DOT/dot' );
  
  require( 'DOT/Matrix3' );
  require( 'DOT/Vector2' );
  require( 'DOT/Ray2' );

  // takes a 4x4 matrix
  dot.Transform3 = function Transform3( matrix ) {
    this.listeners = [];
    
    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices
    this.setMatrix( matrix === undefined ? dot.Matrix3.IDENTITY : matrix );
    
    phetAllocation && phetAllocation( 'Transform3' );
  };
  var Transform3 = dot.Transform3;

  Transform3.prototype = {
    constructor: Transform3,
    
    /*---------------------------------------------------------------------------*
    * mutators
    *----------------------------------------------------------------------------*/

    setMatrix: function( matrix ) {
      // TODO: performance: don't notify or handle instances where the matrix is detected to be the identity matrix?
      assert && assert( matrix instanceof dot.Matrix3 );

      assert && assert( matrix.isFinite(),'Matrix was suspicious' );

      //Temporary solution: if the programmer tried to set the top, bottom, etc of a node without defined bounds, do a no-op
      //In the future, this should be replaced with the assertion above, once we have tested that everything is working properly
      if ( !matrix.isFinite() ) {
        return;
      }
      
      var oldMatrix = this.matrix;
      var length = this.listeners.length;
      var i;
      
      // notify listeners before the change
      for ( i = 0; i < length; i++ ) {
        this.listeners[i].before( matrix, oldMatrix );
      }
      
      this.matrix = matrix;
      
      // compute these lazily
      this.inverse = null;
      this.matrixTransposed = null;
      this.inverseTransposed = null;
      
      // notify listeners after the change
      for ( i = 0; i < length; i++ ) {
        this.listeners[i].after( matrix, oldMatrix );
      }
    },
    
    prepend: function( matrix ) {
      this.setMatrix( matrix.timesMatrix( this.matrix ) );
    },

    //Simpler case of prepending a translation without having to allocate a matrix for it, see scenery#119
    prependTranslation: function( x, y ) {
      this.setMatrix( dot.Matrix3.translationTimesMatrix( x, y, this.matrix ) );
    },

    append: function( matrix ) {
      this.setMatrix( this.matrix.timesMatrix( matrix ) );
    },

    prependTransform: function( transform ) {
      this.prepend( transform.matrix );
    },

    appendTransform: function( transform ) {
      this.append( transform.matrix );
    },

    applyToCanvasContext: function( context ) {
      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );
    },
    
    /*---------------------------------------------------------------------------*
    * getters
    *----------------------------------------------------------------------------*/
    
    // uses the same matrices, for use cases where the matrices are considered immutable
    copy: function() {
      var transform = new Transform3( this.matrix );
      transform.inverse = this.inverse;
      transform.matrixTransposed = this.matrixTransposed;
      transform.inverseTransposed = this.inverseTransposed;
    },
    
    // copies matrices, for use cases where the matrices are considered mutable
    deepCopy: function() {
      var transform = new Transform3( this.matrix.copy() );
      transform.inverse = this.inverse ? this.inverse.copy() : null;
      transform.matrixTransposed = this.matrixTransposed ? this.matrixTransposed.copy() : null;
      transform.inverseTransposed = this.inverseTransposed ? this.inverseTransposed.copy() : null;
    },
    
    getMatrix: function() {
      return this.matrix;
    },
    
    getInverse: function() {
      if ( this.inverse === null ) {
        this.inverse = this.matrix.inverted();
      }
      return this.inverse;
    },
    
    getMatrixTransposed: function() {
      if ( this.matrixTransposed === null ) {
        this.matrixTransposed = this.matrix.transposed();
      }
      return this.matrixTransposed;
    },
    
    getInverseTransposed: function() {
      if ( this.inverseTransposed === null ) {
        this.inverseTransposed = this.getInverse().transposed();
      }
      return this.inverseTransposed;
    },
    
    isIdentity: function() {
      return this.matrix.type === dot.Matrix3.Types.IDENTITY;
    },
    
    isFinite: function() {
      return this.matrix.isFinite();
    },

    /*---------------------------------------------------------------------------*
     * forward transforms (for Vector2 or scalar)
     *----------------------------------------------------------------------------*/

    // transform a position (includes translation)
    transformPosition2: function( vec2 ) {
      return this.matrix.timesVector2( vec2 );
    },

    // transform a vector (exclude translation)
    transformDelta2: function( vec2 ) {
      var m = this.getMatrix();
      // m . vec2 - m . Vector2.ZERO
      return new dot.Vector2( m.m00() * vec2.x + m.m01() * vec2.y, m.m10() * vec2.x + m.m11() * vec2.y );
    },

    // transform a normal vector (different than a normal vector)
    transformNormal2: function( vec2 ) {
      return this.getInverse().timesTransposeVector2( vec2 );
    },
    
    transformX: function( x ) {
      var m = this.getMatrix();
      // TODO: ensure assertions are stripped out
      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },
    
    transformY: function( y ) {
      var m = this.getMatrix();
      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },
    
    transformDeltaX: function( x ) {
      var m = this.getMatrix();
      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
      // same as this.transformDelta2( new dot.Vector2( x, 0 ) ).x;
      return m.m00() * x;
    },
    
    transformDeltaY: function( y ) {
      var m = this.getMatrix();
      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
      // same as this.transformDelta2( new dot.Vector2( 0, y ) ).y;
      return m.m11() * y;
    },
    
    transformBounds2: function( bounds2 ) {
      return bounds2.transformed( this.matrix );
    },
    
    transformShape: function( shape ) {
      return shape.transformed( this.matrix );
    },
    
    transformRay2: function( ray ) {
      return new dot.Ray2( this.transformPosition2( ray.pos ), this.transformDelta2( ray.dir ).normalized() );
    },

    /*---------------------------------------------------------------------------*
     * inverse transforms (for Vector2 or scalar)
     *----------------------------------------------------------------------------*/

    inversePosition2: function( vec2 ) {
      return this.getInverse().timesVector2( vec2 );
    },

    inverseDelta2: function( vec2 ) {
      var m = this.getInverse();
      // m . vec2 - m . Vector2.ZERO
      return new dot.Vector2( m.m00() * vec2.x + m.m01() * vec2.y, m.m10() * vec2.x + m.m11() * vec2.y );
    },

    inverseNormal2: function( vec2 ) {
      return this.matrix.timesTransposeVector2( vec2 );
    },
    
    inverseX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },
    
    inverseY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },
    
    inverseDeltaX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      // same as this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;
      return m.m00() * x;
    },

    inverseDeltaY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      // same as this.inverseDelta2( new dot.Vector2( 0, y ) ).y;
      return m.m11() * y;
    },
    
    inverseBounds2: function( bounds2 ) {
      return bounds2.transformed( this.getInverse() );
    },
    
    inverseShape: function( shape ) {
      return shape.transformed( this.getInverse() );
    },
    
    inverseRay2: function( ray ) {
      return new dot.Ray2( this.inversePosition2( ray.pos ), this.inverseDelta2( ray.dir ).normalized() );
    },
    
    /*---------------------------------------------------------------------------*
    * listeners
    *----------------------------------------------------------------------------*/
    
    // note: listener.before( matrix, oldMatrix ) will be called before the change, listener.after( matrix, oldMatrix ) will be called after
    addTransformListener: function( listener ) {
      assert && assert( !_.contains( this.listeners, listener ) );
      this.listeners.push( listener );
    },
    
    // useful for making sure the listener is triggered first
    prependTransformListener: function( listener ) {
      assert && assert( !_.contains( this.listeners, listener ) );
      this.listeners.unshift( listener );
    },
    
    removeTransformListener: function( listener ) {
      assert && assert( _.contains( this.listeners, listener ) );
      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
    }
  };
  
  return Transform3;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * A 2D rectangle-shaped bounded area (bounding box)
 *
 * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not
 * store these with the Bounds2 instance, since we want to lower the memory footprint.
 *
 * minX, minY, maxX, and maxY are actually stored. We don't do x,y,width,height because this can't properly express
 * semi-infinite bounds (like a half-plane), or easily handle what Bounds2.NOTHING and Bounds2.EVERYTHING do with
 * the constructive solid areas.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Bounds2',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  
  require( 'DOT/Vector2' );

  //Temporary instances to be used in the transform method.
  var scratchVector2 = new dot.Vector2();

  // not using x,y,width,height so that it can handle infinity-based cases in a better way
  dot.Bounds2 = function Bounds2( minX, minY, maxX, maxY ) {
    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
    
    phetAllocation && phetAllocation( 'Bounds2' );
  };
  var Bounds2 = dot.Bounds2;

  Bounds2.prototype = {
    constructor: Bounds2,
    
    isBounds: true,
    dimension: 2,
    
    /*---------------------------------------------------------------------------*
    * Properties
    *----------------------------------------------------------------------------*/
    
    getWidth: function() { return this.maxX - this.minX; },
    get width() { return this.getWidth(); },
    
    getHeight: function() { return this.maxY - this.minY; },
    get height() { return this.getHeight(); },
    
    /* 
     * Convenience locations
     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
     *
     *             minX (x)     centerX        maxX
     *          ---------------------------------------
     * minY (y) | leftTop     centerTop     rightTop
     * centerY  | leftCenter  center        rightCenter
     * maxY     | leftBottom  centerBottom  rightBottom
     */
    getX: function() { return this.minX; },
    get x() { return this.getX(); },
    getY: function() { return this.minY; },
    get y() { return this.getY(); },
    
    getMinX: function() { return this.minX; },
    get left() { return this.minX; },
    getMinY: function() { return this.minY; },
    get top() { return this.minY; },
    getMaxX: function() { return this.maxX; },
    get right() { return this.maxX; },
    getMaxY: function() { return this.maxY; },
    get bottom() { return this.maxY; },
    
    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
    get centerX() { return this.getCenterX(); },
    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
    get centerY() { return this.getCenterY(); },
    
    getLeftTop: function() { return new dot.Vector2( this.minX, this.minY ); },
    get leftTop() { return this.getLeftTop(); },
    getCenterTop: function() { return new dot.Vector2( this.getCenterX(), this.minY ); },
    get centerTop() { return this.getCenterTop(); },
    getRightTop: function() { return new dot.Vector2( this.maxX, this.minY ); },
    get rightTop() { return this.getRightTop(); },
    getLeftCenter: function() { return new dot.Vector2( this.minX, this.getCenterY() ); },
    get leftCenter() { return this.getLeftCenter(); },
    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },
    get center() { return this.getCenter(); },
    getRightCenter: function() { return new dot.Vector2( this.maxX, this.getCenterY() ); },
    get rightCenter() { return this.getRightCenter(); },
    getLeftBottom: function() { return new dot.Vector2( this.minX, this.maxY ); },
    get leftBottom() { return this.getLeftBottom(); },
    getCenterBottom: function() { return new dot.Vector2( this.getCenterX(), this.maxY ); },
    get centerBottom() { return this.getCenterBottom(); },
    getRightBottom: function() { return new dot.Vector2( this.maxX, this.maxY ); },
    get rightBottom() { return this.getRightBottom(); },

    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },
    
    isFinite: function() {
      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );
    },
    
    isValid: function() {
      return !this.isEmpty() && this.isFinite();
    },
    
    // whether the coordinates are inside the bounding box (or on the boundary)
    containsCoordinates: function( x, y ) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    },
    
    // whether the point is inside the bounding box (or on the boundary)
    containsPoint: function( point ) {
      return this.containsCoordinates( point.x, point.y );
    },
    
    // whether this bounding box completely contains the argument bounding box
    containsBounds: function( bounds ) {
      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;
    },
    
    // whether the intersection is non-empty (if they share any part of a boundary, this will be true)
    intersectsBounds: function( bounds ) {
      // TODO: more efficient way of doing this?
      return !this.intersection( bounds ).isEmpty();
    },
    
    // distance to the closest point inside the Bounds2
    minimumDistanceToPointSquared: function( point ) {
      var closeX = point.x < this.minX ? this.minX : ( point.x > this.maxX ? this.maxX : null );
      var closeY = point.y < this.minY ? this.minY : ( point.y > this.maxY ? this.maxY : null );
      var d;
      if ( closeX === null && closeY === null ) {
        // inside, or on the boundary
        return 0;
      } else if ( closeX === null ) {
        // vertically directly above/below
        d = closeY - point.y;
        return d * d;
      } else if ( closeY === null ) {
        // horizontally directly to the left/right
        d = closeX - point.x;
        return d * d;
      } else {
        // corner case
        var dx = closeX - point.x;
        var dy = closeY - point.y;
        return dx * dx + dy * dy;
      }
    },
    
    // distance to the farthest point inside the Bounds2
    maximumDistanceToPointSquared: function( point ) {
      var x = point.x > this.getCenterX() ? this.minX : this.maxX;
      var y = point.y > this.getCenterY() ? this.minY : this.maxY;
      x -= point.x;
      y -= point.y;
      return x * x + y * y;
    },
    
    toString: function() {
      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';
    },
    
    equals: function( other ) {
      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;
    },
    
    equalsEpsilon: function( other, epsilon ) {
      epsilon = epsilon || 0;
      var thisFinite = this.isFinite();
      var otherFinite = other.isFinite();
      if ( thisFinite && otherFinite ) {
        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity
        return Math.abs( this.minX - other.minX ) < epsilon &&
               Math.abs( this.minY - other.minY ) < epsilon &&
               Math.abs( this.maxX - other.maxX ) < epsilon &&
               Math.abs( this.maxY - other.maxY ) < epsilon;
      } else if ( thisFinite !== otherFinite ) {
        return false; // one is finite, the other is not. definitely not equal
      } else if ( this === other ) {
        return true; // exact same instance, must be equal
      } else {
        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both
        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * Immutable operations
    *----------------------------------------------------------------------------*/
    
    // create a copy, or if bounds is passed in, set that bounds to our value
    copy: function( bounds ) {
      if ( bounds ) {
        return bounds.set( this );
      } else {
        return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );
      }
    },
    
    // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)
    union: function( bounds ) {
      return new Bounds2(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },
    intersection: function( bounds ) {
      return new Bounds2(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },
    // TODO: difference should be well-defined, but more logic is needed to compute
    
    withCoordinates: function( x, y ) {
      return new Bounds2(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },
    
    // like a union with a point-sized bounding box
    withPoint: function( point ) {
      return this.withCoordinates( point.x, point.y );
    },
    
    withMinX: function( minX ) { return new Bounds2( minX, this.minY, this.maxX, this.maxY ); },
    withMinY: function( minY ) { return new Bounds2( this.minX, minY, this.maxX, this.maxY ); },
    withMaxX: function( maxX ) { return new Bounds2( this.minX, this.minY, maxX, this.maxY ); },
    withMaxY: function( maxY ) { return new Bounds2( this.minX, this.minY, this.maxX, maxY ); },
    
    // copy rounded to integral values, expanding where necessary
    roundedOut: function() {
      return new Bounds2(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },
    
    // copy rounded to integral values, contracting where necessary
    roundedIn: function() {
      return new Bounds2(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },
    
    // transform a bounding box.
    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box
    transformed: function( matrix ) {
      return this.copy().transform( matrix );
    },
    
    // returns copy expanded on all sides by length d
    dilated: function( d ) {
      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },
    
    // dilates only in the x direction
    dilatedX: function( x ) {
      return new Bounds2( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },
    
    // dilates only in the y direction
    dilatedY: function( y ) {
      return new Bounds2( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },
    
    // dilate with different amounts in the x and y directions
    dilatedXY: function( x, y ) {
      return new Bounds2( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },
    
    // returns copy contracted on all sides by length d, or for x/y independently
    eroded: function( d ) { return this.dilated( -d ); },
    erodedX: function( x ) { return this.dilatedX( -x ); },
    erodedY: function( y ) { return this.dilatedY( -y ); },
    erodedXY: function( x, y ) { return this.dilatedXY( -x, -y ); },
    
    shiftedX: function( x ) {
      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },
    
    shiftedY: function( y ) {
      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },
    
    shifted: function( x, y ) {
      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },
    
    /*---------------------------------------------------------------------------*
    * Mutable operations
    *----------------------------------------------------------------------------*/
    
    // mutable core opreations (all other mutations should be called through these)
    setMinMax: function( minX, minY, maxX, maxY ) {
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
      return this;
    },
    setMinX: function( minX ) { this.minX = minX; return this; },
    setMinY: function( minY ) { this.minY = minY; return this; },
    setMaxX: function( maxX ) { this.maxX = maxX; return this; },
    setMaxY: function( maxY ) { this.maxY = maxY; return this; },
    
    set: function( bounds ) {
      return this.setMinMax( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );
    },
    
    // mutable union
    includeBounds: function( bounds ) {
      return this.setMinMax(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },
    
    // mutable intersection
    constrainBounds: function( bounds ) {
      return this.setMinMax(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },
    
    addCoordinates: function( x, y ) {
      return this.setMinMax(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },
    
    addPoint: function( point ) {
      return this.addCoordinates( point.x, point.y );
    },
    
    // round to integral values, expanding where necessary
    roundOut: function() {
      return this.setMinMax(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },
    
    // round to integral values, contracting where necessary
    roundIn: function() {
      return this.setMinMax(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },

    // transform a bounding box.
    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box
    transform: function( matrix ) {
      // if we contain no area, no change is needed
      if ( this.isEmpty() ) {
        return this;
      }
      
      // optimization to bail for identity matrices
      if ( matrix.isIdentity() ) {
        return this;
      }

      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.set( dot.Bounds2.NOTHING );
      
      // using mutable vector so we don't create excessive instances of Vector2 during this
      // make sure all 4 corners are inside this transformed bounding box

      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, maxY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, maxY ) ) );
      return this;
    },
    
    // expands on all sides by length d
    dilate: function( d ) {
      return this.setMinMax( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },
    
    // dilates only in the x direction
    dilateX: function( x ) {
      return this.setMinMax( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },
    
    // dilates only in the y direction
    dilateY: function( y ) {
      return this.setMinMax( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },
    
    // dilate with different amounts in the x and y directions
    dilateXY: function( x, y ) {
      return this.setMinMax( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },
    
    // contracts on all sides by length d, or for x/y independently
    erode: function( d ) { return this.dilate( -d ); },
    erodeX: function( x ) { return this.dilateX( -x ); },
    erodeY: function( y ) { return this.dilateY( -y ); },
    erodeXY: function( x, y ) { return this.dilateXY( -x, -y ); },
    
    shiftX: function( x ) {
      return this.setMinMax( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },
    
    shiftY: function( y ) {
      return this.setMinMax( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },
    
    shift: function( x, y ) {
      return this.setMinMax( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },

    /**
     * Find a point in the Bounds2 closest to the specified point.  Used for making sure a dragged object doesn't get outside the visible play area.
     * @param x x point to test
     * @param y y point to test
     * @param {Vector2} result optional Vector2 that can store the return value to avoid allocations
     * @returns {Vector2}
     */
    getClosestPoint: function( x, y, result ) {
      if ( result ) {
        result.setXY( x, y );
      }
      else {
        result = new dot.Vector2( x, y );
      }
      if ( result.x < this.minX ) { result.x = this.minX; }
      if ( result.x > this.maxX ) { result.x = this.maxX; }
      if ( result.y < this.minY ) { result.y = this.minY; }
      if ( result.y > this.maxY ) { result.y = this.maxY; }
      return result;
    }
  };
  
  Bounds2.rect = function( x, y, width, height ) {
    return new Bounds2( x, y, x + width, y + height );
  };
  
  // a volume-less point bounds, which can be dilated to form a centered bounds
  Bounds2.point = function( x, y ) {
    if ( x instanceof dot.Vector2 ) {
      var p = x;
      return new Bounds2( p.x, p.y, p.x, p.y );
    } else {
      return new Bounds2( x, y, x, y );
    }
  };
  
  // experimental object pooling
  /* jshint -W064 */
  Poolable( Bounds2, {
    defaultFactory: function() { return Bounds2.NOTHING.copy(); },
    constructorDuplicateFactory: function( pool ) {
      return function( minX, minY, maxX, maxY ) {
        if ( pool.length ) {
          return pool.pop().setMinMax( minX, minY, maxX, maxY );
        } else {
          return new Bounds2( minX, minY, maxX, maxY );
        }
      };
    }
  } );

  // specific bounds useful for operations
  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );
  
  return Bounds2;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally
 * since it prevents Require.js issues with circular dependencies.
 *
 * The returned kite object namespace may be incomplete if not all modules are listed as
 * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/kite',['require','ASSERT/assert','ASSERT/assert','PHET_CORE/phetAllocation'],function( require ) {
  
  
  window.assert = window.assert || require( 'ASSERT/assert' )( 'basic' );
  window.assertSlow = window.assertSlow || require( 'ASSERT/assert' )( 'slow', true );
  
  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
  
  var kite = {};
  
  // will be filled in by other modules
  return kite;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * A segment represents a specific curve with a start and end.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Segment',['require','KITE/kite','DOT/Util','DOT/Bounds2'],function( require ) {
  
  
  var kite = require( 'KITE/kite' );
  
  var DotUtil = require( 'DOT/Util' );
  var Bounds2 = require( 'DOT/Bounds2' );
  
  /*
   * Will contain (for segments):
   * properties (backed by ES5 getters, created usually lazily):
   * start        - start point of this segment
   * end          - end point of this segment
   * startTangent - the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)
   * endTangent   - the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)
   * bounds       - the bounding box for the segment
   *
   * methods:
   * positionAt( t )          - returns the position parametrically, with 0 <= t <= 1. this does NOT guarantee a constant magnitude tangent... don't feel like adding elliptical functions yet!
   * tangentAt( t )           - returns the non-normalized tangent (dx/dt, dy/dt) parametrically, with 0 <= t <= 1.
   * curvatureAt( t )         - returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)
   * subdivided( t )          - returns an array with 2 sub-segments, split at the parametric t value.
   * getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first
   * strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side
   * strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side
   * intersectsBounds         - whether this segment intersects the specified bounding box (not just the segment's bounding box, but the actual segment)
   * windingIntersection      - returns the winding number for intersection with a ray
   * getInteriorExtremaTs     - returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
   *
   * writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
   * transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix
   */
  kite.Segment = function Segment(){}; // no common construction for now
  var Segment = kite.Segment;
  
  var identityFunction = function identityFunction( x ) { return x; };
  
  Segment.prototype = {
    constructor: Segment,
    
    // tList should be a list of sorted t values from 0 <= t <= 1
    subdivisions: function( tList ) {
      // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization
      var right = this;
      var result = [];
      for ( var i = 0; i < tList.length; i++ ) {
        // assume binary subdivision
        var t = tList[i];
        var arr = right.subdivided( t );
        assert && assert( arr.length === 2 );
        result.push( arr[0] );
        right = arr[1];
        
        // scale up the remaining t values
        for ( var j = i + 1; j < tList.length; j++ ) {
          tList[j] = DotUtil.linear( t, 1, 0, 1, tList[j] );
        }
      }
      result.push( right );
      return result;
    },
    
    // return an array of segments from breaking this segment into monotone pieces
    subdividedIntoMonotone: function() {
      return this.subdivisions( this.getInteriorExtremaTs() );
    },
    
    /*
     * toPiecewiseLinearSegments( options ), with the following options provided:
     * - minLevels:                       how many levels to force subdivisions
     * - maxLevels:                       prevent subdivision past this level
     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve
     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments
     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                    instead of using our brute-force logic
     */
    toPiecewiseLinearSegments: function( options, minLevels, maxLevels, segments, start, end ) {
      // for the first call, initialize min/max levels from our options
      minLevels = minLevels === undefined ? options.minLevels : minLevels;
      maxLevels = maxLevels === undefined ? options.maxLevels : maxLevels;
      segments = segments || [];
      var pointMap = options.pointMap || identityFunction;
      
      // points mapped by the (possibly-nonlinear) pointMap.
      start = start || pointMap( this.start );
      end = end || pointMap( this.end );
      var middle = pointMap( this.positionAt( 0.5 ) );
      
      assert && assert( minLevels <= maxLevels );
      assert && assert( options.distanceEpsilon === null || typeof options.distanceEpsilon === 'number' );
      assert && assert( options.curveEpsilon === null || typeof options.curveEpsilon === 'number' );
      assert && assert( !pointMap || typeof pointMap === 'function' );
      
      // i.e. we will have finished = maxLevels === 0 || ( minLevels <= 0 && epsilonConstraints ), just didn't want to one-line it
      var finished = maxLevels === 0; // bail out once we reach our maximum number of subdivision levels
      if ( !finished && minLevels <= 0 ) { // force subdivision if minLevels hasn't been reached
                   // flatness criterion: A=start, B=end, C=midpoint, d0=distance from AB, d1=||B-A||, subdivide if d0/d1 > sqrt(epsilon)
        finished = ( options.curveEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) / start.distanceSquared( end ) < options.curveEpsilon ) ) &&
                   // deviation criterion
                   ( options.distanceEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) < options.distanceEpsilon ) );
      }
      
      if ( finished ) {
        segments.push( new Segment.Line( start, end ) );
      } else {
        var subdividedSegments = this.subdivided( 0.5 );
        subdividedSegments[0].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, start, middle );
        subdividedSegments[1].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, middle, end );
      }
      return segments;
    }
  };
  
  // list of { segment: ..., t: ..., closestPoint: ..., distanceSquared: ... } (since there can be duplicates), threshold is used for subdivision,
  // where it will exit if all of the segments are shorter than the threshold
  // TODO: solve segments to determine this analytically!
  Segment.closestToPoint = function( segments, point, threshold ) {
    var thresholdSquared = threshold * threshold;
    var items = [];
    var bestList = [];
    var bestDistanceSquared = Number.POSITIVE_INFINITY;
    var thresholdOk = false;
    
    _.each( segments, function( segment ) {
      // if we have an explicit computation for this segment, use it
      if ( segment.explicitClosestToPoint ) {
        var infos = segment.explicitClosestToPoint( point );
        _.each( infos, function( info ) {
          if ( info.distanceSquared < bestDistanceSquared ) {
            bestList = [info];
            bestDistanceSquared = info.distanceSquared;
          } else if ( info.distanceSquared === bestDistanceSquared ) {
            bestList.push( info );
          }
        } );
      } else {
        // otherwise, we will split based on monotonicity, so we can subdivide
        // separate, so we can map the subdivided segments 
        var ts = [0].concat( segment.getInteriorExtremaTs() ).concat([1]);
        for ( var i = 0; i < ts.length - 1; i++ ) {
          var ta = ts[i];
          var tb = ts[i+1];
          var pa = segment.positionAt( ta );
          var pb = segment.positionAt( tb );
          var bounds = Bounds2.point( pa ).addPoint( pb );
          var minDistanceSquared = bounds.minimumDistanceToPointSquared( point );
          if ( minDistanceSquared <= bestDistanceSquared ) {
            var maxDistanceSquared = bounds.maximumDistanceToPointSquared( point );
            if ( maxDistanceSquared < bestDistanceSquared ) {
              bestDistanceSquared = maxDistanceSquared;
              bestList = []; // clear it
            }
            items.push( {
              ta: ta,
              tb: tb,
              pa: pa,
              pb: pb,
              segment: segment,
              bounds: bounds,
              min: minDistanceSquared,
              max: maxDistanceSquared
            } );
          }
        }
      }
    } );
    
    while ( items.length && !thresholdOk ) {
      var curItems = items;
      items = [];
      
      // whether all of the segments processed are shorter than the threshold
      thresholdOk = true;
      
      _.each( curItems, function( item ) {
        if ( item.minDistanceSquared > bestDistanceSquared ) {
          return; // drop this item
        }
        if ( thresholdOk && item.pa.distanceSquared( item.pb ) > thresholdSquared ) {
          thresholdOk = false;
        }
        var tmid = ( item.ta + item.tb ) / 2;
        var pmid = item.segment.positionAt( tmid );
        var boundsA = Bounds2.point( item.pa ).addPoint( pmid );
        var boundsB = Bounds2.point( item.pb ).addPoint( pmid );
        var minA = boundsA.minimumDistanceToPointSquared( point );
        var minB = boundsB.minimumDistanceToPointSquared( point );
        if ( minA <= bestDistanceSquared ) {
          var maxA = boundsA.maximumDistanceToPointSquared( point );
          if ( maxA < bestDistanceSquared ) {
            bestDistanceSquared = maxA;
            bestList = []; // clear it
          }
          items.push( {
            ta: item.ta,
            tb: tmid,
            pa: item.pa,
            pb: pmid,
            segment: item.segment,
            bounds: boundsA,
            min: minA,
            max: maxA
          } );
        }
        if ( minB <= bestDistanceSquared ) {
          var maxB = boundsB.maximumDistanceToPointSquared( point );
          if ( maxB < bestDistanceSquared ) {
            bestDistanceSquared = maxB;
            bestList = []; // clear it
          }
          items.push( {
            ta: tmid,
            tb: item.tb,
            pa: pmid,
            pb: item.pb,
            segment: item.segment,
            bounds: boundsB,
            min: minB,
            max: maxB
          } );
        }
      } );
    }
    
    // if there are any closest regions, they are within the threshold, so we will add them all
    _.each( items, function( item ) {
      var t = ( item.ta + item.tb ) / 2;
      var closestPoint = item.segment.positionAt( t );
      bestList.push( {
        segment: item.segment,
        t: t,
        closestPoint: closestPoint,
        distanceSquared: point.distanceSquared( closestPoint )
      } );
    } );
    
    return bestList;
  };
  
  return Segment;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Linear segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Line',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Util','KITE/segments/Segment'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );
  
  var Segment = require( 'KITE/segments/Segment' );

  Segment.Line = function Line( start, end ) {
    this._start = start;
    this._end = end;
    
    // TODO: performance test removal of these undefined declarations
    this._tangent = undefined;
    this._bounds = undefined;
  };
  inherit( Segment, Segment.Line, {
    
    getStart: function() {
      return this._start;
    },
    get start() { return this._start; },
    
    getEnd: function() {
      return this._end;
    },
    get end() { return this._end; },
    
    getStartTangent: function() {
      if ( this._tangent === undefined ) {
        // TODO: allocation reduction
        this._tangent = this._end.minus( this._start ).normalized();
      }
      return this._tangent;
    },
    get startTangent() { return this.getStartTangent(); },
    
    getEndTangent: function() {
      return this.getStartTangent();
    },
    get endTangent() { return this.getEndTangent(); },
    
    getBounds: function() {
      // TODO: allocation reduction
      if ( this._bounds === undefined ) {
        this._bounds = Bounds2.dirtyFromPool().addPoint( this._start ).addPoint( this._end );
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    
    getNondegenerateSegments: function() {
      // if it is degenerate (0-length), just ignore it
      if ( this._start.equals( this._end ) ) {
        return [];
      } else {
        return [this];
      }
    },
    
    positionAt: function( t ) {
      return this._start.plus( this._end.minus( this._start ).times( t ) );
    },
    
    tangentAt: function( t ) {
      // tangent always the same, just use the start tanget
      return this.getStartTangent();
    },
    
    curvatureAt: function( t ) {
      return 0; // no curvature on a straight line segment
    },
    
    getSVGPathFragment: function() {
      return 'L ' + this._end.x + ' ' + this._end.y;
    },
    
    strokeLeft: function( lineWidth ) {
      var offset = this.getEndTangent().perpendicular().negated().times( lineWidth / 2 );
      return [new Segment.Line( this._start.plus( offset ), this._end.plus( offset ) )];
    },
    
    strokeRight: function( lineWidth ) {
      var offset = this.getStartTangent().perpendicular().times( lineWidth / 2 );
      return [new Segment.Line( this._end.plus( offset ), this._start.plus( offset ) )];
    },
    
    // lines are already monotone
    getInteriorExtremaTs: function() { return []; },
    
    subdivided: function( t ) {
      var pt = this.positionAt( t );
      return [
        new Segment.Line( this._start, pt ),
        new Segment.Line( pt, this._end )
      ];
    },
    
    intersectsBounds: function( bounds ) {
      throw new Error( 'Segment.Line.intersectsBounds unimplemented' ); // TODO: implement
    },
    
    intersection: function( ray ) {
      // We solve for the parametric line-line intersection, and then ensure the parameters are within both
      // the line segment and forwards from the ray.
      
      var result = [];
      
      var start = this._start;
      var end = this._end;
      
      var diff = end.minus( start );
      
      if ( diff.magnitudeSquared() === 0 ) {
        return result;
      }
      
      var denom = ray.dir.y * diff.x - ray.dir.x * diff.y;

      // If denominator is 0, the lines are parallel or coincident
      if ( denom === 0 ) {
        return result;
      }
      
      // linear parameter where start (0) to end (1)
      var t = ( ray.dir.x * ( start.y - ray.pos.y ) - ray.dir.y * ( start.x - ray.pos.x ) ) / denom;
      
      // check that the intersection point is between the line segment's endpoints
      if ( t < 0 || t >= 1 ) {
        return result;
      }
      
      // linear parameter where ray.pos (0) to ray.pos+ray.dir (1)
      var s = ( diff.x * ( start.y - ray.pos.y ) - diff.y * ( start.x - ray.pos.x ) ) / denom;
      
      // bail if it is behind our ray
      if ( s < 0.000001 ) {
        return result;
      }
      
      // return the proper winding direction depending on what way our line intersection is "pointed"
      var perp = diff.perpendicular();
      result.push( {
        distance: s,
        point: start.plus( diff.times( t ) ),
        normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,
        wind: ray.dir.perpendicular().dot( diff ) < 0 ? 1 : -1,
        segment: this
      } );
      return result;
    },
    
    // returns the resultant winding number of this ray intersecting this segment.
    windingIntersection: function( ray ) {
      var hits = this.intersection( ray );
      if ( hits.length ) {
        return hits[0].wind;
      } else {
        return 0;
      }
    },
    
    // assumes the current position is at start
    writeToContext: function( context ) {
      context.lineTo( this._end.x, this._end.y );
    },
    
    transformed: function( matrix ) {
      return new Segment.Line( matrix.timesVector2( this._start ), matrix.timesVector2( this._end ) );
    },
    
    explicitClosestToPoint: function( point ) {
      var diff = this._end.minus( this._start );
      var t = point.minus( this._start ).dot( diff ) / diff.magnitudeSquared();
      t = Util.clamp( t, 0, 1 );
      var closestPoint = this.positionAt( t );
      return [{
        segment: this,
        t: t,
        closestPoint: closestPoint,
        distanceSquared: point.distanceSquared( closestPoint )
      }];
    },
    
    // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
    reparameterized: function( a, b ) {
      return new Segment.Line( this.positionAt( b ), this.positionAt( a + b ) );
    },
    
    polarToCartesian: function( options ) {
      if ( this._start.x === this._end.x ) {
        // angle is the same, we are still a line segment!
        return [new Segment.Line( Vector2.createPolar( this._start.y, this._start.x ), Vector2.createPolar( this._end.y, this._end.x ) )];
      } else if ( this._start.y === this._end.y ) {
        // we have a constant radius, so we are a circular arc
        return [new Segment.Arc( Vector2.ZERO, this._start.y, this._start.x, this._end.x, this._start.x > this._end.x )];
      } else {
        return this.toPiecewiseLinearSegments( options );
      }
    }
  } );
  
  return Segment.Line;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Arc segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Arc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/segments/Segment'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var DotUtil = require( 'DOT/Util' );

  var Segment = require( 'KITE/segments/Segment' );

  Segment.Arc = function Arc( center, radius, startAngle, endAngle, anticlockwise ) {
    if ( radius < 0 ) {
      // support this case since we might actually need to handle it inside of strokes?
      radius = -radius;
      startAngle += Math.PI;
      endAngle += Math.PI;
    }
    
    this._center = center;
    this._radius = radius;
    this._startAngle = startAngle;
    this._endAngle = endAngle;
    this._anticlockwise = anticlockwise;
    
    // TODO: performance test removal of these undefined declarations
    this._start = undefined;
    this._end = undefined;
    this._startTangent = undefined;
    this._endTangent = undefined;
    this._actualEndAngle = undefined;
    this._isFullPerimeter = undefined;
    this._angleDifference = undefined;
    
    // constraints
    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );
    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );
  };
  inherit( Segment, Segment.Arc, {
    
    getCenter: function() {
      return this._center;
    },
    get center() { return this.getCenter(); },
    
    getRadius: function() {
      return this._radius;
    },
    get radius() { return this.getRadius(); },
    
    getStartAngle: function() {
      return this._startAngle;
    },
    get startAngle() { return this.getStartAngle(); },
    
    getEndAngle: function() {
      return this._endAngle;
    },
    get endAngle() { return this.getEndAngle(); },
    
    getAnticlockwise: function() {
      return this._anticlockwise;
    },
    get anticlockwise() { return this.getAnticlockwise(); },
    
    getStart: function() {
      if ( this._start === undefined ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },
    
    getEnd: function() {
      if ( this._end === undefined ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },
    
    getStartTangent: function() {
      if ( this._startTangent === undefined ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    
    getEndTangent: function() {
      if ( this._endTangent === undefined ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    
    getActualEndAngle: function() {
      if ( this._actualEndAngle === undefined ) {
        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
        if ( this._anticlockwise ) {
          // angle is 'decreasing'
          // -2pi <= end - start < 2pi
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          } else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          } else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        } else {
          // angle is 'increasing'
          // -2pi < end - start <= 2pi
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          } else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          } else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },
    
    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === undefined ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },
    
    getAngleDifference: function() {
      if ( this._angleDifference === undefined ) {
        // compute an angle difference that represents how "much" of the circle our arc covers
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },
    
    getBounds: function() {
      if ( this._bounds === undefined ) {
        // acceleration for intersection
        this._bounds = Bounds2.NOTHING.copy().withPoint( this.getStart() )
                                             .withPoint( this.getEnd() );
        
        // if the angles are different, check extrema points
        if ( this._startAngle !== this._endAngle ) {
          // check all of the extrema points
          this.includeBoundsAtAngle( 0 );
          this.includeBoundsAtAngle( Math.PI / 2 );
          this.includeBoundsAtAngle( Math.PI );
          this.includeBoundsAtAngle( 3 * Math.PI / 2 );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    
    getNondegenerateSegments: function() {
      if ( this._radius <= 0 || this._startAngle === this._endAngle ) {
        return [];
      } else {
        return [this]; // basically, Arcs aren't really degenerate that easily
      }
    },
    
    includeBoundsAtAngle: function( angle ) {
      if ( this.containsAngle( angle ) ) {
        // the boundary point is in the arc
        this._bounds = this._bounds.withPoint( this._center.plus( Vector2.createPolar( this._radius, angle ) ) );
      }
    },
    
    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
    mapAngle: function( angle ) {
      // consider an assert that we contain that angle?
      return ( this._startAngle > this.getActualEndAngle() ) ?
               DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
               DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },
    
    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },
    
    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },
    
    positionAt: function( t ) {
      return this.positionAtAngle( this.angleAt( t ) );
    },
    
    tangentAt: function( t ) {
      return this.tangentAtAngle( this.angleAt( t ) );
    },
    
    curvatureAt: function( t ) {
      return ( this._anticlockwise ? -1 : 1 ) / this._radius;
    },
    
    positionAtAngle: function( angle ) {
      return this._center.plus( Vector2.createPolar( this._radius, angle ) );
    },
    
    tangentAtAngle: function( angle ) {
      var normal = Vector2.createPolar( 1, angle );
      
      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },
    
    // TODO: refactor? shared with Segment.EllipticalArc (use this improved version)
    containsAngle: function( angle ) {
      // transform the angle into the appropriate coordinate form
      // TODO: check anticlockwise version!
      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;
      
      // get the angle between 0 and 2pi
      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );
      
      return positiveMinAngle <= this.angleDifference;
    },
    
    getSVGPathFragment: function() {
      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
      // rx ry x-axis-rotation large-arc-flag sweep-flag x y
      
      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
      var sweepFlag = this._anticlockwise ? '0' : '1';
      var largeArcFlag;
      if ( this.angleDifference < Math.PI * 2 - epsilon ) {
        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';
        return 'A ' + this._radius + ' ' + this._radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;
      } else {
        // circle (or almost-circle) case needs to be handled differently
        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs
        
        // get the angle that is between and opposite of both of the points
        var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
        var splitPoint = this._center.plus( Vector2.createPolar( this._radius, splitOppositeAngle ) );
        
        largeArcFlag = '0'; // since we split it in 2, it's always the small arc
        
        var firstArc = 'A ' + this._radius + ' ' + this._radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;
        var secondArc = 'A ' + this._radius + ' ' + this._radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;
        
        return firstArc + ' ' + secondArc;
      }
    },
    
    strokeLeft: function( lineWidth ) {
      return [new Segment.Arc( this._center, this._radius + ( this._anticlockwise ? 1 : -1 ) * lineWidth / 2, this._startAngle, this._endAngle, this._anticlockwise )];
    },
    
    strokeRight: function( lineWidth ) {
      return [new Segment.Arc( this._center, this._radius + ( this._anticlockwise ? -1 : 1 ) * lineWidth / 2, this._endAngle, this._startAngle, !this._anticlockwise )];
    },
    
    // not including 0 and 1
    getInteriorExtremaTs: function() {
      var that = this;
      var result = [];
      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {
        if ( that.containsAngle( angle ) ) {
          var t = that.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },
    
    subdivided: function( t ) {
      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new Segment.Arc( this._center, this._radius, angle0, angleT, this._anticlockwise ),
        new Segment.Arc( this._center, this._radius, angleT, angle1, this._anticlockwise )
      ];
    },
    
    intersectsBounds: function( bounds ) {
      throw new Error( 'Segment.intersectsBounds unimplemented!' );
    },
    
    intersection: function( ray ) {
      var result = []; // hits in order
      
      // left here, if in the future we want to better-handle boundary points
      var epsilon = 0;
      
      // Run a general circle-intersection routine, then we can test the angles later.
      // Solves for the two solutions t such that ray.pos + ray.dir * t is on the circle.
      // Then we check whether the angle at each possible hit point is in our arc.
      var centerToRay = ray.pos.minus( this._center );
      var tmp = ray.dir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this._radius * this._radius );
      if ( discriminant < epsilon ) {
        // ray misses circle entirely
        return result;
      }
      var base = ray.dir.dot( this._center ) - ray.dir.dot( ray.pos );
      var sqt = Math.sqrt( discriminant ) / 2;
      var ta = base - sqt;
      var tb = base + sqt;
      
      if ( tb < epsilon ) {
        // circle is behind ray
        return result;
      }
      
      var pointB = ray.pointAtDistance( tb );
      var normalB = pointB.minus( this._center ).normalized();
      
      if ( ta < epsilon ) {
        // we are inside the circle, so only one intersection is possible
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(), // normal is towards the ray
            wind: this._anticlockwise ? -1 : 1 // since we are inside, wind this way
          } );
        }
      }
      else {
        // two possible hits (outside circle)
        var pointA = ray.pointAtDistance( ta );
        var normalA = pointA.minus( this._center ).normalized();
        
        if ( this.containsAngle( normalA.angle() ) ) {
          result.push( {
            distance: ta,
            point: pointA,
            normal: normalA,
            wind: this._anticlockwise ? 1 : -1 // hit from outside
          } );
        }
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(),
            wind: this._anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way
          } );
        }
      }
      
      return result;
    },
    
    // returns the resultant winding number of this ray intersecting this segment.
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },
    
    writeToContext: function( context ) {
      context.arc( this._center.x, this._center.y, this._radius, this._startAngle, this._endAngle, this._anticlockwise );
    },
    
    // TODO: test various transform types, especially rotations, scaling, shears, etc.
    transformed: function( matrix ) {
      // so we can handle reflections in the transform, we do the general case handling for start/end angles
      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this._startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this._endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
      
      // reverse the 'clockwiseness' if our transform includes a reflection
      var anticlockwise = matrix.getDeterminant() >= 0 ? this._anticlockwise : !this._anticlockwise;
      
      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }

      var scaleVector = matrix.getScaleVector();
      if ( scaleVector.x !== scaleVector.y ) {
        var radiusX = scaleVector.x * this._radius;
        var radiusY = scaleVector.y * this._radius;
        return new Segment.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );
      } else {
        var radius = scaleVector.x * this._radius;
        return new Segment.Arc( matrix.timesVector2( this._center ), radius, startAngle, endAngle, anticlockwise );
      }
    }
  } );
  
  return Segment.Arc;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.
 *
 * See http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#concept-path
 * for the path / subpath Canvas concept.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/Subpath',['require','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Line','KITE/segments/Arc'],function( require ) {
  
  
  var Bounds2 = require( 'DOT/Bounds2' );
  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;
  
  var kite = require( 'KITE/kite' );
  
  require( 'KITE/segments/Line' );
  require( 'KITE/segments/Arc' );
  
  // all arguments optional (they are for the copy() method)
  kite.Subpath = function Subpath( segments, points, closed ) {
    this.segments = segments || [];
    
    // recombine points if necessary, based off of start points of segments + the end point of the last segment
    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[segments.length-1].end ) : [] );
    this.closed = !!closed;
    
    // cached stroked shape (so hit testing can be done quickly on stroked shapes)
    this._strokedSubpaths = null;
    this._strokedSubpathsComputed = false;
    this._strokedStyles = null;
    
    var bounds = this.bounds = Bounds2.NOTHING.copy();
    _.each( this.segments, function( segment ) {
      bounds.includeBounds( segment.bounds );
    } );
  };
  var Subpath = kite.Subpath;
  Subpath.prototype = {
    copy: function() {
      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );
    },
    
    invalidate: function() {
      this._strokedSubpathsComputed = false;
    },
    
    addPoint: function( point ) {
      this.points.push( point );
      
      return this; // allow chaining
    },
    
    addSegmentDirectly: function( segment ) {
      assert && assert( segment.start.isFinite(), 'Segment start is infinite' );
      assert && assert( segment.end.isFinite(), 'Segment end is infinite' );
      assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );
      assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );
      assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );
      this.segments.push( segment );
      this.invalidate();
      
      this.bounds.includeBounds( segment.getBounds() );
      
      return this; // allow chaining
    },
    
    addSegment: function( segment ) {
      var subpath = this;
      _.each( segment.getNondegenerateSegments(), function( segment ) {
        subpath.addSegmentDirectly( segment );
      } );
      
      return this; // allow chaining
    },
    
    // Adds a line segment from the start to end (if non-zero length) and marks the subpath as closed.
    // NOTE: normally you just want to mark the subpath as closed, and not generate the closing segment this way?
    addClosingSegment: function() {
      if ( this.hasClosingSegment() ) {
        var closingSegment = this.getClosingSegment();
        this.addSegmentDirectly( closingSegment );
        this.addPoint( this.getFirstPoint() );
        this.closed = true;
      }
    },
    
    // TODO: consider always adding a closing segment into our segments list for easier processing!! see addClosingSegment()
    close: function() {
      this.closed = true;
    },
    
    getLength: function() {
      return this.points.length;
    },
    
    getFirstPoint: function() {
      return _.first( this.points );
    },
    
    getLastPoint: function() {
      return _.last( this.points );
    },
    
    getFirstSegment: function() {
      return _.first( this.segments );
    },
    
    getLastSegment: function() {
      return _.last( this.segments );
    },
    
    isDrawable: function() {
      return this.segments.length > 0;
    },
    
    isClosed: function() {
      return this.closed;
    },
    
    hasClosingSegment: function() {
      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );
    },
    
    getClosingSegment: function() {
      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );
      return new kite.Segment.Line( this.getLastPoint(), this.getFirstPoint() );
    },
    
    writeToContext: function( context ) {
      if ( this.isDrawable() ) {
        var startPoint = this.getFirstSegment().start;
        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start
        
        var len = this.segments.length;
        for ( var i = 0; i < len; i++ ) {
          this.segments[i].writeToContext( context );
        }
        
        if ( this.closed ) {
          context.closePath();
        }
      }
    },
    
    // see Segment.toPiecewiseLinearSegments for documentation
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'For use with pointMap, please use nonlinearTransformed' );
      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        return segment.toPiecewiseLinearSegments( options );
      } ) ), null, this.closed );
    },
    
    transformed: function( matrix ) {
      return new Subpath(
        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),
        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),
        this.closed
      );
    },
    
    // see Segment.toPiecewiseLinearSegments for documentation
    nonlinearTransformed: function( options ) {
      // specify an actual closing segment, so it can be mapped properly by any non-linear transforms
      // TODO: always create and add the closing segments when the subpath is closed!!!
      if ( this.closed && this.hasClosingSegment() ) {
        this.addClosingSegment();
      }
      
      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        // check for this segment's support for the specific transform or discretization being applied
        if ( options.methodName && segment[options.methodName] ) {
          return segment[options.methodName]( options );
        } else {
          return segment.toPiecewiseLinearSegments( options );
        }
      } ) ), null, this.closed );
    },
    
    // returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.
    stroked: function( lineStyles ) {
      // non-drawable subpaths convert to empty subpaths
      if ( !this.isDrawable() ) {
        return [];
      }
      
      if ( lineStyles === undefined ) {
        lineStyles = new kite.LineStyles();
      }
      
      // return a cached version if possible
      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {
        return this._strokedSubpaths;
      }
      
      var lineWidth = lineStyles.lineWidth;
      
      // joins two segments together on the logical "left" side, at 'center' (where they meet), and normalized tangent vectors in the direction of the stroking
      // to join on the "right" side, switch the tangent order and negate them
      function join( center, fromTangent, toTangent ) {
        // where our join path starts and ends
        var fromPoint = center.plus( fromTangent.perpendicular().negated().times( lineWidth / 2 ) );
        var toPoint = center.plus( toTangent.perpendicular().negated().times( lineWidth / 2 ) );
        
        var bevel = ( fromPoint.equals( toPoint ) ? [] : [new kite.Segment.Line( fromPoint, toPoint )] );
        
        // only insert a join on the non-acute-angle side
        if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {
          switch( lineStyles.lineJoin ) {
            case 'round':
              var fromAngle = fromTangent.angle() + Math.PI / 2;
              var toAngle = toTangent.angle() + Math.PI / 2;
              return [new kite.Segment.Arc( center, lineWidth / 2, fromAngle, toAngle, true )];
            case 'miter':
              var theta = fromTangent.angleBetween( toTangent.negated() );
              if ( 1 / Math.sin( theta / 2 ) <= lineStyles.miterLimit && theta < Math.PI - 0.00001 ) {
                // draw the miter
                var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );
                return [
                  new kite.Segment.Line( fromPoint, miterPoint ),
                  new kite.Segment.Line( miterPoint, toPoint )
                ];
              } else {
                // angle too steep, use bevel instead. same as below, but copied for linter
                return bevel;
              }
              break;
            case 'bevel':
              return bevel;
          }
        } else {
          // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place
          // TODO: can we prevent self-intersection here?
          return bevel;
        }
      }
      
      // draws the necessary line cap from the endpoint 'center' in the direction of the tangent
      function cap( center, tangent ) {
        var fromPoint = center.plus( tangent.perpendicular().times( -lineWidth / 2 ) );
        var toPoint = center.plus( tangent.perpendicular().times( lineWidth / 2 ) );
        
        switch( lineStyles.lineCap ) {
          case 'butt':
            return [new kite.Segment.Line( fromPoint, toPoint )];
          case 'round':
            var tangentAngle = tangent.angle();
            return [new kite.Segment.Arc( center, lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true )];
          case 'square':
            var toLeft = tangent.perpendicular().negated().times( lineWidth / 2 );
            var toRight = tangent.perpendicular().times( lineWidth / 2 );
            var toFront = tangent.times( lineWidth / 2 );
            
            var left = center.plus( toLeft ).plus( toFront );
            var right = center.plus( toRight ).plus( toFront );
            return [
              new kite.Segment.Line( fromPoint, left ),
              new kite.Segment.Line( left, right ),
              new kite.Segment.Line( right, toPoint )
            ];
        }
      }
      
      var i;
      var leftSegments = [];
      var rightSegments = [];
      var firstSegment = this.getFirstSegment();
      var lastSegment = this.getLastSegment();
      
      function addLeftSegments( segments ) {
        leftSegments = leftSegments.concat( segments );
      }
      function addRightSegments( segments ) {
        rightSegments = rightSegments.concat( segments );
      }
      
      // we don't need to insert an implicit closing segment if the start and end points are the same
      var alreadyClosed = lastSegment.end.equals( firstSegment.start );
      // if there is an implicit closing segment
      var closingSegment = alreadyClosed ? null : new kite.Segment.Line( this.segments[this.segments.length-1].end, this.segments[0].start );
      
      // stroke the logical "left" side of our path
      for ( i = 0; i < this.segments.length; i++ ) {
        if ( i > 0 ) {
          addLeftSegments( join( this.segments[i].start, this.segments[i-1].endTangent, this.segments[i].startTangent, true ) );
        }
        addLeftSegments( this.segments[i].strokeLeft( lineWidth ) );
      }
      
      // stroke the logical "right" side of our path
      for ( i = this.segments.length - 1; i >= 0; i-- ) {
        if ( i < this.segments.length - 1 ) {
          addRightSegments( join( this.segments[i].end, this.segments[i+1].startTangent.negated(), this.segments[i].endTangent.negated(), false ) );
        }
        addRightSegments( this.segments[i].strokeRight( lineWidth ) );
      }
      
      var subpaths;
      if ( this.closed ) {
        if ( alreadyClosed ) {
          // add the joins between the start and end
          addLeftSegments( join( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
          addRightSegments( join( lastSegment.end, firstSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );
        } else {
          // logical "left" stroke on the implicit closing segment
          addLeftSegments( join( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
          addLeftSegments( closingSegment.strokeLeft( lineWidth ) );
          addLeftSegments( join( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );
          
          // logical "right" stroke on the implicit closing segment
          addRightSegments( join( closingSegment.end, firstSegment.startTangent.negated(), closingSegment.endTangent.negated() ) );
          addRightSegments( closingSegment.strokeRight( lineWidth ) );
          addRightSegments( join( closingSegment.start, closingSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );
        }
        subpaths = [
          new Subpath( leftSegments, null, true ),
          new Subpath( rightSegments, null, true )
        ];
      } else {
        subpaths = [
          new Subpath( leftSegments
                         .concat( cap( lastSegment.end, lastSegment.endTangent ) )
                         .concat( rightSegments )
                         .concat( cap( firstSegment.start, firstSegment.startTangent.negated() ) ),
                       null, true )
        ];
      }
      
      this._strokedSubpaths = subpaths;
      this._strokedSubpathsComputed = true;
      this._strokedStyles = new kite.LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable
      
      return subpaths;
    }
  };

  return kite.Subpath;
} );

// generated from svgPath.pegjs, with added kite namespace and require.js compatibility

define( 'KITE/../parser/svgPath',['require','KITE/kite'],function( require ) {
  
  var kite = require( 'KITE/kite' );
  
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  kite.svgPath = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "svgPath": parse_svgPath,
        "movetoDrawtoCommandGroups": parse_movetoDrawtoCommandGroups,
        "movetoDrawtoCommandGroup": parse_movetoDrawtoCommandGroup,
        "drawtoCommands": parse_drawtoCommands,
        "drawtoCommand": parse_drawtoCommand,
        "moveto": parse_moveto,
        "movetoArgumentSequence": parse_movetoArgumentSequence,
        "closepath": parse_closepath,
        "lineto": parse_lineto,
        "linetoArgumentSequence": parse_linetoArgumentSequence,
        "horizontalLineto": parse_horizontalLineto,
        "horizontalLinetoArgumentSequence": parse_horizontalLinetoArgumentSequence,
        "verticalLineto": parse_verticalLineto,
        "verticalLinetoArgumentSequence": parse_verticalLinetoArgumentSequence,
        "curveto": parse_curveto,
        "curvetoArgumentSequence": parse_curvetoArgumentSequence,
        "curvetoArgument": parse_curvetoArgument,
        "smoothCurveto": parse_smoothCurveto,
        "smoothCurvetoArgumentSequence": parse_smoothCurvetoArgumentSequence,
        "smoothCurvetoArgument": parse_smoothCurvetoArgument,
        "quadraticBezierCurveto": parse_quadraticBezierCurveto,
        "quadraticBezierCurvetoArgumentSequence": parse_quadraticBezierCurvetoArgumentSequence,
        "quadraticBezierCurvetoArgument": parse_quadraticBezierCurvetoArgument,
        "smoothQuadraticBezierCurveto": parse_smoothQuadraticBezierCurveto,
        "smoothQuadraticBezierCurvetoArgumentSequence": parse_smoothQuadraticBezierCurvetoArgumentSequence,
        "ellipticalArc": parse_ellipticalArc,
        "ellipticalArcArgumentSequence": parse_ellipticalArcArgumentSequence,
        "ellipticalArcArgument": parse_ellipticalArcArgument,
        "coordinatePair": parse_coordinatePair,
        "nonnegativeNumber": parse_nonnegativeNumber,
        "number": parse_number,
        "flag": parse_flag,
        "commaWsp": parse_commaWsp,
        "comma": parse_comma,
        "floatingPointConstant": parse_floatingPointConstant,
        "fractionalConstant": parse_fractionalConstant,
        "exponent": parse_exponent,
        "sign": parse_sign,
        "digitSequence": parse_digitSequence,
        "digit": parse_digit,
        "wsp": parse_wsp
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "svgPath";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_svgPath() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_wsp();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_wsp();
        }
        if (result0 !== null) {
          result1 = parse_movetoDrawtoCommandGroups();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = [];
            result3 = parse_wsp();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_wsp();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, path) { return path ? path : []; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_movetoDrawtoCommandGroups() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_movetoDrawtoCommandGroup();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_movetoDrawtoCommandGroups();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return a.concat( b ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_movetoDrawtoCommandGroup();
          if (result0 !== null) {
            result0 = (function(offset, a) { return a; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_movetoDrawtoCommandGroup() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_moveto();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_drawtoCommands();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, m, c) { return c.length ? m.concat( c ) : m; })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_drawtoCommands() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_drawtoCommand();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_drawtoCommands();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, cmd, cmds) { return cmd.concat( cmds ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_drawtoCommand();
          if (result0 !== null) {
            result0 = (function(offset, cmd) { return cmd; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_drawtoCommand() {
        var result0;
        
        result0 = parse_closepath();
        if (result0 === null) {
          result0 = parse_lineto();
          if (result0 === null) {
            result0 = parse_horizontalLineto();
            if (result0 === null) {
              result0 = parse_verticalLineto();
              if (result0 === null) {
                result0 = parse_curveto();
                if (result0 === null) {
                  result0 = parse_smoothCurveto();
                  if (result0 === null) {
                    result0 = parse_quadraticBezierCurveto();
                    if (result0 === null) {
                      result0 = parse_smoothQuadraticBezierCurveto();
                      if (result0 === null) {
                        result0 = parse_ellipticalArc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_moveto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 77) {
          result0 = "M";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"M\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_movetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return createMoveTo( args, false ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 109) {
            result0 = "m";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"m\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_movetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return createMoveTo( args, true ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_movetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_linetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, pair, list) { return [pair].concat( list ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if (result0 !== null) {
            result0 = (function(offset, pair) { return [pair]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_closepath() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 90) {
          result0 = "Z";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Z\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 122) {
            result0 = "z";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"z\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, command) { return { cmd: 'close' }; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lineto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 76) {
          result0 = "L";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"L\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_linetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'lineTo', args: [ arg.x, arg.y ] }; } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 108) {
            result0 = "l";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"l\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_linetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'lineToRelative', args: [ arg.x, arg.y ] }; } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_linetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_linetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_horizontalLineto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 72) {
          result0 = "H";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"H\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'horizontalLineTo', args: [ arg ] } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 104) {
            result0 = "h";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"h\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_horizontalLinetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'horizontalLineToRelative', args: [ arg ] } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_horizontalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_number();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_verticalLineto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 86) {
          result0 = "V";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"V\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_verticalLinetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'verticalLineTo', args: [ arg ] } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 118) {
            result0 = "v";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"v\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_verticalLinetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'verticalLineToRelative', args: [ arg ] } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_verticalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_verticalLinetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_number();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_curveto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 67) {
          result0 = "C";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"C\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_curvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'cubicCurveTo', args: arg } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 99) {
            result0 = "c";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"c\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_curvetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'cubicCurveToRelative', args: arg } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_curvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_curvetoArgument();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_curvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_curvetoArgument();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_curvetoArgument() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_coordinatePair();
            if (result2 !== null) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_coordinatePair();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b, c) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })(pos0, result0[0], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_smoothCurveto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 83) {
          result0 = "S";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"S\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveTo', args: arg } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 115) {
            result0 = "s";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"s\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_smoothCurvetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveToRelative', args: arg } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_smoothCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_smoothCurvetoArgument();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_smoothCurvetoArgument();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_smoothCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_coordinatePair();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return [ a.x, a.y, b.x, b.y ]; })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_quadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 81) {
          result0 = "Q";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Q\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'quadraticCurveTo', args: arg } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 113) {
            result0 = "q";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"q\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_quadraticBezierCurvetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'quadraticCurveToRelative', args: arg } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_quadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_quadraticBezierCurvetoArgument();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_quadraticBezierCurvetoArgument();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_quadraticBezierCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_coordinatePair();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return [ a.x, a.y, b.x, b.y ]; })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_smoothQuadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 84) {
          result0 = "T";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"T\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveTo', args: [ arg.x, arg.y ] } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 116) {
            result0 = "t";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"t\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveToRelative', args: [ arg.x, arg.y ] } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_ellipticalArc() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 65) {
          result0 = "A";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"A\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_wsp();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_wsp();
          }
          if (result1 !== null) {
            result2 = parse_ellipticalArcArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'ellipticalArcTo', args: arg } } ); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 97) {
            result0 = "a";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"a\"");
            }
          }
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result2 = parse_ellipticalArcArgumentSequence();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'ellipticalArcToRelative', args: arg } } ); })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_ellipticalArcArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ellipticalArcArgument();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_ellipticalArcArgumentSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_ellipticalArcArgument();
          if (result0 !== null) {
            result0 = (function(offset, a) { return [a]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_ellipticalArcArgument() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_nonnegativeNumber();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_nonnegativeNumber();
            if (result2 !== null) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_number();
                if (result4 !== null) {
                  result5 = parse_commaWsp();
                  if (result5 !== null) {
                    result6 = parse_flag();
                    if (result6 !== null) {
                      result7 = parse_commaWsp();
                      result7 = result7 !== null ? result7 : "";
                      if (result7 !== null) {
                        result8 = parse_flag();
                        if (result8 !== null) {
                          result9 = parse_commaWsp();
                          result9 = result9 !== null ? result9 : "";
                          if (result9 !== null) {
                            result10 = parse_coordinatePair();
                            if (result10 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, rx, ry, rot, largeArc, sweep, to) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })(pos0, result0[0], result0[2], result0[4], result0[6], result0[8], result0[10]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_coordinatePair() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if (result0 !== null) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_number();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return { x: a, y: b }; })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonnegativeNumber() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_floatingPointConstant();
        if (result0 !== null) {
          result0 = (function(offset, number) { return parseFloat( number, 10 ); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_digitSequence();
          if (result0 !== null) {
            result0 = (function(offset, number) { return parseInt( number, 10 ); })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_sign();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_floatingPointConstant();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, sign, number) { return parseFloat( sign + number, 10 ); })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_sign();
          result0 = result0 !== null ? result0 : "";
          if (result0 !== null) {
            result1 = parse_digitSequence();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, sign, number) { return parseInt( sign + number, 10 ); })(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_flag() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return false; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 49) {
            result0 = "1";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"1\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return true; })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_commaWsp() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result1 = parse_wsp();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_wsp();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_comma();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = [];
            result3 = parse_wsp();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_wsp();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_comma();
          if (result0 !== null) {
            result1 = [];
            result2 = parse_wsp();
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_wsp();
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_comma() {
        var result0;
        
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        return result0;
      }
      
      function parse_floatingPointConstant() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_fractionalConstant();
        if (result0 !== null) {
          result1 = parse_exponent();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if (result0 !== null) {
            result1 = parse_exponent();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_fractionalConstant() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_digitSequence();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_digitSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return a + '.' + b; })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if (result0 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, a) { return a })(pos0, result0[0]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_exponent() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 101) {
          result0 = "e";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"e\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 69) {
            result0 = "E";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"E\"");
            }
          }
        }
        if (result0 !== null) {
          result1 = parse_sign();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_digitSequence();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b, c) { return a + b + c; })(pos0, result0[0], result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sign() {
        var result0;
        
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
        }
        return result0;
      }
      
      function parse_digitSequence() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_digit();
        if (result0 !== null) {
          result1 = parse_digitSequence();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_digit();
        }
        return result0;
      }
      
      function parse_digit() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_wsp() {
        var result0;
        
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 9) {
            result0 = "\t";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\t\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 10) {
                result0 = "\n";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\n\"");
                }
              }
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        function createMoveTo( args, isRelative ) {
          var result = [ {
            cmd: isRelative ? 'moveToRelative' : 'moveTo',
            args: [ args[0].x, args[0].y ]
          } ];
          
          // any other coordinate pairs are implicit lineTos
          if ( args.length > 1 ) {
            for ( var i = 1; i < args.length; i++ ) {
              result.push( {
                cmd: isRelative ? 'lineToRelative' : 'lineTo',
                args: [ args[i].x, args[i].y ]
              } );
            }
          }
          return result;
        }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  var result = kite.svgPath;
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
});

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Styles needed to determine a stroked line shape.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/LineStyles',['require','KITE/kite'],function( require ) {
  
  
  var kite = require( 'KITE/kite' );
  
  kite.LineStyles = function( args ) {
    if ( args === undefined ) {
      args = {};
    }
    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;
    this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square
    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel
    this.lineDash = args.lineDash ? args.lineDash : []; // [] is default, otherwise an array of numbers
    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number
    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations
    
    assert && assert( Array.isArray( this.lineDash ) );
  };
  var LineStyles = kite.LineStyles;
  LineStyles.prototype = {
    constructor: LineStyles,
    
    equals: function( other ) {
      var typical = this.lineWidth === other.lineWidth &&
                    this.lineCap === other.lineCap &&
                    this.lineJoin === other.lineJoin &&
                    this.miterLimit === other.miterLimit &&
                    this.lineDashOffset === other.lineDashOffset;
      if ( !typical ) {
        return false;
      }
      
      if ( this.lineDash.length === other.lineDash.length ) {
        for ( var i = 0; i < this.lineDash.length; i++ ) {
          if ( this.lineDash[i] !== other.lineDash[i] ) {
            return false;
          }
        }
      } else {
        // line dashes must be different
        return false;
      }
      
      return true;
    }
  };
  
  return kite.LineStyles;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Quadratic Bezier segment
 *
 * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Quadratic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','DOT/Util','KITE/segments/Segment'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;
  var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;

  var Segment = require( 'KITE/segments/Segment' );

  Segment.Quadratic = function Quadratic( start, control, end ) {
    this._start = start;
    this._control = control;
    this._end = end;
    
    // TODO: performance test removal of these undefined declarations
    this._startTangent = undefined;
    this._endTangent = undefined;
    this._tCriticalX = undefined; // replaced with null if not in range
    this._tCriticalY = undefined; // replaced with null if not in range
    this._bounds = undefined;
  };
  inherit( Segment, Segment.Quadratic, {
    
    degree: 2,
    
    getStart: function() {
      return this._start;
    },
    get start() { return this._start; },
    
    getControl: function() {
      return this._control;
    },
    get control() { return this._control; },
    
    getEnd: function() {
      return this._end;
    },
    get end() { return this._end; },
    
    getStartTangent: function() {
      if ( this._startTangent === undefined ) {
        var controlIsStart = this._start.equals( this._control );
        // TODO: allocation reduction
        this._startTangent = controlIsStart ?
                               this._end.minus( this._start ).normalized() :
                               this._control.minus( this._start ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    
    getEndTangent: function() {
      if ( this._endTangent === undefined ) {
        var controlIsEnd = this._end.equals( this._control );
        // TODO: allocation reduction
        this._endTangent = controlIsEnd ?
                               this._end.minus( this._start ).normalized() :
                               this._end.minus( this._control ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    
    getTCriticalX: function() {
      // compute x where the derivative is 0 (used for bounds and other things)
      if ( this._tCriticalX === undefined ) {
        this._tCriticalX = Segment.Quadratic.extremaT( this._start.x, this._control.x, this._end.x );
      }
      return this._tCriticalX;
    },
    get tCriticalX() { return this.getTCriticalX(); },
    
    getTCriticalY: function() {
      // compute y where the derivative is 0 (used for bounds and other things)
      if ( this._tCriticalY === undefined ) {
        this._tCriticalY = Segment.Quadratic.extremaT( this._start.y, this._control.y, this._end.y );
      }
      return this._tCriticalY;
    },
    get tCriticalY() { return this.getTCriticalY(); },
    
    getNondegenerateSegments: function() {
      var start = this._start;
      var control = this._control;
      var end = this._end;
      
      var startIsEnd = start.equals( end );
      var startIsControl = start.equals( control );
      var endIsControl = start.equals( control );
      
      if ( startIsEnd && startIsControl ) {
        // all same points
        return [];
      } else if ( startIsEnd ) {
        // this is a special collinear case, we basically line out to the farthest point and back
        var halfPoint = this.positionAt( 0.5 );
        return [
          new Segment.Line( start, halfPoint ),
          new Segment.Line( halfPoint, end )
        ];
      } else if ( arePointsCollinear( start, control, end ) ) {
        // if they are collinear, we can reduce to start->control and control->end, or if control is between, just one line segment
        // also, start !== end (handled earlier)
        if ( startIsControl || endIsControl ) {
          // just a line segment!
          return [new Segment.Line( start, end )]; // no extra nondegenerate check since start !== end
        }
        // now control point must be unique. we check to see if our rendered path will be outside of the start->end line segment
        var delta = end.minus( start );
        var p1d = control.minus( start ).dot( delta.normalized ) / delta.magnitude();
        var t = Segment.Quadratic.extremaT( 0, p1d, 1 );
        if ( t !== null && t > 0 && t < 1 ) {
          // we have a local max inside the range, indicating that our extrema point is outside of start->end
          // we'll line to and from it
          var pt = this.positionAt( t );
          return _.flatten( [
            new Segment.Line( start, pt ).getNondegenerateSegments(),
            new Segment.Line( pt, end ).getNondegenerateSegments()
          ] );
        } else {
          // just provide a line segment, our rendered path doesn't go outside of this
          return [new Segment.Line( start, end )]; // no extra nondegenerate check since start !== end
        }
      } else {
        return [this];
      }
    },
    
    getBounds: function() {
      // calculate our temporary guaranteed lower bounds based on the end points
      if ( this._bounds === undefined ) {
        this._bounds = new Bounds2( Math.min( this._start.x, this._end.x ), Math.min( this._start.y, this._end.y ), Math.max( this._start.x, this._end.x ), Math.max( this._start.y, this._end.y ) );
        
        // compute x and y where the derivative is 0, so we can include this in the bounds
        var tCriticalX = this.getTCriticalX();
        var tCriticalY = this.getTCriticalY();
        
        if ( tCriticalX !== null && tCriticalX > 0 && tCriticalX < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalX ) );
        }
        if ( tCriticalY !== null && tCriticalY > 0 && tCriticalY < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalY ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    
    // can be described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end
    positionAt: function( t ) {
      var mt = 1 - t;
      // TODO: allocation reduction
      return this._start.times( mt * mt ).plus( this._control.times( 2 * mt * t ) ).plus( this._end.times( t * t ) );
    },
    
    // derivative: 2(1-t)( control - start ) + 2t( end - control )
    tangentAt: function( t ) {
      // TODO: allocation reduction
      return this._control.minus( this._start ).times( 2 * ( 1 - t ) ).plus( this._end.minus( this._control ).times( 2 * t ) );
    },
    
    curvatureAt: function( t ) {
      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
      // TODO: remove code duplication with Cubic
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = this._control;
        var p2 = isZero ? this._end : this._start;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      } else {
        return this.subdivided( t, true )[0].curvatureAt( 1 );
      }
    },
    
    // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf
    // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length
    
    offsetTo: function( r, reverse ) {
      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      var curves = [this];
      
      // subdivide this curve
      var depth = 5; // generates 2^depth curves
      for ( var i = 0; i < depth; i++ ) {
        curves = _.flatten( _.map( curves, function( curve ) {
          return curve.subdivided( 0.5, true );
        } ));
      }
      
      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );
      
      if ( reverse ) {
        offsetCurves.reverse();
        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );
      }
      
      return offsetCurves;
    },
    
    subdivided: function( t ) {
      // de Casteljau method
      var leftMid = this._start.blend( this._control, t );
      var rightMid = this._control.blend( this._end, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new Segment.Quadratic( this._start, leftMid, mid ),
        new Segment.Quadratic( mid, rightMid, this._end )
      ];
    },
    
    // elevation of this quadratic Bezier curve to a cubic Bezier curve
    degreeElevated: function() {
      // TODO: allocation reduction
      return new Segment.Cubic(
        this._start,
        this._start.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end
      );
    },
    
    reversed: function() {
      return new Segment.Quadratic( this._end, this._control, this._start );
    },
    
    approximateOffset: function( r ) {
      return new Segment.Quadratic(
        this._start.plus( ( this._start.equals( this._control ) ? this._end.minus( this._start ) : this._control.minus( this._start ) ).perpendicular().normalized().times( r ) ),
        this._control.plus( this._end.minus( this._start ).perpendicular().normalized().times( r ) ),
        this._end.plus( ( this._end.equals( this._control ) ? this._end.minus( this._start ) : this._end.minus( this._control ) ).perpendicular().normalized().times( r ) )
      );
    },
    
    getSVGPathFragment: function() {
      return 'Q ' + this._control.x + ' ' + this._control.y + ' ' + this._end.x + ' ' + this._end.y;
    },
    
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },
    
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },
    
    getInteriorExtremaTs: function() {
      // TODO: we assume here we are reduce, so that a criticalX doesn't equal a criticalY?
      var result = [];
      var epsilon = 0.0000000001; // TODO: general kite epsilon?
      if ( this.tCriticalX !== undefined && this.tCriticalX > epsilon && this.tCriticalX < 1 - epsilon ) {
        result.push( this.tCriticalX );
      }
      if ( this.tCriticalY !== undefined && this.tCriticalY > epsilon && this.tCriticalY < 1 - epsilon ) {
        result.push( this.tCriticalY );
      }
      return result.sort();
    },
    
    intersectsBounds: function( bounds ) {
      throw new Error( 'Segment.Quadratic.intersectsBounds unimplemented' ); // TODO: implement
    },
    
    // returns the resultant winding number of this ray intersecting this segment.
    intersection: function( ray ) {
      var self = this;
      var result = [];
      
      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );
      
      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control );
      var p2 = inverseMatrix.timesVector2( this._end );
      
      //(1-t)^2 start + 2(1-t)t control + t^2 end
      var a = p0.y - 2 * p1.y + p2.y;
      var b = -2 * p0.y + 2 * p1.y;
      var c = p0.y;
      
      var ts = solveQuadraticRootsReal( a, b, c );
      
      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.pos );
          
          // make sure it's not behind the ray
          if ( toHit.dot( ray.dir ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,
              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },
    
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },
    
    // assumes the current position is at start
    writeToContext: function( context ) {
      context.quadraticCurveTo( this._control.x, this._control.y, this._end.x, this._end.y );
    },
    
    transformed: function( matrix ) {
      return new Segment.Quadratic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control ), matrix.timesVector2( this._end ) );
    },
    
    // given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
    reparameterized: function( a, b ) {
      // to the polynomial pt^2 + qt + r:
      var p = this._start.plus( this._end.plus( this._control.timesScalar( -2 ) ) );
      var q = this._control.minus( this._start ).timesScalar( 2 );
      var r = this._start;
      
      // to the polynomial alpha*x^2 + beta*x + gamma:
      var alpha = p.timesScalar( a * a );
      var beta = p.timesScalar( a * b ).timesScalar( 2 ).plus( q.timesScalar( a ) );
      var gamma = p.timesScalar( b * b ).plus( q.timesScalar( b ) ).plus( r );
      
      // back to the form start,control,end
      return new Segment.Quadratic( gamma, beta.timesScalar( 0.5 ).plus( gamma ), alpha.plus( beta ).plus( gamma ) );
    }
  } );
  
  // one-dimensional solution to extrema
  Segment.Quadratic.extremaT = function( start, control, end ) {
    // compute t where the derivative is 0 (used for bounds and other things)
    var divisorX = 2 * ( end - 2 * control + start );
    if ( divisorX !== 0 ) {
      return -2 * ( control - start ) / divisorX;
    } else {
      return null;
    }
  };
  
  return Segment.Quadratic;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Cubic Bezier segment.
 *
 * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info
 *
 * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Cubic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/segments/Quadratic'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;
  var solveCubicRootsReal = require( 'DOT/Util' ).solveCubicRootsReal;
  var arePointsCollinear = require( 'DOT/Util' ).arePointsCollinear;
  
  var Segment = require( 'KITE/segments/Segment' );
  require( 'KITE/segments/Quadratic' );

  Segment.Cubic = function Cubic( start, control1, control2, end ) {
    this._start = start;
    this._control1 = control1;
    this._control2 = control2;
    this._end = end;
    
    // TODO: performance test removal of these undefined declarations
    this._startTangent = undefined;
    this._endTangent = undefined;
    this._r = undefined;
    this._s = undefined;
    
    this._tCusp = undefined;
    this._tDeterminant = undefined;
    this._tInflection1 = undefined;
    this._tInflection2 = undefined;
    this._startQuadratic = undefined;
    this._endQuadratic = undefined;
    
    this._xExtremaT = undefined;
    this._yExtremaT = undefined;
    
    this._bounds = undefined;
  };
  inherit( Segment, Segment.Cubic, {
    
    degree: 3,
    
    getStart: function() {
      return this._start;
    },
    get start() { return this._start; },
    
    getControl1: function() {
      return this._control1;
    },
    get control1() { return this._control1; },
    
    getControl2: function() {
      return this._control2;
    },
    get control2() { return this._control2; },
    
    getEnd: function() {
      return this._end;
    },
    get end() { return this._end; },
    
    getStartTangent: function() {
      if ( this._startTangent === undefined ) {
        this._startTangent = this.tangentAt( 0 ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    
    getEndTangent: function() {
      if ( this._endTangent === undefined ) {
        this._endTangent = this.tangentAt( 1 ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    
    getR: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      if ( this._r === undefined ) {
        this._r = this._control1.minus( this._start ).normalized();
      }
      return this._r;
    },
    get r() { return this.getR(); },
    
    getS: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      if ( this._s === undefined ) {
        this._s = this.getR().perpendicular();
      }
      return this._s;
    },
    get s() { return this.getS(); },
    
    getTCusp: function() {
      if ( this._tCusp === undefined ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tCusp !== undefined );
      return this._tCusp;
    },
    get tCusp() { return this.getTCusp(); },
    
    getTDeterminant: function() {
      if ( this._tDeterminant === undefined ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tDeterminant !== undefined );
      return this._tDeterminant;
    },
    get tDeterminant() { return this.getTDeterminant(); },
    
    getTInflection1: function() {
      if ( this._tInflection1 === undefined ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection1 !== undefined );
      return this._tInflection1;
    },
    get tInflection1() { return this.getTInflection1(); },
    
    getTInflection2: function() {
      if ( this._tInflection2 === undefined ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection2 !== undefined );
      return this._tInflection2;
    },
    get tInflection2() { return this.getTInflection2(); },
    
    getStartQuadratic: function() {
      if ( this._startQuadratic === undefined ) {
        this.computeCuspSegments();
      }
      assert && assert( this._startQuadratic !== undefined );
      return this._startQuadratic;
    },
    get startQuadratic() { return this.getStartQuadratic(); },
    
    getEndQuadratic: function() {
      if ( this._endQuadratic === undefined ) {
        this.computeCuspSegments();
      }
      assert && assert( this._endQuadratic !== undefined );
      return this._endQuadratic;
    },
    get endQuadratic() { return this.getEndQuadratic(); },
    
    getXExtremaT: function() {
      if ( this._xExtremaT === undefined ) {
        this._xExtremaT = Segment.Cubic.extremaT( this._start.x, this._control1.x, this._control2.x, this._end.x );
      }
      return this._xExtremaT;
    },
    get xExtremaT() { return this.getXExtremaT(); },
    
    getYExtremaT: function() {
      if ( this._yExtremaT === undefined ) {
        this._yExtremaT = Segment.Cubic.extremaT( this._start.y, this._control1.y, this._control2.y, this._end.y );
      }
      return this._yExtremaT;
    },
    get yExtremaT() { return this.getYExtremaT(); },
    
    getBounds: function() {
      if ( this._bounds === undefined ) {
        this._bounds = Bounds2.NOTHING;
        this._bounds = this._bounds.withPoint( this._start );
        this._bounds = this._bounds.withPoint( this._end );
        
        var cubic = this;
        _.each( this.getXExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );
          }
        } );
        _.each( this.getYExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            cubic._bounds = cubic._bounds.withPoint( cubic.positionAt( t ) );
          }
        } );
        
        if ( this.hasCusp() ) {
          this._bounds = this._bounds.withPoint( this.positionAt( this.getTCusp() ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    
    // t value for the cusp, and the related determinant and inflection points
    computeCuspInfo: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      // TODO: allocation reduction
      var a = this._start.times( -1 ).plus( this._control1.times( 3 ) ).plus( this._control2.times( -3 ) ).plus( this._end );
      var b = this._start.times( 3 ).plus( this._control1.times( -6 ) ).plus( this._control2.times( 3 ) );
      var c = this._start.times( -3 ).plus( this._control1.times( 3 ) );

      var aPerp = a.perpendicular();
      var bPerp = b.perpendicular();
      var aPerpDotB = aPerp.dot( b );
      
      this._tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB );
      this._tDeterminant = this._tCusp * this._tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB );
      if ( this._tDeterminant >= 0 ) {
        var sqrtDet = Math.sqrt( this._tDeterminant );
        this._tInflection1 = this._tCusp - sqrtDet;
        this._tInflection2 = this._tCusp + sqrtDet;
      } else {
        this._tInflection1 = null;
        this._tInflection2 = null;
      }
    },
    
    // the cusp allows us to split into 2 quadratic Bezier curves
    computeCuspSegments: function() {
      if ( this.hasCusp() ) {
        // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.
        // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)
        var subdividedAtCusp = this.subdivided( this.getTCusp );
        this._startQuadratic = new Segment.Quadratic( subdividedAtCusp[0].start, subdividedAtCusp[0].control1, subdividedAtCusp[0].end, false );
        this._endQuadratic = new Segment.Quadratic( subdividedAtCusp[1].start, subdividedAtCusp[1].control2, subdividedAtCusp[1].end, false );
      } else {
        this._startQuadratic = null;
        this._endQuadratic = null;
      }
    },
    
    getNondegenerateSegments: function() {
      var start = this._start;
      var control1 = this._control1;
      var control2 = this._control2;
      var end = this._end;
      
      var reduced = this.degreeReduced( 1e-9 );
      
      if ( start.equals( end ) && start.equals( control1 ) && start.equals( control2 ) ) {
        // degenerate point
        return [];
      } else if ( this.hasCusp() ) {
        return _.flatten( [
          this._startQuadratic.getNondegenerateSegments(),
          this._endQuadratic.getNondegenerateSegments()
        ] );
      } else if ( reduced ) {
        // if we can reduce to a quadratic Bezier, always do this (and make sure it is non-degenerate)
        return reduced.getNondegenerateSegments();
      } else if ( arePointsCollinear( start, control1, end ) && arePointsCollinear( start, control2, end ) ) {
        throw new Error( 'TODO, use extrema T funcs' );
      } else {
        return [this];
      }
    },
    
    hasCusp: function() {
      var tCusp = this.getTCusp();
      
      var epsilon = 1e-7; // TODO: make this available to change?
      return this.tangentAt( tCusp ).magnitude() < epsilon && tCusp >= 0 && tCusp <= 1;
    },
    
    // position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end
    positionAt: function( t ) {
      var mt = 1 - t;
      return this._start.times( mt * mt * mt ).plus( this._control1.times( 3 * mt * mt * t ) ).plus( this._control2.times( 3 * mt * t * t ) ).plus( this._end.times( t * t * t ) );
    },
    
    // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2
    tangentAt: function( t ) {
      var mt = 1 - t;
      return this._start.times( -3 * mt * mt ).plus( this._control1.times( 3 * mt * mt - 6 * mt * t ) ).plus( this._control2.times( 6 * mt * t - 3 * t * t ) ).plus( this._end.times( 3 * t * t ) );
    },
    
    curvatureAt: function( t ) {
      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
      // TODO: remove code duplication with Quadratic
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = isZero ? this._control1 : this._control2;
        var p2 = isZero ? this._control2 : this._control1;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      } else {
        return this.subdivided( t )[0].curvatureAt( 1 );
      }
    },
    
    toRS: function( point ) {
      var firstVector = point.minus( this._start );
      return new Vector2( firstVector.dot( this.getR() ), firstVector.dot( this.getS() ) );
    },
    
    subdivided: function( t ) {
      // de Casteljau method
      // TODO: add a 'bisect' or 'between' method for vectors?
      var left = this._start.blend( this._control1, t );
      var right = this._control2.blend( this._end, t );
      var middle = this._control1.blend( this._control2, t );
      var leftMid = left.blend( middle, t );
      var rightMid = middle.blend( right, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new Segment.Cubic( this._start, left, leftMid, mid ),
        new Segment.Cubic( mid, rightMid, right, this._end )
      ];
    },
    
    offsetTo: function( r, reverse ) {
      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      
      // how many segments to create (possibly make this more adaptive?)
      var quantity = 32;
      
      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var t = i / ( quantity - 1 );
        if ( reverse ) {
          t = 1 - t;
        }
        
        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new Segment.Line( points[i-1], points[i] ) );
        }
      }
      
      return result;
    },
    
    getSVGPathFragment: function() {
      return 'C ' + this._control1.x + ' ' + this._control1.y + ' ' + this._control2.x + ' ' + this._control2.y + ' ' + this._end.x + ' ' + this._end.y;
    },
    
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },
    
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },
    
    getInteriorExtremaTs: function() {
      var ts = this.getXExtremaT().concat( this.getYExtremaT() );
      var result = [];
      _.each( ts, function( t ) {
        var epsilon = 0.0000000001; // TODO: general kite epsilon?
        if ( t > epsilon && t < 1 - epsilon ) {
          // don't add duplicate t values
          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {
            result.push( t );
          }
        }
      } );
      return result.sort();
    },
    
    intersectsBounds: function( bounds ) {
      throw new Error( 'Segment.Cubic.intersectsBounds unimplemented' ); // TODO: implement
    },
    
    // returns the resultant winding number of this ray intersecting this segment.
    intersection: function( ray ) {
      var self = this;
      var result = [];
      
      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );
      
      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control1 );
      var p2 = inverseMatrix.timesVector2( this._control2 );
      var p3 = inverseMatrix.timesVector2( this._end );
      
      // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;
      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;
      var c = -3 * p0.y + 3 * p1.y;
      var d = p0.y;
      
      var ts = solveCubicRootsReal( a, b, c, d );
      
      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.pos );
          
          // make sure it's not behind the ray
          if ( toHit.dot( ray.dir ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,
              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },
    
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },
    
    // assumes the current position is at start
    writeToContext: function( context ) {
      context.bezierCurveTo( this._control1.x, this._control1.y, this._control2.x, this._control2.y, this._end.x, this._end.y );
    },
    
    transformed: function( matrix ) {
      return new Segment.Cubic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control1 ), matrix.timesVector2( this._control2 ), matrix.timesVector2( this._end ) );
    },
    
    // returns a degree-reduced quadratic Bezier if possible, otherwise it returns null
    degreeReduced: function( epsilon ) {
      epsilon = epsilon || 0; // if not provided, use an exact version
      // TODO: allocation reduction
      // TODO: performance: don't divide both by 2 here, combine it later!!
      var controlA = this._control1.timesScalar( 3 ).minus( this._start ).dividedScalar( 2 );
      var controlB = this._control2.timesScalar( 3 ).minus( this._end ).dividedScalar( 2 );
      if ( controlA.minus( controlB ).magnitude() <= epsilon ) {
        return new Segment.Quadratic(
          this._start,
          controlA.average( controlB ), // average the control points for stability. they should be almost identical
          this._end
        );
      } else {
        // the two options for control points are too far away, this curve isn't easily reducible.
        return null;
      }
    }
    
    // returns the resultant winding number of this ray intersecting this segment.
    // windingIntersection: function( ray ) {
    //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
    //   var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() );
    //   assert && assert( inverseMatrix.timesVector2( ray.dir ).x > 0.99 ); // verify that we transform the unit vector to the x-unit
      
    //   var y0 = inverseMatrix.timesVector2( this._start ).y;
    //   var y1 = inverseMatrix.timesVector2( this._control1 ).y;
    //   var y2 = inverseMatrix.timesVector2( this._control2 ).y;
    //   var y3 = inverseMatrix.timesVector2( this._end ).y;
      
    //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
    //   var a = -y0 + 3 * y1 - 3 * y2 + y3;
    //   var b = 3 * y0 - 6 * y1 + 3 * y2;
    //   var c = -3 * y0 + 3 * y1;
    //   var d = y0;
      
    //   // solve cubic roots
    //   var ts = solveCubicRootsReal( a, b, c, d );
      
    //   var result = 0;
      
    //   // for each hit
    //   _.each( ts, function( t ) {
    //     if ( t >= 0 && t <= 1 ) {
    //       result += ray.dir.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;
    //     }
    //   } );
      
    //   return result;
    // }
  } );
  
  // finds what t values the cubic extrema are at (if any). This is just the 1-dimensional case, used for multiple purposes
  Segment.Cubic.extremaT = function( v0, v1, v2, v3 ) {
    // coefficients of derivative
    var a = -3 * v0 + 9 * v1 -9 * v2 + 3 * v3;
    var b =  6 * v0 - 12 * v1 + 6 * v2;
    var c = -3 * v0 + 3 * v1;
    
    return solveQuadraticRootsReal( a, b, c );
  };
  
  return Segment.Cubic;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Elliptical arc segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/EllipticalArc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/util/Subpath'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var toDegrees = require( 'DOT/Util' ).toDegrees;
  var DotUtil = require( 'DOT/Util' );

  var Segment = require( 'KITE/segments/Segment' );
  require( 'KITE/util/Subpath' );

  // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
  // Canvas notes at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse
  Segment.EllipticalArc = function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
    if ( radiusX < 0 ) {
      // support this case since we might actually need to handle it inside of strokes?
      radiusX = -radiusX;
      startAngle = Math.PI - startAngle;
      endAngle = Math.PI - endAngle;
      anticlockwise = !anticlockwise;
    }
    if ( radiusY < 0 ) {
      // support this case since we might actually need to handle it inside of strokes?
      radiusY = -radiusY;
      startAngle = -startAngle;
      endAngle = -endAngle;
      anticlockwise = !anticlockwise;
    }
    if ( radiusX < radiusY ) {
      // swap radiusX and radiusY internally for consistent Canvas / SVG output
      rotation += Math.PI / 2;
      startAngle -= Math.PI / 2;
      endAngle -= Math.PI / 2;
      
      // swap radiusX and radiusY
      var tmpR = radiusX;
      radiusX = radiusY;
      radiusY = tmpR;
    }
    
    this._center = center;
    this._radiusX = radiusX;
    this._radiusY = radiusY;
    this._rotation = rotation;
    this._startAngle = startAngle;
    this._endAngle = endAngle;
    this._anticlockwise = anticlockwise;
    
    // TODO: performance test removal of these undefined declarations
    this._unitTransform = undefined;
    this._start = undefined;
    this._end = undefined;
    this._startTangent = undefined;
    this._endTangent = undefined;
    this._actualEndAngle = undefined;
    this._isFullPerimeter = undefined;
    this._angleDifference = undefined;
    this._unitArcSegment = undefined;
    
    if ( radiusX < radiusY ) {
      // TODO: check this
      throw new Error( 'Not verified to work if radiusX < radiusY' );
    }
    
    // constraints shared with Segment.Arc
    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
  };
  inherit( Segment, Segment.EllipticalArc, {
    
    getCenter: function() {
      return this._center;
    },
    get center() { return this.getCenter(); },
    
    getRadiusX: function() {
      return this._radiusX;
    },
    get radiusX() { return this.getRadiusX(); },
    
    getRadiusY: function() {
      return this._radiusY;
    },
    get radiusY() { return this.getRadiusY(); },
    
    getRotation: function() {
      return this._rotation;
    },
    get rotation() { return this.getRotation(); },
    
    getStartAngle: function() {
      return this._startAngle;
    },
    get startAngle() { return this.getStartAngle(); },
    
    getEndAngle: function() {
      return this._endAngle;
    },
    get endAngle() { return this.getEndAngle(); },
    
    getAnticlockwise: function() {
      return this._anticlockwise;
    },
    get anticlockwise() { return this.getAnticlockwise(); },
    
    getUnitTransform: function() {
      if ( this._unitTransform === undefined ) {
        this._unitTransform = Segment.EllipticalArc.computeUnitTransform( this._center, this._radiusX, this._radiusY, this._rotation );
      }
      return this._unitTransform;
    },
    get unitTransform() { return this.getUnitTransform(); },
    
    getStart: function() {
      if ( this._start === undefined ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },
    
    getEnd: function() {
      if ( this._end === undefined ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },
    
    getStartTangent: function() {
      if ( this._startTangent === undefined ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    
    getEndTangent: function() {
      if ( this._endTangent === undefined ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    
    getActualEndAngle: function() {
      if ( this._actualEndAngle === undefined ) {
        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
        if ( this._anticlockwise ) {
          // angle is 'decreasing'
          // -2pi <= end - start < 2pi
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          } else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          } else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        } else {
          // angle is 'increasing'
          // -2pi < end - start <= 2pi
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          } else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          } else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },
    
    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === undefined ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },
    
    getAngleDifference: function() {
      if ( this._angleDifference === undefined ) {
        // compute an angle difference that represents how "much" of the circle our arc covers
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },
    
    // a unit arg segment that we can map to our ellipse. useful for hit testing and such.
    getUnitArcSegment: function() {
      if ( this._unitArcSegment === undefined ) {
        this._unitArcSegment = new Segment.Arc( Vector2.ZERO, 1, this._startAngle, this._endAngle, this._anticlockwise );
      }
      return this._unitArcSegment;
    },
    
    // temporary shims
    getBounds: function() {
      if ( this._bounds === undefined ) {
        this._bounds = Bounds2.NOTHING.withPoint( this.getStart() )
                                     .withPoint( this.getEnd() );
        
        // if the angles are different, check extrema points
        if ( this._startAngle !== this._endAngle ) {
          // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.
          // we find one extrema point for both x and y, since the other two are just rotated by pi from them.
          var xAngle = Math.atan( -( this._radiusY / this._radiusX ) * Math.tan( this._rotation ) );
          var yAngle = Math.atan( ( this._radiusY / this._radiusX ) / Math.tan( this._rotation ) );
          
          // check all of the extrema points
          this.possibleExtremaAngles = [
            xAngle,
            xAngle + Math.PI,
            yAngle,
            yAngle + Math.PI
          ];
          
          _.each( this.possibleExtremaAngles, this.includeBoundsAtAngle.bind( this ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    
    getNondegenerateSegments: function() {
      if ( this._radiusX <= 0 || this._radiusY <= 0 || this._startAngle === this._endAngle ) {
        return [];
      } else if ( this._radiusX === this._radiusY ) {
        // reduce to an Arc
        var startAngle = this._startAngle - this._rotation;
        var endAngle = this._endAngle - this._rotation;
        
        // preserve full circles
        if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
          endAngle = this._anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
        }
        return [new Segment.Arc( this._center, this._radiusX, startAngle, endAngle, this._anticlockwise )];
      } else {
        return [this];
      }
    },
    
    includeBoundsAtAngle: function( angle ) {
      if ( this.containsAngle( angle ) ) {
        // the boundary point is in the arc
        this._bounds = this._bounds.withPoint( this.positionAtAngle( angle ) );
      }
    },
    
    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
    mapAngle: function( angle ) {
      // consider an assert that we contain that angle?
      return ( this._startAngle > this.getActualEndAngle() ) ?
             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },
    
    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },
    
    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },
    
    positionAt: function( t ) {
      return this.positionAtAngle( this.angleAt( t ) );
    },
    
    tangentAt: function( t ) {
      return this.tangentAtAngle( this.angleAt( t ) );
    },
    
    curvatureAt: function( t ) {
      // see http://mathworld.wolfram.com/Ellipse.html (59)
      var angle = this.angleAt( t );
      var aq = this._radiusX * Math.sin( angle );
      var bq = this._radiusY * Math.cos( angle );
      var denominator = Math.pow( bq * bq + aq * aq, 3/2 );
      return ( this._anticlockwise ? -1 : 1 ) * this._radiusX * this._radiusY / denominator;
    },
    
    positionAtAngle: function( angle ) {
      return this.getUnitTransform().transformPosition2( Vector2.createPolar( 1, angle ) );
    },
    
    tangentAtAngle: function( angle ) {
      var normal = this.getUnitTransform().transformNormal2( Vector2.createPolar( 1, angle ) );
      
      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },
    
    // TODO: refactor? exact same as Segment.Arc
    containsAngle: function( angle ) {
      // transform the angle into the appropriate coordinate form
      // TODO: check anticlockwise version!
      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;
      
      // get the angle between 0 and 2pi
      var positiveMinAngle = normalizedAngle % ( Math.PI * 2 );
      // check this because modular arithmetic with negative numbers reveal a negative number
      if ( positiveMinAngle < 0 ) {
        positiveMinAngle += Math.PI * 2;
      }
      
      return positiveMinAngle <= this.getAngleDifference();
    },
    
    // discretizes the elliptical arc and returns an offset curve as a list of lineTos
    offsetTo: function( r, reverse ) {
      // how many segments to create (possibly make this more adaptive?)
      var quantity = 32;
      
      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var ratio = i / ( quantity - 1 );
        if ( reverse ) {
          ratio = 1 - ratio;
        }
        var angle = this.angleAt( ratio );
        
        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new Segment.Line( points[i-1], points[i] ) );
        }
      }
      
      return result;
    },
    
    getSVGPathFragment: function() {
      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
      // rx ry x-axis-rotation large-arc-flag sweep-flag x y
      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
      var sweepFlag = this._anticlockwise ? '0' : '1';
      var largeArcFlag;
      var degreesRotation = toDegrees( this._rotation ); // bleh, degrees?
      if ( this.getAngleDifference() < Math.PI * 2 - epsilon ) {
        largeArcFlag = this.getAngleDifference() < Math.PI ? '0' : '1';
        return 'A ' + this._radiusX + ' ' + this._radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.getEnd().x + ' ' + this.getEnd().y;
      } else {
        // ellipse (or almost-ellipse) case needs to be handled differently
        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs
        
        // get the angle that is between and opposite of both of the points
        var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
        var splitPoint = this.positionAtAngle( splitOppositeAngle );
        
        largeArcFlag = '0'; // since we split it in 2, it's always the small arc
        
        var firstArc = 'A ' + this._radiusX + ' ' + this._radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;
        var secondArc = 'A ' + this._radiusX + ' ' + this._radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.getEnd().x + ' ' + this.getEnd().y;
        
        return firstArc + ' ' + secondArc;
      }
    },
    
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },
    
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },
    
    // not including 0 and 1
    getInteriorExtremaTs: function() {
      var that = this;
      var result = [];
      _.each( this.possibleExtremaAngles, function( angle ) {
        if ( that.containsAngle( angle ) ) {
          var t = that.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },
    
    subdivided: function( t ) {
      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new Segment.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angle0, angleT, this._anticlockwise ),
        new Segment.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angleT, angle1, this._anticlockwise )
      ];
    },
    
    intersectsBounds: function( bounds ) {
      throw new Error( 'Segment.EllipticalArc.intersectsBounds unimplemented' );
    },
    
    intersection: function( ray ) {
      // be lazy. transform it into the space of a non-elliptical arc.
      var unitTransform = this.getUnitTransform();
      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );
      var hits = this.getUnitArcSegment().intersection( rayInUnitCircleSpace );
      
      return _.map( hits, function( hit ) {
        var transformedPoint = unitTransform.transformPosition2( hit.point );
        return {
          distance: ray.pos.distance( transformedPoint ),
          point: transformedPoint,
          normal: unitTransform.inverseNormal2( hit.normal ),
          wind: hit.wind
        };
      } );
    },
    
    // returns the resultant winding number of this ray intersecting this segment.
    windingIntersection: function( ray ) {
      // be lazy. transform it into the space of a non-elliptical arc.
      var rayInUnitCircleSpace = this.getUnitTransform().inverseRay2( ray );
      return this.getUnitArcSegment().windingIntersection( rayInUnitCircleSpace );
    },
    
    // assumes the current position is at start
    writeToContext: function( context ) {
      if ( context.ellipse ) {
        context.ellipse( this._center.x, this._center.y, this._radiusX, this._radiusY, this._rotation, this._startAngle, this._endAngle, this._anticlockwise );
      } else {
        // fake the ellipse call by using transforms
        this.getUnitTransform().getMatrix().canvasAppendTransform( context );
        context.arc( 0, 0, 1, this._startAngle, this._endAngle, this._anticlockwise );
        this.getUnitTransform().getInverse().canvasAppendTransform( context );
      }
    },
    
    transformed: function( matrix ) {
      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusX, this._rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusY, this._rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var rotation = transformedSemiMajorAxis.angle();
      var radiusX = transformedSemiMajorAxis.magnitude();
      var radiusY = transformedSemiMinorAxis.magnitude();
      
      var reflected = matrix.getDeterminant() < 0;
      
      // reverse the 'clockwiseness' if our transform includes a reflection
      // TODO: check reflections. swapping angle signs should fix clockwiseness
      var anticlockwise = reflected ? !this._anticlockwise : this._anticlockwise;
      var startAngle = reflected ? -this._startAngle : this._startAngle;
      var endAngle = reflected ? -this._endAngle : this._endAngle;
      
      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }
      
      return new Segment.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    }
  } );
  
  // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
  // transforms the unit circle onto our ellipse
  Segment.EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {
    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this._center) when available
                                  .timesMatrix( Matrix3.rotation2( rotation ) )
                                  .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );
  };
  
  return Segment.EllipticalArc;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Shape handling
 *
 * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.
 * Familiarity with how Canvas handles subpaths is helpful for understanding this code.
 *
 * Canvas spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html
 * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html
 *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)
 * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
 * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html
 *
 * TODO: add nonzero / evenodd support when browsers support it
 * TODO: docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/Shape',['require','KITE/kite','DOT/Vector2','DOT/Bounds2','DOT/Ray2','KITE/util/Subpath','KITE/../parser/svgPath','KITE/util/LineStyles','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {
  
  
  var kite = require( 'KITE/kite' );
  
  // TODO: clean up imports
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Ray2 = require( 'DOT/Ray2' );

  var Subpath = require( 'KITE/util/Subpath' );
  
  var svgPath = require( 'KITE/../parser/svgPath' );
  require( 'KITE/util/LineStyles' );
  require( 'KITE/segments/Arc' );
  require( 'KITE/segments/Cubic' );
  require( 'KITE/segments/EllipticalArc' );
  require( 'KITE/segments/Line' );
  require( 'KITE/segments/Quadratic' );
  
  // for brevity
  function p( x,y ) { return new Vector2( x, y ); }
  function v( x,y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type
  
  // a normalized vector for non-zero winding checks
  // var weirdDir = p( Math.PI, 22 / 7 );
  
  // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'
  kite.Shape = function Shape( subpaths, bounds ) {
    // lower-level piecewise mathematical description using segments, also individually immutable
    this.subpaths = ( typeof subpaths === 'object' ) ? subpaths : [];
    assert && assert( this.subpaths.length === 0 || this.subpaths[0].constructor.name !== 'Array' );
    
    // computed bounds for all pieces added so far
    this.bounds = ( bounds || Bounds2.NOTHING ).copy();
    
    var that = this;
    if ( subpaths && typeof subpaths !== 'object' ) {
      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' );
      // parse the SVG path
      _.each( svgPath.parse( subpaths ), function( item ) {
        assert && assert( Shape.prototype[item.cmd] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );
        that[item.cmd].apply( that, item.args );
      } );
    }
    
    phetAllocation && phetAllocation( 'Shape' );
  };
  var Shape = kite.Shape;
  
  Shape.prototype = {
    constructor: Shape,
    
    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },
    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },
    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },
    moveToPoint: function( point ) {
      return this.addSubpath( new kite.Subpath().addPoint( point ) );
    },
    
    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },
    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },
    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },
    lineToPoint: function( point ) {
      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-lineto
      if ( this.hasSubpaths() ) {
        var start = this.getLastSubpath().getLastPoint();
        var end = point;
        var line = new kite.Segment.Line( start, end );
        this.getLastSubpath().addPoint( end );
        this.addSegmentAndBounds( line );
        assert && assert( !isNaN( this.bounds.getX() ) );
      } else {
        this.ensure( point );
      }
      
      return this;
    },
    
    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },
    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },
    
    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },
    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },
    
    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },
    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },
    quadraticCurveToPointRelative: function( controlPoint, point ) {
      var relativePoint = this.getRelativePoint();
      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );
    },
    // TODO: consider a rename to put 'smooth' farther back?
    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },
    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },
    quadraticCurveToPoint: function( controlPoint, point ) {
      var shape = this;
      
      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto
      this.ensure( controlPoint );
      var start = this.getLastSubpath().getLastPoint();
      var quadratic = new kite.Segment.Quadratic( start, controlPoint, point );
      this.getLastSubpath().addPoint( point );
      var nondegenerateSegments = quadratic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        // TODO: optimization
        shape.addSegmentAndBounds( segment );
      } );
      return this;
    },
    
    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
    cubicCurveToPointRelative: function( control1, control2, point ) {
      var relativePoint = this.getRelativePoint();
      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );
    },
    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },
    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },
    cubicCurveToPoint: function( control1, control2, point ) {
      var shape = this;
      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto
      this.ensure( control1 );
      var start = this.getLastSubpath().getLastPoint();
      var cubic = new kite.Segment.Cubic( start, control1, control2, point );
      
      var nondegenerateSegments = cubic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        shape.addSegmentAndBounds( segment );
      } );
      this.getLastSubpath().addPoint( point );
      
      return this;
    },
    
    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },
    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {
      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc
      
      var arc = new kite.Segment.Arc( center, radius, startAngle, endAngle, anticlockwise );
      
      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
      var startPoint = arc.getStart();
      var endPoint = arc.getEnd();
      
      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }
      
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new kite.Subpath() );
      }
      
      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );
      
      this.addSegmentAndBounds( arc );
      
      return this;
    },
    
    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },
    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc
      
      var ellipticalArc = new kite.Segment.EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
      
      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
      var startPoint = ellipticalArc.start;
      var endPoint = ellipticalArc.end;
      
      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }
      
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new kite.Subpath() );
      }
      
      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );
      
      this.addSegmentAndBounds( ellipticalArc );
      
      return this;
    },
    
    close: function() {
      if ( this.hasSubpaths() ) {
        var previousPath = this.getLastSubpath();
        var nextPath = new kite.Subpath();
        
        previousPath.close();
        this.addSubpath( nextPath );
        nextPath.addPoint( previousPath.getFirstPoint() );
      }
      return this;
    },
    
    // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html
    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      var relativePoint = this.getRelativePoint();
      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );
    },
    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      throw new Error( 'ellipticalArcTo unimplemented' );
    },
    
    /*
     * Draws a circle using the arc() call with the following parameters:
     * circle( center, radius ) // center is a Vector2
     * circle( centerX, centerY, radius )
     */
    circle: function( centerX, centerY, radius ) {
      if ( typeof centerX === 'object' ) {
        // circle( center, radius )
        var center = centerX;
        radius = centerY;
        return this.arcPoint( center, radius, 0, Math.PI * 2, false );
      } else {
        // circle( centerX, centerY, radius )
        return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );
      }
    },
    
    /*
     * Draws an ellipse using the ellipticalArc() call with the following parameters:
     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2
     * ellipse( centerX, centerY, radiusX, radiusY, rotation )
     *
     * The rotation is about the centerX, centerY.
     */
    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {
      // TODO: separate into ellipse() and ellipsePoint()?
      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
      if ( typeof centerX === 'object' ) {
        // ellipse( center, radiusX, radiusY, rotation )
        var center = centerX;
        rotation = radiusY;
        radiusY = radiusX;
        radiusX = centerY;
        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );
      } else {
        // ellipse( centerX, centerY, radiusX, radiusY, rotation )
        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );
      }
    },
    
    rect: function( x, y, width, height ) {
      var subpath = new kite.Subpath();
      this.addSubpath( subpath );
      subpath.addPoint( v( x, y ) );
      subpath.addPoint( v( x + width, y ) );
      subpath.addPoint( v( x + width, y + height ) );
      subpath.addPoint( v( x, y + height ) );
      this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[0], subpath.points[1] ) );
      this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[1], subpath.points[2] ) );
      this.addSegmentAndBounds( new kite.Segment.Line( subpath.points[2], subpath.points[3] ) );
      subpath.close();
      this.addSubpath( new kite.Subpath() );
      this.getLastSubpath().addPoint( v( x, y ) );
      assert && assert( !isNaN( this.bounds.getX() ) );
      
      return this;
    },

    //Create a round rectangle. All arguments are number.
    roundRect: function( x, y, width, height, arcw, arch ) {
      var lowX = x + arcw;
      var highX = x + width - arcw;
      var lowY = y + arch;
      var highY = y + height - arch;
      // if ( true ) {
      if ( arcw === arch ) {
        // we can use circular arcs, which have well defined stroked offsets
        this.arc( highX, lowY, arcw, -Math.PI / 2, 0, false )
            .arc( highX, highY, arcw, 0, Math.PI / 2, false )
            .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )
            .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )
            .close();
      } else {
        // we have to resort to elliptical arcs
        this.ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )
            .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )
            .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )
            .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )
            .close();
      }
      return this;
    },
    
    polygon: function( vertices ) {
      var length = vertices.length;
      if ( length > 0 ) {
        this.moveToPoint( vertices[0] );
        for ( var i = 1; i < length; i++ ) {
          this.lineToPoint( vertices[i] );
        }
      }
      return this.close();
    },
    
    copy: function() {
      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one
      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );
    },
    
    // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!
    writeToContext: function( context ) {
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        this.subpaths[i].writeToContext( context );
      }
    },
    
    // returns something like "M150 0 L75 200 L225 200 Z" for a triangle
    getSVGPath: function() {
      var subpathStrings = [];
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        var subpath = this.subpaths[i];
        if( subpath.isDrawable() ) {
          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point
          var startPoint = subpath.getFirstSegment().start;
          assert && assert( startPoint.equals( subpath.getFirstPoint(), 0.00001 ) ); // sanity check
          var string = 'M ' + startPoint.x + ' ' + startPoint.y + ' ';
          
          string += _.map( subpath.segments, function( segment ) { return segment.getSVGPathFragment(); } ).join( ' ' );
          
          if ( subpath.isClosed() ) {
            string += ' Z';
          }
          subpathStrings.push( string );
        }
      }
      return subpathStrings.join( ' ' );
    },
    
    // return a new Shape that is transformed by the associated matrix
    transformed: function( matrix ) {
      // TODO: allocation reduction
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },
    
    /*
     * Provided options (see Segment.nonlinearTransformed)
     * - minLevels:                       how many levels to force subdivisions
     * - maxLevels:                       prevent subdivision past this level
     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve. smaller => more subdivision
     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments. smaller => more subdivision
     * -   OR includeCurvature:           {Boolean}, whether to include a default curveEpsilon (usually off by default)
     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                    instead of using our brute-force logic. Supports optimizations for custom non-linear transforms (like polar coordinates)
     */
    nonlinearTransformed: function( options ) {
      // defaults
      options = _.extend( {
        minLevels: 0,
        maxLevels: 7,
        distanceEpsilon: 0.16, // NOTE: this will change when the Shape is scaled, since this is a threshold for the square of a distance value
        curveEpsilon: ( options && options.includeCurvature ) ? 0.002 : null
      }, options );
      
      // TODO: allocation reduction
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.nonlinearTransformed( options ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },
    
    /*
     * Maps points by treating their x coordinate as polar angle, and y coordinate as polar magnitude.
     * See http://en.wikipedia.org/wiki/Polar_coordinate_system
     *
     * Please see Shape.nonlinearTransformed for more documentation on adaptive discretization options (minLevels, maxLevels, distanceEpsilon, curveEpsilon)
     *
     * Example: A line from (0,10) to (pi,10) will be transformed to a circular arc from (10,0) to (-10,0) passing through (0,10).
     */
    polarToCartesian: function( options ) {
      return this.nonlinearTransformed( _.extend( {
        pointMap: function( p ) {
          return Vector2.createPolar( p.y, p.x );
          // return new Vector2( p.y * Math.cos( p.x ), p.y * Math.sin( p.x ) );
        },
        methodName: 'polarToCartesian' // this will be called on Segments if it exists to do more optimized conversion (see Line)
      }, options ) );
    },
    
    /*
     * Converts each segment into lines, using an adaptive (midpoint distance subdivision) method.
     *
     * NOTE: uses nonlinearTransformed method internally, but since we don't provide a pointMap or methodName, it won't create anything but line segments.
     * See nonlinearTransformed for documentation of options
     */
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments' );
      assert && assert( !options.methodName, 'No methodName for toPiecewiseLinear allowed, since it could create non-linear segments' );
      return this.nonlinearTransformed( options );
    },
    
    // returns the bounds. if lineStyles exists, include the stroke in the bounds
    // TODO: consider renaming to getBounds()?
    computeBounds: function( lineStyles ) {
      if ( lineStyles ) {
        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );
      } else {
        return this.bounds;
      }
    },
    
    containsPoint: function( point ) {
      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape
      var ray = new Ray2( point, Vector2.X_UNIT );
      
      return this.windingIntersection( ray ) !== 0;
    },
    
    intersection: function( ray ) {
      var hits = [];
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[i];
        
        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            var segment = subpath.segments[k];
            hits = hits.concat( segment.intersection( ray ) );
          }
          
          if ( subpath.hasClosingSegment() ) {
            hits = hits.concat( subpath.getClosingSegment().intersection( ray ) );
          }
        }
      }
      return _.sortBy( hits, function( hit ) { return hit.distance; } );
    },
    
    windingIntersection: function( ray ) {
      var wind = 0;
      
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[i];
        
        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            wind += subpath.segments[k].windingIntersection( ray );
          }
          
          // handle the implicit closing line segment
          if ( subpath.hasClosingSegment() ) {
            wind += subpath.getClosingSegment().windingIntersection( ray );
          }
        }
      }
      
      return wind;
    },
    
    intersectsBounds: function( bounds ) {
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[i];
        
        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            if ( subpath.segments[k].intersectsBounds( bounds ) ) {
              return true;
            }
          }
          
          // handle the implicit closing line segment
          if ( subpath.hasClosingSegment() ) {
            if ( subpath.getClosingSegment().intersectsBounds( bounds ) ) {
              return true;
            }
          }
        }
      }
      return false;
    },
    
    // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)
    // TODO: rename stroked( lineStyles )
    getStrokedShape: function( lineStyles ) {
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        var subpath = this.subpaths[i];
        var strokedSubpath = subpath.stroked( lineStyles );
        subpaths = subpaths.concat( strokedSubpath );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[i].bounds );
      }
      return new Shape( subpaths, bounds );
    },
    
    toString: function() {
      // TODO: consider a more verbose but safer way?
      return 'new kite.Shape( \'' + this.getSVGPath() + '\' )';
    },
    
    /*---------------------------------------------------------------------------*
    * Internal subpath computations
    *----------------------------------------------------------------------------*/
    
    addSegmentAndBounds: function( segment ) {
      this.getLastSubpath().addSegment( segment );
      this.bounds = this.bounds.includeBounds( this.getLastSubpath().bounds );
    },
    
    ensure: function( point ) {
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
        this.getLastSubpath().addPoint( point );
      }
    },
    
    addSubpath: function( subpath ) {
      this.subpaths.push( subpath );
      
      return this; // allow chaining
    },
    
    hasSubpaths: function() {
      return this.subpaths.length > 0;
    },
    
    getLastSubpath: function() {
      return _.last( this.subpaths );
    },
    
    // gets the last point in the last subpath, or null if it doesn't exist
    getLastPoint: function() {
      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;
    },
    
    getLastSegment: function() {
      if ( !this.hasSubpaths() ) { return null; }
      
      var subpath = this.getLastSubpath();
      if ( !subpath.isDrawable() ) { return null; }
      
      return subpath.getLastSegment();
    },
    
    // returns the point to be used for smooth quadratic segments
    getSmoothQuadraticControlPoint: function() {
      var lastPoint = this.getLastPoint();
      
      var segment = this.getLastSegment();
      if ( !segment || !( segment instanceof kite.Segment.Quadratic ) ) { return lastPoint; }
      
      return lastPoint.plus( lastPoint.minus( segment.control ) );
    },
    
    // returns the point to be used for smooth cubic segments
    getSmoothCubicControlPoint: function() {
      var lastPoint = this.getLastPoint();
      
      var segment = this.getLastSegment();
      if ( !segment || !( segment instanceof kite.Segment.Cubic ) ) { return lastPoint; }
      
      return lastPoint.plus( lastPoint.minus( segment.control2 ) );
    },
    
    getRelativePoint: function() {
      var lastPoint = this.getLastPoint();
      return lastPoint ? lastPoint : Vector2.ZERO;
    }
  };
  
  /*---------------------------------------------------------------------------*
  * Shape shortcuts
  *----------------------------------------------------------------------------*/
  
  Shape.rectangle = function( x, y, width, height ) {
    return new Shape().rect( x, y, width, height );
  };
  Shape.rect = Shape.rectangle;

  //Create a round rectangle. All arguments are number.
  //Rounding is currently using quadraticCurveTo.  Please note, future versions may use arcTo
  //TODO: rewrite with arcTo?
  Shape.roundRect = function( x, y, width, height, arcw, arch ) {
    return new Shape().roundRect( x, y, width, height, arcw, arch );
  };
  Shape.roundRectangle = Shape.roundRect;
  
  Shape.polygon = function( vertices ) {
    return new Shape().polygon( vertices );
  };
  
  Shape.bounds = function( bounds ) {
    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );
  };

  //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments
  Shape.lineSegment = function( a, b, c, d ) {
    // TODO: add type assertions?
    if ( typeof a === 'number' ) {
      return new Shape().moveTo( a, b ).lineTo( c, d );
    }
    else {
      return new Shape().moveToPoint( a ).lineToPoint( b );
    }
  };
  
  Shape.regularPolygon = function( sides, radius ) {
    var shape = new Shape();
    _.each( _.range( sides ), function( k ) {
      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );
      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );
    } );
    return shape.close();
  };
  
  // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0
  Shape.circle = function( centerX, centerY, radius ) {
    if ( centerY === undefined ) {
      // circle( radius ), center = 0,0
      return new Shape().circle( 0, 0, centerX );
    }
    return new Shape().circle( centerX, centerY, radius ).close();
  };
  
  /*
   * Supports ellipse( centerX, centerY, radiusX, radiusY, rotation ), ellipse( center, radiusX, radiusY, rotation ), and ellipse( radiusX, radiusY, rotation )
   * with the center default to 0,0 and rotation of 0.  The rotation is about the centerX, centerY.
   */
  Shape.ellipse = function( centerX, centerY, radiusX, radiusY, rotation ) {
    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
    if ( radiusY === undefined ) {
      // ellipse( radiusX, radiusY ), center = 0,0
      return new Shape().ellipse( 0, 0, centerX, centerY, radiusX );
    }
    return new Shape().ellipse( centerX, centerY, radiusX, radiusY, rotation ).close();
  };
  
  // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )
  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {
    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );
  };
  
  return Shape;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Mix-in for Node's event handling, with experimental performance enhancements
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/FixedNodeEvents',['require','SCENERY/scenery'],function( require ) {
  

  var scenery = require( 'SCENERY/scenery' );

  var eventNames = [
    'selfBounds',
    'childBounds',
    'bounds',
    'resize',
    'boundsAccuracy'
  ];

  scenery.FixedNodeEvents = function FixedNodeEvents( type ) {
    var proto = type.prototype;

    // this should be called in the constructor to initialize
    proto.initializeNodeEvents = function() {
      this._events = {};

      var node = this;

      // TODO: performance: consider delaying this? Could affect memory usage?
      var len = eventNames.length;
      for ( var i = 0; i < len; i++ ) {
        node._events[eventNames[i]] = [];
      }
    };

    /**
     * @param {String}   type     The type of event, like 'resize' or 'bounds'
     * @param {Function} listener Callback, called with arguments that depend on the event type
     */
    proto.addEventListener = function( type, listener ) {
      assert && assert( type !== undefined && listener !== undefined,
        'Both a type and listener are required for addEventListener' );

      // most commonly a bug, maybe there will be a good use case? can always work around by wrapping with a new function each time
      assert && assert( _.indexOf( this._events[type], listener ),
        'Event listener was already there for addEventListener with type ' + type );

      this._events[type].push( listener );

      // allow chaining
      return this;
    };

    /**
     * Check to see whether this Node contains the specified listener
     * @param {string} type type of listener
     * @param {function} listener the listener instance
     * @returns {boolean} true if the listener is already registered with this Node
     */
    proto.containsEventListener = function( type, listener ) {
      return _.indexOf( this._events[type], listener ) >= 0;
    };

    /**
     * @param {String}   type     The type of event, like 'resize' or 'bounds'
     * @param {Function} listener The callback to remove.
     */
    proto.removeEventListener = function( type, listener ) {
      assert && assert( type !== undefined && listener !== undefined,
        'Both a type and listener are required for removeEventListener' );

      // ensure the listener is in our list
      assert && assert( _.indexOf( this._events[type], listener ) !== -1,
        'Listener did not exist for type ' + type );

      this._events[type].splice( _.indexOf( this._events[type], listener ), 1 );

      // allow chaining
      return this;
    };

    /*
     * Fires an event to all event listeners attached to this node. It does not bubble down to
     * all ancestors with trails, like dispatchEvent does. Use fireEvent when you only want an event
     * that is relevant for a specific node, and ancestors don't need to be notified.
     */
    proto.fireEvent = function( type, args ) {
      assert && assert( _.contains( eventNames, type ),
        'unknown event type: ' + type );

      var events = this._events[type];
      var len = events.length;
      if ( len ) { // TODO: consider removing branch? is this even helpful?
        var copy = events.slice( 0 ); // defensive copy, in case listeners are added or removed as a side effect of a listener being called
        for ( var i = 0; i < len; i++ ) {
          copy[i]( args );
        }
      }
    };
  };
  var FixedNodeEvents = scenery.FixedNodeEvents;

  return FixedNodeEvents;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A node for the Scenery scene graph. Supports general directed acyclic graphics (DAGs).
 * Handles multiple layers with assorted types (Canvas 2D, SVG, DOM, WebGL, etc.).
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Node',['require','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','DOT/Vector2','DOT/Util','KITE/Shape','SCENERY/scenery','SCENERY/util/FixedNodeEvents'],function( require ) {
  
  
  var Bounds2 = require( 'DOT/Bounds2' );
  var Transform3 = require( 'DOT/Transform3' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Vector2 = require( 'DOT/Vector2' );
  var clamp = require( 'DOT/Util' ).clamp;
  
  var Shape = require( 'KITE/Shape' );
  
  var scenery = require( 'SCENERY/scenery' );
  var NodeEvents = require( 'SCENERY/util/FixedNodeEvents' ); // uncapitalized, because of JSHint (TODO: find the flag)
  // require( 'SCENERY/layers/Renderer' ); // commented out so Require.js doesn't balk at the circular dependency
  
  // TODO: FIXME: Why do I have to comment out this dependency?
  // require( 'SCENERY/util/Trail' );
  // require( 'SCENERY/util/TrailPointer' );
  
  var globalIdCounter = 1;
  
  /*
   * Available keys for use in the options parameter object for a vanilla Node (not inherited), in the order they are executed in:
   *
   * children:         A list of children to add (in order)
   * cursor:           Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The Scene needs to have input listeners attached with an initialize method first.
   * visible:          If false, this node (and its children) will not be displayed (or get input events)
   * pickable:         If false, this node (and its children) will not get input events
   * translation:      Sets the translation of the node to either the specified dot.Vector2 value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )
   * x:                Sets the x-translation of the node
   * y:                Sets the y-translation of the node
   * rotation:         Sets the rotation of the node in radians
   * scale:            Sets the scale of the node. Supports either a number (same x-y scale), or a dot.Vector2 / object with ob.x and ob.y to set the scale for each axis independently
   * left:             Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at the specified value
   * right:            Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at the specified value
   * top:              Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the specified value
   * bottom:           Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is at the specified value
   * centerX:          Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate frame) is at the specified value
   * centerY:          Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame) is at the specified value
   * renderer:         Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible, children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)
   * rendererOptions:  Parameter object that is passed to the created layer, and can affect how the layering process works.
   * layerSplit:       Forces a split between layers before and after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.
   * mouseArea:        Shape (in local coordinate frame) that overrides the 'hit area' for mouse input.
   * touchArea:        Shape (in local coordinate frame) that overrides the 'hit area' for touch input.
   * clipArea:         Shape (in local coordinate frame) that causes any graphics outside of the shape to be invisible (for the node and any children).
   */
  scenery.Node = function Node( options ) {
    var self = this;
    
    // assign a unique ID to this node (allows trails to get a unique list of IDs)
    this._id = globalIdCounter++;
    
    // all of the Instances tracking this Node (across multiple layers and scenes)
    this._instances = [];
    
    // Whether this node (and its children) will be visible when the scene is updated. Visible nodes by default will not be pickable either
    this._visible = true;
    
    // Opacity from 0 to 1
    this._opacity = 1;
    
    // Whether this node (and its subtree) will allow hit-testing (and thus user interaction). Notably:
    // pickable: null  - default. Node is only pickable if it (or an ancestor/descendant) has either an input listener or pickable: true set
    // pickable: false - Node (and subtree) is pickable, just like if there is an input listener
    // pickable: true  - Node is unpickable (only has an effect when underneath a node with an input listener / pickable: true set)
    this._pickable = null;
    
    // This node and all children will be clipped by this shape (in addition to any other clipping shapes).
    // The shape should be in the local coordinate frame
    this._clipArea = null;
    
    // areas for hit intersection. if set on a Node, no descendants can handle events
    this._mouseArea = null; // {Shape|Bounds2} for mouse position          in the local coordinate frame
    this._touchArea = null; // {Shape|Bounds2} for touch and pen position  in the local coordinate frame
    
    // the CSS cursor to be displayed over this node. null should be the default (inherit) value
    this._cursor = null;
    
    this._children = []; // ordered
    this._parents = []; // unordered
    
    this._peers = []; // array of peer factories: { element: ..., options: ... }, where element can be an element or a string
    this._liveRegions = []; // array of live region instances
    
    /*
     * Set up the transform reference. we add a listener so that the transform itself can be modified directly
     * by reference, or node.transform = <transform> / node.setTransform() can be used to change the transform reference.
     * Both should trigger the necessary event notifications for Scenery to keep track internally.
     */
    this._transform = new Transform3();
    this._transformListener = {
      // TODO: performance handling so we don't need to do two recursions!
      before: function() { self.beforeTransformChange(); },
      after: function() { self.afterTransformChange(); }
    };
    this._transform.addTransformListener( this._transformListener );
    
    this._inputListeners = []; // for user input handling (mouse/touch)
    this.initializeNodeEvents(); // for internal events like paint invalidation, layer invalidation, etc.
    
    // bounds handling
    this._bounds = Bounds2.NOTHING;      // for this node and its children, in "parent" coordinates
    this._selfBounds = Bounds2.NOTHING;  // just for this node, in "local" coordinates
    this._childBounds = Bounds2.NOTHING; // just for children, in "local" coordinates
    this._localBounds = null; // just used for an override currently, will be replaced in Scenery ohtwo
    this._boundsDirty = true;
    this._selfBoundsDirty = this.isPainted();
    this._childBoundsDirty = true;
    
    // Similar to bounds, but includes any mouse/touch areas respectively. They are validated separately (immediately after normal bounds validation),
    // and are only non-null if there are mouseAreas/touchAreas in this node or any descendants. null indicates that the normal bounds can be treated
    // as the mouse/touch bounds, and hit pruning can use those instead. These are needed because mouse/touch areas (and thus pruning bounds) can be
    // larger than the actual bounds (display bounds, _bounds above)
    this._mouseBounds = null;
    this._mouseBoundsDirty = true;
    this._touchBounds = null;
    this._touchBoundsDirty = true;
    
    // dirty region handling
    this._paintDirty = false;        // whether the self paint is dirty (just this node, none of its children)
    this._subtreePaintDirty = false; // whether the subtree paint is dirty (this node and its children, usually after a transform)
    this._childPaintDirty = false;   // whether the child paint is dirty (excluding self paint, just used for finding _paintDirty, _selfPaintDirty)
    
    // what type of renderer should be forced for this node.
    this._renderer = null;
    this._rendererOptions = null; // options that will determine the layer type
    this._rendererLayerType = null; // cached layer type that is used by the LayerStrategy
    
    // whether layers should be split before and after this node
    this._layerSplit = false;
    
    // the subtree pickable count is #pickable:true + #inputListeners, since we can prune subtrees with a pickable count of 0
    this._subtreePickableCount = 0;
    
    this._rendererBitmask = scenery.bitmaskNodeDefault;
    this._subtreeRendererBitmask = scenery.bitmaskNodeDefault; // value not important initially, since it is dirty
    // this._subtreeRendererBitmaskDirty = true; // TODO: include dirty flag!
    
    if ( options ) {
      this.mutate( options );
    }
    
    phetAllocation && phetAllocation( 'Node' );
  };
  var Node = scenery.Node;
  
  Node.prototype = {
    constructor: Node,
    
    insertChild: function( index, node ) {
      assert && assert( node !== null && node !== undefined, 'insertChild cannot insert a null/undefined child' );
      assert && assert( !_.contains( this._children, node ), 'Parent already contains child' );
      assert && assert( node !== this, 'Cannot add self as a child' );
      
      // needs to be early to prevent re-entrant children modifications
      this.changePickableCount( node._subtreePickableCount );
      
      node._parents.push( this );
      this._children.splice( index, 0, node );
      
      node.invalidateBounds();
      this._boundsDirty = true; // like calling this.invalidateBounds(), but we already marked all ancestors with dirty child bounds
      
      this.markForInsertion( node, index );
      this.notifyStitch( false );
      
      node.invalidateSubtreePaint();
    },
    
    addChild: function( node ) {
      this.insertChild( this._children.length, node );
    },
    
    removeChild: function( node ) {
      assert && assert( node );
      assert && assert( this.isChild( node ) );
      
      var indexOfChild = _.indexOf( this._children, node );
      
      this.removeChildWithIndex( node, indexOfChild );
    },
    
    removeChildAt: function( index ) {
      assert && assert( index >= 0 );
      assert && assert( index < this._children.length );
      
      var node = this._children[index];
      
      this.removeChildWithIndex( node, index );
    },
    
    // meant for internal use
    removeChildWithIndex: function( node, indexOfChild ) {
      assert && assert( node );
      assert && assert( this.isChild( node ) );
      assert && assert( this._children[indexOfChild] === node );
      
      // needs to be early to prevent re-entrant children modifications
      this.changePickableCount( -node._subtreePickableCount );
      
      node.markOldPaint( false );
      
      var indexOfParent = _.indexOf( node._parents, this );
      
      this.markForRemoval( node, indexOfChild );
      
      node._parents.splice( indexOfParent, 1 );
      this._children.splice( indexOfChild, 1 );
      
      this.invalidateBounds();
      this._childBoundsDirty = true; // force recomputation of child bounds after removing a child
      
      this.notifyStitch( false );
    },
    
    removeAllChildren: function() {
      this.setChildren( [] );
    },
    
    // TODO: efficiency by batching calls?
    setChildren: function( children ) {
      if ( this._children !== children ) {
        // remove all children in a way where we don't have to copy the child array for safety
        while ( this._children.length ) {
          this.removeChild( this._children[this._children.length-1] );
        }
        
        var len = children.length;
        for ( var i = 0; i < len; i++ ) {
          this.addChild( children[i] );
        }
      }
    },
    
    getChildren: function() {
      // TODO: ensure we are not triggering this in Scenery code when not necessary!
      return this._children.slice( 0 ); // create a defensive copy
    },
    
    getChildrenCount: function() {
      return this._children.length;
    },
    
    getParents: function() {
      return this._parents.slice( 0 ); // create a defensive copy
    },
    
    // returns a single parent if it exists, otherwise null (no parents), or an assertion failure (multiple parents)
    getParent: function() {
      assert && assert( this._parents.length <= 1, 'Cannot call getParent on a node with multiple parents' );
      return this._parents.length ? this._parents[0] : null;
    },
    
    getChildAt: function( index ) {
      return this._children[index];
    },
    
    indexOfParent: function( parent ) {
      return _.indexOf( this._parents, parent );
    },
    
    indexOfChild: function( child ) {
      return _.indexOf( this._children, child );
    },
    
    moveToFront: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToFront( self );
      } );
    },
    
    moveChildToFront: function( child ) {
      if ( this.indexOfChild( child ) !== this._children.length - 1 ) {
        this.removeChild( child );
        this.addChild( child );
      }
    },
    
    moveToBack: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToBack( self );
      } );
    },
    
    moveChildToBack: function( child ) {
      if ( this.indexOfChild( child ) !== 0 ) {
        this.removeChild( child );
        this.insertChild( 0, child );
      }
    },
    
    // remove this node from its parents
    detach: function() {
      var that = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.removeChild( that );
      } );
    },
    
    // propagate the pickable count change down to our ancestors
    changePickableCount: function( n ) {
      this._subtreePickableCount += n;
      assert && assert( this._subtreePickableCount >= 0, 'subtree pickable count should be guaranteed to be >= 0' );
      var len = this._parents.length;
      for ( var i = 0; i < len; i++ ) {
        this._parents[i].changePickableCount( n );
      }
    },
    
    // currently, there is no way to remove peers. if a string is passed as the element pattern, it will be turned into an element
    addPeer: function( element, options ) {
      assert && assert( !this.instances.length, 'Cannot call addPeer after a node has instances (yet)' );
      
      this._peers.push( { element: element, options: options } );
    },

    /**               
     * @param property any object that has es5 getter for 'value' es5 setter for value, and 
     */
    addLiveRegion: function( property, options ) {
      this._liveRegions.push( {property: property, options: options} );
    },
    
    // should be overridden to modify (increase ONLY if Canvas is involved) the node's bounds. Return the expanded bounds.
    overrideBounds: function( computedBounds ) {
      return computedBounds;
    },
    
    // ensure that cached bounds stored on this node (and all children) are accurate
    validateBounds: function() {
      var that = this;
      var i;
      
      if ( this._selfBoundsDirty ) {
        // note: this should only be triggered if the bounds were actually changed, since we have a guard in place at invalidateSelf()
        this._selfBoundsDirty = false;
        
        // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
        this.fireEvent( 'selfBounds', this._selfBounds );
      }
      
      // validate bounds of children if necessary
      if ( this._childBoundsDirty ) {
        
        // have each child validate their own bounds
        i = this._children.length;
        while ( i-- ) {
          this._children[i].validateBounds();
        }
        
        var oldChildBounds = this._childBounds;
        
        // and recompute our _childBounds
        this._childBounds = Bounds2.NOTHING.copy();
        
        i = this._children.length;
        while ( i-- ) {
          this._childBounds.includeBounds( this._children[i]._bounds );
        }
        
        // run this before firing the event
        this._childBoundsDirty = false;
        
        if ( !this._childBounds.equals( oldChildBounds ) ) {
          // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
          this.fireEvent( 'childBounds', this._childBounds );
        }
      }
      
      // TODO: layout here?
      
      if ( this._boundsDirty ) {
        // run this before firing the event
        this._boundsDirty = false;
        
        var oldBounds = this._bounds;
        
        // converts local to parent bounds. mutable methods used to minimize number of created bounds instances (we create one so we don't change references to the old one)
        var localBounds = this._localBounds ? this._localBounds.copy() : this._selfBounds.copy().includeBounds( this._childBounds );
        if ( this.hasClipArea() ) {
          // localBounds clipping in the local coordinate frame
          localBounds = localBounds.intersection( this._clipArea.bounds );
        }
        var newBounds = this.transformBoundsFromLocalToParent( localBounds );
        newBounds = this.overrideBounds( newBounds ); // allow expansion of the bounds area
        var changed = !newBounds.equals( oldBounds );
        
        if ( changed ) {
          this._bounds = newBounds;
          
          i = this._parents.length;
          while ( i-- ) {
            this._parents[i].invalidateBounds();
          }
          
          // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
          this.fireEvent( 'bounds', this._bounds );
        }
      }
      
      // if there were side-effects, run the validation again until we are clean
      if ( this._selfBoundsDirty || this._childBoundsDirty || this._boundsDirty ) {
        // TODO: if there are side-effects in listeners, this could overflow the stack. we should report an error instead of locking up
        this.validateBounds();
      }
      
      // double-check that all of our bounds handling has been accurate
      if ( assertSlow ) {
        // new scope for safety
        (function(){
          var epsilon = 0.000001;
          
          var childBounds = Bounds2.NOTHING.copy();
          _.each( that.children, function( child ) { childBounds.includeBounds( child._bounds ); } );
          
          var fullBounds = that.localToParentBounds( that._selfBounds ).union( that.localToParentBounds( childBounds ) );
          
          if ( that.hasClipArea() ) {
            fullBounds = fullBounds.intersection( that.getClipArea().bounds );
          }
          
          assertSlow && assertSlow( that._childBounds.equalsEpsilon( childBounds, epsilon ), 'Child bounds mismatch after validateBounds: ' +
                                                                                                    that._childBounds.toString() + ', expected: ' + childBounds.toString() );
          assertSlow && assertSlow( that._bounds.equalsEpsilon( fullBounds, epsilon ) ||
                                                    that._bounds.equalsEpsilon( that.overrideBounds( fullBounds ), epsilon ),
                                                    'Bounds mismatch after validateBounds: ' + that._bounds.toString() + ', expected: ' + fullBounds.toString() );
        })();
      }
    },
    
    validateMouseBounds: function() {
      var that = this;
      
      assert && assert( !this._selfBoundsDirty && !this._childBoundsDirty && !this._boundsDirty, 'Bounds must be validated before calling validateMouseBounds' );
      
      if ( this._mouseBoundsDirty ) {
        var hasMouseAreas = false;
        
        // --- mouseBounds in local coordinates for now, transformed later
        this._mouseBounds = this._selfBounds.copy(); // start with the self bounds, then add from there
        
        // union of all children's mouse bounds (if they exist)
        var i = this._children.length;
        while ( i-- ) {
          var child = this._children[i];
          child.validateMouseBounds();
          if ( child._mouseBounds ) {
            hasMouseAreas = true;
            that._mouseBounds.includeBounds( child._mouseBounds );
          }
        }
        
        // do this before the transformation to the parent coordinate frame
        if ( this._mouseArea ) {
          hasMouseAreas = true;
          this._mouseBounds.includeBounds( this._mouseArea.isBounds ? this._mouseArea : this._mouseArea.bounds );
        }
        
        if ( this.hasClipArea() ) {
          // exclude areas outside of the clipping area's bounds (for efficiency)
          this._mouseBounds = this._mouseBounds.intersection( this._clipArea.bounds );
        }
        
        if ( hasMouseAreas ) {
          // --- mouseBounds put into parent coordinates here
          // transform it to the parent coordinate frame\
          this.transformBoundsFromLocalToParent( this._mouseBounds );
          
          // and include the normal bounds, so that we don't have to 
          this._mouseBounds.includeBounds( this._bounds );
        } else {
          this._mouseBounds = null; // no mouse areas under this node
        }
        
        this._mouseBoundsDirty = false;
      }
    },
    
    validateTouchBounds: function() {
      var that = this;
      
      assert && assert( !this._selfBoundsDirty && !this._childBoundsDirty && !this._boundsDirty, 'Bounds must be validated before calling validateTouchBounds' );
      
      if ( this._touchBoundsDirty ) {
        var hasTouchAreas = false;
        
        // --- touchBounds in local coordinates for now, transformed later
        this._touchBounds = this._selfBounds.copy(); // start with the self bounds, then add from there
        
        // union of all children's touch bounds (if they exist)
        var i = this._children.length;
        while ( i-- ) {
          var child = this._children[i];
          child.validateTouchBounds();
          if ( child._touchBounds ) {
            hasTouchAreas = true;
            that._touchBounds.includeBounds( child._touchBounds );
          }
        }
        
        // do this before the transformation to the parent coordinate frame
        if ( this._touchArea ) {
          hasTouchAreas = true;
          this._touchBounds.includeBounds( this._touchArea.isBounds ? this._touchArea : this._touchArea.bounds );
        }
        
        if ( this.hasClipArea() ) {
          // exclude areas outside of the clipping area's bounds (for efficiency)
          this._touchBounds = this._touchBounds.intersection( this._clipArea.bounds );
        }
        
        if ( hasTouchAreas ) {
          // --- touchBounds put into parent coordinates here
          // transform it to the parent coordinate frame
          this.transformBoundsFromLocalToParent( this._touchBounds );
          
          // and include the normal bounds, so that we don't have to 
          this._touchBounds.includeBounds( this._bounds );
        } else {
          this._touchBounds = null; // no touch areas under this node
        }
        
        this._touchBoundsDirty = false;
      }
    },
    
    validatePaint: function() {
      if ( this._paintDirty ) {
        assert && assert( this.isPainted(), 'Only painted nodes can have self dirty paint' );
        if ( !this._subtreePaintDirty ) {
          // if the subtree is clean, just notify the self (only will hit one layer, instead of possibly multiple ones)
          this.notifyDirtySelfPaint();
        }
        this._paintDirty = false;
      }
      
      if ( this._subtreePaintDirty ) {
        this.notifyDirtySubtreePaint();
        this._subtreePaintDirty = false;
      }
      
      // clear flags and recurse
      if ( this._childPaintDirty ) {
        this._childPaintDirty = false;
        
        var children = this._children;
        var length = children.length;
        for ( var i = 0; i < length; i++ ) {
          children[i].validatePaint();
        }
      }
    },
    
    // mark the bounds of this node as invalid, so it is recomputed before it is accessed again
    invalidateBounds: function() {
      this._boundsDirty = true;
      this._mouseBoundsDirty = true;
      this._touchBoundsDirty = true;
      
      // and set flags for all ancestors
      var i = this._parents.length;
      while ( i-- ) {
        this._parents[i].invalidateChildBounds();
      }
    },
    
    // recursively tag all ancestors with _childBoundsDirty
    invalidateChildBounds: function() {
      // don't bother updating if we've already been tagged
      if ( !this._childBoundsDirty ) {
        this._childBoundsDirty = true;
        this._mouseBoundsDirty = true;
        this._touchBoundsDirty = true;
        var i = this._parents.length;
        while ( i-- ) {
          this._parents[i].invalidateChildBounds();
        }
      }
    },
    
    // mark the paint of this node as invalid, so its new region will be painted
    invalidatePaint: function() {
      assert && assert( this.isPainted(), 'Can only call invalidatePaint on a painted node' );
      this._paintDirty = true;
      
      // and set flags for all ancestors
      var i = this._parents.length;
      while ( i-- ) {
        this._parents[i].invalidateChildPaint();
      }
    },
    
    invalidateSubtreePaint: function() {
      this._subtreePaintDirty = true;
      
      // and set flags for all ancestors
      var i = this._parents.length;
      while ( i-- ) {
        this._parents[i].invalidateChildPaint();
      }
    },
    
    // recursively tag all ancestors with _childPaintDirty
    invalidateChildPaint: function() {
      // don't bother updating if we've already been tagged
      if ( !this._childPaintDirty ) {
        this._childPaintDirty = true;
        var i = this._parents.length;
        while ( i-- ) {
          this._parents[i].invalidateChildPaint();
        }
      }
    },
    
    // called to notify that self rendering will display different paint, with possibly different bounds
    invalidateSelf: function( newBounds ) {
      assert && assert( newBounds.isEmpty() || newBounds.isFinite() , "Bounds must be empty or finite in invalidateSelf");
      
      // mark the old region to be repainted, regardless of whether the actual bounds change
      this.notifyBeforeSelfChange();
      
      // if these bounds are different than current self bounds
      if ( !this._selfBounds.equals( newBounds ) ) {
        // set repaint flags
        this._selfBoundsDirty = true;
        this.invalidateBounds();
        
        // record the new bounds
        this._selfBounds = newBounds;
      }
      
      this.invalidatePaint();
    },
    
    markOldSelfPaint: function() {
      this.notifyBeforeSelfChange();
    },
    
    // should be called whenever something triggers changes for how this node is layered
    markLayerRefreshNeeded: function() {
      this.markForLayerRefresh();
      this.notifyStitch( true );
    },
    
    // marks the last-rendered bounds of this node and optionally all of its descendants as needing a repaint
    markOldPaint: function( justSelf ) {
      // TODO: rearchitecture
      if ( justSelf ) {
        this.notifyBeforeSelfChange();
      } else {
        this.notifyBeforeSubtreeChange();
      }
    },
    
    isChild: function( potentialChild ) {
      assert && assert( potentialChild && ( potentialChild instanceof Node ), 'isChild needs to be called with a Node' );
      var ourChild = _.contains( this._children, potentialChild );
      var itsParent = _.contains( potentialChild._parents, this );
      assert && assert( ourChild === itsParent );
      return ourChild;
    },
    
    // the bounds for self content in "local" coordinates.
    getSelfBounds: function() {
      return this._selfBounds;
    },
    
    // returns a bounding box that should contain all self content in the local coordinate frame (our normal self bounds aren't guaranteed this for Text, etc.)
    getSafeSelfBounds: function() {
      // override this to provide different behavior
      return this._selfBounds;
    },
    
    getChildBounds: function() {
      this.validateBounds();
      return this._childBounds;
    },
    
    // local coordinate frame bounds
    getLocalBounds: function() {
      if ( this._localBounds ) {
        return this._localBounds;
      }
      var localBounds = this.getSelfBounds().union( this.getChildBounds() );
      if ( this.hasClipArea() ) {
        // localBounds clipping in the local coordinate frame
        localBounds = localBounds.intersection( this._clipArea.bounds );
      }
      return localBounds;
    },
    
    // {Bounds2 | null} to override the localBounds. Once this is called, it will always be used for localBounds until this is called again.
    // To revert to having Scenery compute the localBounds, set this to null.
    setLocalBounds: function( localBounds ) {
      assert && assert( localBounds === null || localBounds instanceof Bounds2, 'localBounds override should be set to either null or a Bounds2' );
      
      if ( localBounds === null ) {
        this._localBounds = null;
        this.invalidateBounds();
      } else {
        var changed = localBounds !== this._localBounds || !this._localBounds;
        
        if ( changed ) {
          this._localBounds = localBounds;
          
          this.invalidateBounds();
        }
      }
      
      return this; // allow chaining
    },
    
    // the bounds for content in render(), in "parent" coordinates
    getBounds: function() {
      this.validateBounds();
      return this._bounds;
    },
    
    // like getBounds() in the "parent" coordinate frame, but includes only visible nodes
    getVisibleBounds: function() {
      // defensive copy, since we use mutable modifications below
      var bounds = this._selfBounds.copy();
      
      var i = this._children.length;
      while ( i-- ) {
        var child = this._children[i];
        if ( child.isVisible() ) {
          bounds.includeBounds( child.getVisibleBounds() );
        }
      }
      
      assert && assert( bounds.isFinite() || bounds.isEmpty(), 'Visible bounds should not be infinite' );
      return this.localToParentBounds( bounds );
    },
    
    trailUnderPointer: function( pointer ) {
      var options = {};
      if ( pointer.isMouse ) { options.isMouse = true; }
      if ( pointer.isTouch ) { options.isTouch = true; }
      if ( pointer.isPen ) { options.isPen = true; }
      
      return this.trailUnderPoint( pointer.point, options );
    },
    
    /*
     * Return a trail to the top node (if any, otherwise null) whose self-rendered area contains the
     * point (in parent coordinates).
     *
     * If options.pruneInvisible is false, invisible nodes will be allowed in the trail.
     * If options.pruneUnpickable is false, unpickable nodes will be allowed in the trail.
     *
     * When calling, don't pass the recursive flag. It signals that the point passed can be mutated
     */
    trailUnderPoint: function( point, options, recursive, hasListener ) {
      assert && assert( point, 'trailUnderPointer requires a point' );
      
      if ( options === undefined ) { options = {}; }
      
      var pruneInvisible = ( options.pruneInvisible === undefined ) ? true : options.pruneInvisible;
      var pruneUnpickable = ( options.pruneUnpickable === undefined ) ? true : options.pruneUnpickable;
      
      hasListener = hasListener || this._inputListeners.length > 0 || this._pickable === true;
      
      if ( pruneInvisible && !this.isVisible() ) {
        return null;
      }
      
      // if pickable: false, skip it
      // if pickable: undefined and our pickable count indicates there are no input listeners / pickable: true in our subtree, skip it
      if ( pruneUnpickable && ( this._pickable === false || ( this._pickable !== true && !hasListener && this._subtreePickableCount === 0 ) ) ) {
        return null;
      }
      
      // update bounds for pruning
      this.validateBounds();
      if ( options.isMouse ) { this.validateMouseBounds(); }
      if ( options.isTouch ) { this.validateTouchBounds(); }
      
      var hasHitAreas = options && ( ( options.isMouse && this._mouseBounds ) || ( options.isTouch && this._touchBounds ) || options.isPen );
      
      // bail quickly if this doesn't hit our computed bounds
      if ( hasHitAreas ? (
            // if we have hit areas, prune based on the respective hit bounds (mouseBounds/touchBounds)
            ( options.isMouse && !this._mouseBounds.containsPoint( point ) ) ||
            ( options.isTouch && !this._touchBounds.containsPoint( point ) )
            // otherwise, prune based on the normal bounds
          ) : !this._bounds.containsPoint( point ) ) {
        return null; // not in our bounds, so this point can't possibly be contained
      }
      
      // temporary result variable, since it's easier to do this way to free the computed point
      var result = null;
      
      // point in the local coordinate frame. computed after the main bounds check, so we can bail out there efficiently
      var localPoint = this._transform.getInverse().multiplyVector2( Vector2.createFromPool( point.x, point.y ) );
      // var localPoint = this.parentToLocalPoint( point );
      
      // if our point is outside of the local-coordinate clipping area, we shouldn't return a hit
      if ( this.hasClipArea() && !this._clipArea.containsPoint( localPoint ) ) {
        return null;
      }
      
      // check children first, since they are rendered later
      if ( this._children.length > 0 && ( hasHitAreas || this._childBounds.containsPoint( localPoint ) ) ) {
        
        // manual iteration here so we can return directly, and so we can iterate backwards (last node is in front)
        for ( var i = this._children.length - 1; i >= 0; i-- ) {
          var child = this._children[i];
          
          var childHit = child.trailUnderPoint( localPoint, options, true, hasListener );
          
          // the child will have the point in its parent's coordinate frame (i.e. this node's frame)
          if ( childHit ) {
            childHit.addAncestor( this, i );
            localPoint.freeToPool();
            return childHit;
          }
        }
      }

      // tests for mouse and touch hit areas before testing containsPointSelf
      if ( hasHitAreas ) {
        if ( options.isMouse && this._mouseArea ) {
          // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
          result = this._mouseArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;
          localPoint.freeToPool();
          return result;
        }
        if ( ( options.isTouch || options.isPen ) && this._touchArea ) {
          // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
          result = this._touchArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;
          localPoint.freeToPool();
          return result;
        }
      }
      
      // didn't hit our children, so check ourself as a last resort
      if ( hasHitAreas || this._selfBounds.containsPoint( localPoint ) ) {
        if ( this.containsPointSelf( localPoint ) ) {
          localPoint.freeToPool();
          return new scenery.Trail( this );
        }
      }
      
      // signal no hit
      localPoint.freeToPool();
      return null;
    },
    
    // checking for whether a point (in parent coordinates) is contained in this sub-tree
    containsPoint: function( point ) {
      return this.trailUnderPoint( point ) !== null;
    },
    
    // override for computation of whether a point is inside the self content
    // point is considered to be in the local coordinate frame
    containsPointSelf: function( point ) {
      // if self bounds are not null default to checking self bounds
      return this._selfBounds.containsPoint( point );
    },
    
    // whether this node's self intersects the specified bounds, in the local coordinate frame
    intersectsBoundsSelf: function( bounds ) {
      // if self bounds are not null, child should override this
      return this._selfBounds.intersectsBounds( bounds );
    },
    
    isPainted: function() {
      return false;
    },
    
    hasParent: function() {
      return this._parents.length !== 0;
    },
    
    hasChildren: function() {
      return this._children.length > 0;
    },
    
    walkDepthFirst: function( callback ) {
      callback( this );
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        this._children[i].walkDepthFirst( callback );
      }
    },
    
    getChildrenWithinBounds: function( bounds ) {
      var result = [];
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        var child = this._children[i];
        if ( !child._bounds.intersection( bounds ).isEmpty() ) {
          result.push( child );
        }
      }
      return result;
    },
    
    // TODO: set this up with a mix-in for a generic notifier?
    addInputListener: function( listener ) {
      // don't allow listeners to be added multiple times
      if ( _.indexOf( this._inputListeners, listener ) === -1 ) {
        this._inputListeners.push( listener );
        this.changePickableCount( 1 );
      }
      return this;
    },
    
    removeInputListener: function( listener ) {
      // ensure the listener is in our list
      assert && assert( _.indexOf( this._inputListeners, listener ) !== -1 );
      
      this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );
      this.changePickableCount( -1 );
      return this;
    },
    
    getInputListeners: function() {
      return this._inputListeners.slice( 0 ); // defensive copy
    },
    
    /*
     * Dispatches an event across all possible Trails ending in this node.
     *
     * For example, if the scene has two children A and B, and both of those nodes have X as a child,
     * dispatching an event on X will fire the event with the following trails:
     * on X     with trail [ X ]
     * on A     with trail [ A, X ]
     * on scene with trail [ scene, A, X ]
     * on B     with trail [ B, X ]
     * on scene with trail [ scene, B, X ]
     *
     * This allows you to add a listener on any node to get notifications for all of the trails that the
     * event is relevant for (e.g. marks dirty paint region for both places X was on the scene).
     */
    dispatchEvent: function( type, args ) {
      sceneryEventLog && sceneryEventLog( this.constructor.name + '.dispatchEvent ' + type );
      var trail = new scenery.Trail();
      trail.setMutable(); // don't allow this trail to be set as immutable for storage
      args.trail = trail; // this reference shouldn't be changed be listeners (or errors will occur)
      
      // store a branching flag, since if we don't branch at all, we don't have to walk our trail back down.
      var branches = false;
      
      function recursiveEventDispatch( node ) {
        trail.addAncestor( node );
        
        node.fireEvent( type, args );
        
        var parents = node._parents;
        var length = parents.length;
        
        // make sure to set the branch flag here before iterating (don't move it)
        branches = branches || length > 1;
        
        for ( var i = 0; i < length; i++ ) {
          recursiveEventDispatch( parents[i] );
        }
        
        // if there were no branches, we will not fire another listener once we have reached here
        if ( branches ) {
          trail.removeAncestor();
        }
      }
      
      recursiveEventDispatch( this );
    },
    
    // TODO: consider renaming to translateBy to match scaleBy
    translate: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        // translate( x, y, prependInstead )
        if ( !x && !y ) { return; } // bail out if both are zero
        if ( prependInstead ) {
          this.prependTranslation( x, y );
        } else {
          this.appendMatrix( Matrix3.translation( x, y ) );
        }
      } else {
        // translate( vector, prependInstead )
        var vector = x;
        if ( !vector.x && !vector.y ) { return; } // bail out if both are zero
        this.translate( vector.x, vector.y, y ); // forward to full version
      }
    },
    
    // scale( s ) is also supported, which will scale both dimensions by the same amount. renamed from 'scale' to satisfy the setter/getter
    scale: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        if ( y === undefined ) {
          // scale( scale )
          if ( x === 1 ) { return; } // bail out if we are scaling by 1 (identity)
          this.appendMatrix( Matrix3.scaling( x, x ) );
        } else {
          // scale( x, y, prependInstead )
          if ( x === 1 && y === 1 ) { return; } // bail out if we are scaling by 1 (identity)
          if ( prependInstead ) {
            this.prependMatrix( Matrix3.scaling( x, y ) );
          } else {
            this.appendMatrix( Matrix3.scaling( x, y ) );
          }
        }
      } else {
        // scale( vector, prependInstead ) or scale( { x: x, y: y }, prependInstead )
        var vector = x;
        this.scale( vector.x, vector.y, y ); // forward to full version
      }
    },
    
    // TODO: consider naming to rotateBy to match scaleBy (due to scale property / method name conflict)
    rotate: function( angle, prependInstead ) {
      if ( angle % ( 2 * Math.PI ) === 0 ) { return; } // bail out if our angle is effectively 0
      if ( prependInstead ) {
        this.prependMatrix( Matrix3.rotation2( angle ) );
      } else {
        this.appendMatrix( Matrix3.rotation2( angle ) );
      }
    },
    
    // point should be in the parent coordinate frame
    // TODO: determine whether this should use the appendMatrix method
    rotateAround: function( point, angle ) {
      var matrix = Matrix3.translation( -point.x, -point.y );
      matrix = Matrix3.rotation2( angle ).timesMatrix( matrix );
      matrix = Matrix3.translation( point.x, point.y ).timesMatrix( matrix );
      this.prependMatrix( matrix );
    },
    
    getX: function() {
      return this._transform.getMatrix().m02();
    },
    
    setX: function( x ) {
      assert && assert( typeof x === 'number' );
      
      this.translate( x - this.getX(), 0, true );
      return this;
    },
    
    getY: function() {
      return this._transform.getMatrix().m12();
    },
    
    setY: function( y ) {
      assert && assert( typeof y === 'number' );
      
      this.translate( 0, y - this.getY(), true );
      return this;
    },
    
    // returns a vector with an entry for each axis, e.g. (5,2) for an Affine-style matrix with rows ((5,0,0),(0,2,0),(0,0,1))
    getScaleVector: function() {
      return this._transform.getMatrix().getScaleVector();
    },
    
    // supports setScaleMagnitude( 5 ) for both dimensions, setScaleMagnitude( 5, 3 ) for each dimension separately, or setScaleMagnitude( new Vector2( x, y ) )
    setScaleMagnitude: function( a, b ) {
      var currentScale = this.getScaleVector();
      
      if ( typeof a === 'number' ) {
        if ( b === undefined ) {
          // to map setScaleMagnitude( scale ) => setScaleMagnitude( scale, scale )
          b = a;
        }
        // setScaleMagnitude( x, y )
        this.appendMatrix( Matrix3.scaling( a / currentScale.x, b / currentScale.y ) );
      } else {
        // setScaleMagnitude( vector ), where we set the x-scale to vector.x and y-scale to vector.y
        this.appendMatrix( Matrix3.scaling( a.x / currentScale.x, a.y / currentScale.y ) );
      }
      return this;
    },
    
    getRotation: function() {
      return this._transform.getMatrix().getRotation();
    },
    
    setRotation: function( rotation ) {
      assert && assert( typeof rotation === 'number' );
      
      this.appendMatrix( Matrix3.rotation2( rotation - this.getRotation() ) );
      return this;
    },
    
    // supports setTranslation( x, y ) or setTranslation( new Vector2( x, y ) ) .. or technically setTranslation( { x: x, y: y } )
    setTranslation: function( a, b ) {
      var m = this._transform.getMatrix();
      var tx = m.m02();
      var ty = m.m12();

      var dx, dy;
      
      if ( typeof a === 'number' ) {
        dx = a - tx;
        dy = b - ty;
      } else {
        dx = a.x - tx;
        dy = a.y - ty;
      }
      
      this.translate( dx, dy, true );
      
      return this;
    },
    
    getTranslation: function() {
      var matrix = this._transform.getMatrix();
      return new Vector2( matrix.m02(), matrix.m12() );
    },
    
    // append a transformation matrix to our local transform
    appendMatrix: function( matrix ) {
      this._transform.append( matrix );
    },
    
    // prepend a transformation matrix to our local transform
    prependMatrix: function( matrix ) {
      this._transform.prepend( matrix );
    },

    // prepend an x,y translation to our local transform without allocating a matrix for it, see #119
    prependTranslation: function( x,y ) {
      this._transform.prependTranslation( x, y );
    },
    
    setMatrix: function( matrix ) {
      this._transform.setMatrix( matrix );
    },
    
    getMatrix: function() {
      return this._transform.getMatrix();
    },
    
    // change the actual transform reference (not just the actual transform)
    setTransform: function( transform ) {
      assert && assert( transform.isFinite(), 'Transform should not have infinite/NaN values' );
      
      if ( this._transform !== transform ) {
        // since our referenced transform doesn't change, we need to trigger the before/after ourselves
        this.beforeTransformChange();
        
        // swap the transform and move the listener to the new one
        this._transform.removeTransformListener( this._transformListener ); // don't leak memory!
        this._transform = transform;
        this._transform.prependTransformListener( this._transformListener );
        
        this.afterTransformChange();
      }
    },
    
    getTransform: function() {
      // for now, return an actual copy. we can consider listening to changes in the future
      return this._transform;
    },
    
    resetTransform: function() {
      this.setMatrix( Matrix3.IDENTITY );
    },
    
    // called before our transform is changed
    beforeTransformChange: function() {
      // mark our old bounds as dirty, so that any dirty region repainting will include not just our new position, but also our old position
      this.notifyBeforeSubtreeChange();
    },
    
    // called after our transform is changed
    afterTransformChange: function() {
      assert && assert( this.transform.matrix.isFinite() );
      this.notifyTransformChange();
      
      this.invalidateBounds();
      this.invalidateSubtreePaint();
    },
    
    // the left bound of this node, in the parent coordinate frame
    getLeft: function() {
      return this.getBounds().minX;
    },
    
    // shifts this node horizontally so that its left bound (in the parent coordinate frame) is 'left'
    setLeft: function( left ) {
      assert && assert( typeof left === 'number' );
      
      this.translate( left - this.getLeft(), 0, true );
      return this; // allow chaining
    },
    
    // the right bound of this node, in the parent coordinate frame
    getRight: function() {
      return this.getBounds().maxX;
    },
    
    // shifts this node horizontally so that its right bound (in the parent coordinate frame) is 'right'
    setRight: function( right ) {
      assert && assert( typeof right === 'number' );
      
      this.translate( right - this.getRight(), 0, true );
      return this; // allow chaining
    },
    
    getCenter: function() {
      return this.getBounds().getCenter();
    },
    
    setCenter: function( center ) {
      assert && assert( center instanceof Vector2 );
      
      this.translate( center.minus( this.getCenter() ), true );
      return this;
    },
    
    getCenterX: function() {
      return this.getBounds().getCenterX();
    },
    
    setCenterX: function( x ) {
      assert && assert( typeof x === 'number' );
      
      this.translate( x - this.getCenterX(), 0, true );
      return this; // allow chaining
    },
    
    getCenterY: function() {
      return this.getBounds().getCenterY();
    },
    
    setCenterY: function( y ) {
      assert && assert( typeof y === 'number' );
      
      this.translate( 0, y - this.getCenterY(), true );
      return this; // allow chaining
    },
    
    // the top bound of this node, in the parent coordinate frame
    getTop: function() {
      return this.getBounds().minY;
    },
    
    // shifts this node vertically so that its top bound (in the parent coordinate frame) is 'top'
    setTop: function( top ) {
      assert && assert( typeof top === 'number' );
      
      this.translate( 0, top - this.getTop(), true );
      return this; // allow chaining
    },
    
    // the bottom bound of this node, in the parent coordinate frame
    getBottom: function() {
      return this.getBounds().maxY;
    },
    
    // shifts this node vertically so that its bottom bound (in the parent coordinate frame) is 'bottom'
    setBottom: function( bottom ) {
      assert && assert( typeof bottom === 'number' );
      
      this.translate( 0, bottom - this.getBottom(), true );
      return this; // allow chaining
    },
    
    getLeftTop: function() {
      return this.getBounds().getLeftTop();
    },
    
    setLeftTop: function( leftTop ) {
      assert && assert( leftTop instanceof Vector2 );
      
      this.translate( leftTop.minus( this.getLeftTop() ), true );
    },
    
    getCenterTop: function() {
      return this.getBounds().getCenterTop();
    },
    
    setCenterTop: function( centerTop ) {
      assert && assert( centerTop instanceof Vector2 );
      
      this.translate( centerTop.minus( this.getCenterTop() ), true );
    },
    
    getRightTop: function() {
      return this.getBounds().getRightTop();
    },
    
    setRightTop: function( rightTop ) {
      assert && assert( rightTop instanceof Vector2 );
      
      this.translate( rightTop.minus( this.getRightTop() ), true );
    },
    
    getLeftCenter: function() {
      return this.getBounds().getLeftCenter();
    },
    
    setLeftCenter: function( leftCenter ) {
      assert && assert( leftCenter instanceof Vector2 );
      
      this.translate( leftCenter.minus( this.getLeftCenter() ), true );
    },
    
    getRightCenter: function() {
      return this.getBounds().getRightCenter();
    },
    
    setRightCenter: function( rightCenter ) {
      assert && assert( rightCenter instanceof Vector2 );
      
      this.translate( rightCenter.minus( this.getRightCenter() ), true );
    },
    
    getLeftBottom: function() {
      return this.getBounds().getLeftBottom();
    },
    
    setLeftBottom: function( leftBottom ) {
      assert && assert( leftBottom instanceof Vector2 );
      
      this.translate( leftBottom.minus( this.getLeftBottom() ), true );
    },
    
    getCenterBottom: function() {
      return this.getBounds().getCenterBottom();
    },
    
    setCenterBottom: function( centerBottom ) {
      assert && assert( centerBottom instanceof Vector2 );
      
      this.translate( centerBottom.minus( this.getCenterBottom() ), true );
    },
    
    getRightBottom: function() {
      return this.getBounds().getRightBottom();
    },
    
    setRightBottom: function( rightBottom ) {
      assert && assert( rightBottom instanceof Vector2 );
      
      this.translate( rightBottom.minus( this.getRightBottom() ), true );
    },
    
    getWidth: function() {
      return this.getBounds().getWidth();
    },
    
    getHeight: function() {
      return this.getBounds().getHeight();
    },
    
    getId: function() {
      return this._id;
    },
    
    isVisible: function() {
      return this._visible;
    },
    
    setVisible: function( visible ) {
      assert && assert( typeof visible === 'boolean' );
      
      if ( visible !== this._visible ) {
        if ( this._visible ) {
          this.notifyBeforeSubtreeChange();
        }
        
        this._visible = visible;
        
        this.notifyVisibilityChange();
      }
      return this;
    },
    
    getOpacity: function() {
      return this._opacity;
    },
    
    setOpacity: function( opacity ) {
      assert && assert( typeof opacity === 'number' );
      
      var clampedOpacity = clamp( opacity, 0, 1 );
      if ( clampedOpacity !== this._opacity ) {
        this.notifyBeforeSubtreeChange();
        
        this._opacity = clampedOpacity;
        
        this.notifyOpacityChange();
      }
    },
    
    isPickable: function() {
      return this._pickable;
    },
    
    setPickable: function( pickable ) {
      assert && assert( pickable === null || typeof pickable === 'boolean' );
      
      if ( this._pickable !== pickable ) {
        var n = this._pickable === true ? -1 : 0;
        
        // no paint or invalidation changes for now, since this is only handled for the mouse
        this._pickable = pickable;
        n += this._pickable === true ? 1 : 0;
        
        if ( n ) {
          this.changePickableCount( n );
        }
        
        // TODO: invalidate the cursor somehow? #150
      }
    },
    
    setCursor: function( cursor ) {
      assert && assert( typeof cursor === 'string' || cursor === null );
      
      // TODO: consider a mapping of types to set reasonable defaults
      /*
      auto default none inherit help pointer progress wait crosshair text vertical-text alias copy move no-drop not-allowed
      e-resize n-resize w-resize s-resize nw-resize ne-resize se-resize sw-resize ew-resize ns-resize nesw-resize nwse-resize
      context-menu cell col-resize row-resize all-scroll url( ... ) --> does it support data URLs?
       */
      
      // allow the 'auto' cursor type to let the ancestors or scene pick the cursor type
      this._cursor = cursor === "auto" ? null : cursor;
    },
    
    getCursor: function() {
      return this._cursor;
    },
    
    setMouseArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'mouseArea needs to be a kite.Shape, dot.Bounds2, or null' );
      
      if ( this._mouseArea !== area ) {
        this._mouseArea = area; // TODO: could change what is under the mouse, invalidate!
        
        this.invalidateBounds();
      }
    },
    
    getMouseArea: function() {
      return this._mouseArea;
    },
    
    setTouchArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'touchArea needs to be a kite.Shape, dot.Bounds2, or null' );
      
      if ( this._touchArea !== area ) {
        this._touchArea = area; // TODO: could change what is under the touch, invalidate!
        
        this.invalidateBounds();
      }
    },
    
    getTouchArea: function() {
      return this._touchArea;
    },
    
    setClipArea: function( shape ) {
      assert && assert( shape === null || shape instanceof Shape, 'clipArea needs to be a kite.Shape, or null' );
      
      if ( this._clipArea !== shape ) {
        this.notifyBeforeSubtreeChange();
        
        this._clipArea = shape;
        
        this.notifyClipChange();
        
        this.invalidateBounds();
      }
    },
    
    getClipArea: function() {
      return this._clipArea;
    },
    
    hasClipArea: function() {
      return this._clipArea !== null;
    },
    
    updateLayerType: function() {
      if ( this._renderer && this._rendererOptions ) {
        // TODO: factor this check out! Make RendererOptions its own class?
        // TODO: FIXME: support undoing this!
        // ensure that if we are passing a CSS transform, we pass this node as the baseNode
        if ( this._rendererOptions.cssTransform || this._rendererOptions.cssTranslation || this._rendererOptions.cssRotation || this._rendererOptions.cssScale ) {
          this._rendererOptions.baseNode = this;
        } else if ( this._rendererOptions.hasOwnProperty( 'baseNode' ) ) {
          delete this._rendererOptions.baseNode; // don't override, let the scene pass in the scene
        }
        // if we set renderer and rendererOptions, only then do we want to trigger a specific layer type
        this._rendererLayerType = this._renderer.createLayerType( this._rendererOptions );
      } else {
        this._rendererLayerType = null; // nothing signaled, since we want to support multiple layer types (including if we specify a renderer)
      }
    },
    
    getRendererLayerType: function() {
      return this._rendererLayerType;
    },
    
    hasRendererLayerType: function() {
      return !!this._rendererLayerType;
    },
    
    supportsCanvas: function() {
      return ( this._rendererBitmask & scenery.bitmaskSupportsCanvas ) !== 0;
    },
    
    supportsSVG: function() {
      return ( this._rendererBitmask & scenery.bitmaskSupportsSVG ) !== 0;
    },
    
    supportsDOM: function() {
      return ( this._rendererBitmask & scenery.bitmaskSupportsDOM ) !== 0;
    },
    
    supportsWebGL: function() {
      return ( this._rendererBitmask & scenery.bitmaskSupportsWebGL ) !== 0;
    },
    
    supportsRenderer: function( renderer ) {
      return ( this._rendererBitmask & renderer.bitmask ) !== 0;
    },
    
    // return a supported renderer (fallback case, not called often)
    pickARenderer: function() {
      if ( this.supportsCanvas() ) {
        return scenery.Renderer.Canvas;
      } else if ( this.supportsSVG() ) {
        return scenery.Renderer.SVG;
      } else if ( this.supportsDOM() ) {
        return scenery.Renderer.DOM;
      }
      // oi!
    },
    
    setRendererBitmask: function( bitmask ) {
      if ( bitmask !== this._rendererBitmask ) {
        this._rendererBitmask = bitmask;
        this.markLayerRefreshNeeded();
      }
    },
    
    // meant to be overridden
    invalidateSupportedRenderers: function() {
      
    },
    
    setRenderer: function( renderer ) {
      var newRenderer;
      if ( typeof renderer === 'string' ) {
        assert && assert( scenery.Renderer[renderer], 'unknown renderer in setRenderer: ' + renderer );
        newRenderer = scenery.Renderer[renderer];
      } else if ( renderer instanceof scenery.Renderer ) {
        newRenderer = renderer;
      } else if ( !renderer ) {
        newRenderer = null;
      } else {
        throw new Error( 'unrecognized type of renderer: ' + renderer );
      }
      if ( newRenderer !== this._renderer ) {
        assert && assert( !this.isPainted() || !newRenderer || this.supportsRenderer( newRenderer ), 'renderer ' + newRenderer + ' not supported by ' + this.constructor.name );
        this._renderer = newRenderer;
        
        this.updateLayerType();
        this.markLayerRefreshNeeded();
      }
    },
    
    getRenderer: function() {
      return this._renderer;
    },
    
    hasRenderer: function() {
      return !!this._renderer;
    },
    
    setRendererOptions: function( options ) {
      // TODO: consider checking options based on the specified 'renderer'?
      this._rendererOptions = options;
      
      this.updateLayerType();
      this.markLayerRefreshNeeded();
    },
    
    getRendererOptions: function() {
      return this._rendererOptions;
    },
    
    hasRendererOptions: function() {
      return !!this._rendererOptions;
    },
    
    setLayerSplit: function( split ) {
      assert && assert( typeof split === 'boolean' );
      
      if ( split !== this._layerSplit ) {
        this._layerSplit = split;
        this.markLayerRefreshNeeded();
      }
    },
    
    isLayerSplit: function() {
      return this._layerSplit;
    },
    
    // returns a unique trail (if it exists) where each node in the ancestor chain has 0 or 1 parents
    getUniqueTrail: function() {
      var trail = new scenery.Trail();
      var node = this;
      
      while ( node ) {
        trail.addAncestor( node );
        assert && assert( node._parents.length <= 1 );
        node = node._parents[0]; // should be undefined if there aren't any parents
      }
      
      return trail;
    },
    
    // all nodes in the connected component, returned in an arbitrary order
    getConnectedNodes: function() {
      var result = [];
      var fresh = this._children.concat( this._parents ).concat( this );
      while ( fresh.length ) {
        var node = fresh.pop();
        if ( !_.contains( result, node ) ) {
          result.push( node );
          fresh = fresh.concat( node._children, node._parents );
        }
      }
      return result;
    },
    
    getTopologicallySortedNodes: function() {
      // see http://en.wikipedia.org/wiki/Topological_sorting
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes(), function( node ) {
        edges[node.id] = {};
        _.each( node.children, function( m ) {
          edges[node.id][m.id] = true;
        } );
        if ( !node.parents.length ) {
          s.push( node );
        }
      } );
      function handleChild( m ) {
        delete edges[n.id][m.id];
        if ( _.every( edges, function( children ) { return !children[m.id]; } ) ) {
          // there are no more edges to m
          s.push( m );
        }
      }
      
      while ( s.length ) {
        n = s.pop();
        l.push( n );
        
        _.each( n.children, handleChild );
      }
      
      // ensure that there are no edges left, since then it would contain a circular reference
      assert && assert( _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } ), 'circular reference check' );
      
      return l;
    },
    
    // verify that this.addChild( child ) it wouldn't cause circular references
    canAddChild: function( child ) {
      if ( this === child || _.contains( this.children, child ) ) {
        return false;
      }
      
      // see http://en.wikipedia.org/wiki/Topological_sorting
      // TODO: remove duplication with above handling?
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes().concat( child.getConnectedNodes() ), function( node ) {
        edges[node.id] = {};
        _.each( node.children, function( m ) {
          edges[node.id][m.id] = true;
        } );
        if ( !node.parents.length && node !== child ) {
          s.push( node );
        }
      } );
      edges[this.id][child.id] = true; // add in our 'new' edge
      function handleChild( m ) {
        delete edges[n.id][m.id];
        if ( _.every( edges, function( children ) { return !children[m.id]; } ) ) {
          // there are no more edges to m
          s.push( m );
        }
      }
      
      while ( s.length ) {
        n = s.pop();
        l.push( n );
        
        _.each( n.children, handleChild );
        
        // handle our new edge
        if ( n === this ) {
          handleChild( child );
        }
      }
      
      // ensure that there are no edges left, since then it would contain a circular reference
      return _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } );
    },
    
    debugText: function() {
      var startPointer = new scenery.TrailPointer( new scenery.Trail( this ), true );
      var endPointer = new scenery.TrailPointer( new scenery.Trail( this ), false );
      
      var depth = 0;
      
      startPointer.depthFirstUntil( endPointer, function( pointer ) {
        if ( pointer.isBefore ) {
          // hackish way of multiplying a string
          var padding = new Array( depth * 2 ).join( ' ' );
          console.log( padding + pointer.trail.lastNode().getId() + ' ' + pointer.trail.toString() );
        }
        depth += pointer.isBefore ? 1 : -1;
      }, false );
    },
    
    /*
     * Renders this node to a canvas. If toCanvas( callback ) is used, the canvas will contain the node's
     * entire bounds.
     *
     * callback( canvas, x, y ) is called, where x and y offsets are computed if not specified.
     */
    toCanvas: function( callback, x, y, width, height ) {
      var self = this;
      
      var padding = 2; // padding used if x and y are not set
      
      // for now, we add an unpleasant hack around Text and safe bounds in general. We don't want to add another Bounds2 object per Node for now.
      var bounds = this.getBounds().union( this.localToParentBounds( this.getSafeSelfBounds() ) );
      
      x = x !== undefined ? x : Math.ceil( padding - bounds.minX );
      y = y !== undefined ? y : Math.ceil( padding - bounds.minY );
      width = width !== undefined ? width : Math.ceil( bounds.getWidth() + 2 * padding );
      height = height !== undefined ? height : Math.ceil( bounds.getHeight() + 2 * padding );
      
      var canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext( '2d' );
      
      var $div = $( document.createElement( 'div' ) );
      $div.width( width ).height( height );
      var scene = new scenery.Scene( $div );
      
      scene.addChild( self );
      scene.x = x;
      scene.y = y;
      scene.updateScene();
      
      scene.renderToCanvas( canvas, context, function() {
        callback( canvas, x, y );
        
        // let us be garbage collected
        scene.removeChild( self );
      } );
    },
    
    // gives a data URI, with the same parameter handling as Node.toCanvas()
    toDataURL: function( callback, x, y, width, height ) {
      this.toCanvas( function( canvas, x, y ) {
        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
        callback( canvas.toDataURL(), x, y );
      }, x, y, width, height );
    },
    
    // gives an HTMLImageElement with the same parameter handling as Node.toCanvas(). guaranteed to be asynchronous
    toImage: function( callback, x, y, width, height ) {
      this.toDataURL( function( url, x, y ) {
        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
        var img = document.createElement( 'img' );
        img.onload = function() {
          callback( img, x, y );
          try {
            delete img.onload;
          } catch ( e ) {} // fails on Safari 5.1
        };
        img.src = url;
      }, x, y, width, height );
    },
    
    // will call callback( node )
    toImageNodeAsynchronous: function( callback, x, y, width, height ) {
      this.toImage( function( image, x, y ) {
        callback( new scenery.Node( { children: [
          new scenery.Image( image, { x: -x, y: -y } )
        ] } ) );
      }, x, y, width, height );
    },
    
    // fully synchronous, but returns a node that can only be rendered in Canvas
    toCanvasNodeSynchronous: function( x, y, width, height ) {
      var result;
      this.toCanvas( function( canvas, x, y ) {
        result = new scenery.Node( { children: [
          new scenery.Image( canvas, { x: -x, y: -y } )
        ] } );
      }, x, y, width, height );
      assert && assert( result, 'toCanvasNodeSynchronous requires that the node can be rendered only using Canvas' );
      return result;
    },
    
    // synchronous, but Image will not have the correct bounds immediately (that will be asynchronous)
    toDataURLNodeSynchronous: function( x, y, width, height ) {
      var result;
      this.toDataURL( function( dataURL, x, y ) {
        result = new scenery.Node( { children: [
          new scenery.Image( dataURL, { x: -x, y: -y } )
        ] } );
      }, x, y, width, height );
      assert && assert( result, 'toDataURLNodeSynchronous requires that the node can be rendered only using Canvas' );
      return result;
    },
    
    /*---------------------------------------------------------------------------*
    * Instance handling
    *----------------------------------------------------------------------------*/
    
    getInstances: function() {
      return this._instances;
    },
    
    addInstance: function( instance ) {
      assert && assert( instance.getNode() === this, 'Must be an instance of this Node' );
      assert && assert( !_.find( this._instances, function( other ) { return instance.equals( other ); } ), 'Cannot add duplicates of an instance to a Node' );
      this._instances.push( instance );
      if ( this._instances.length === 1 ) {
        this.firstInstanceAdded();
      }
    },
    
    firstInstanceAdded: function() {
      // no-op, meant to be overridden in the prototype chain
    },
    
    // returns undefined if there is no instance.
    getInstanceFromTrail: function( trail ) {
      var result;
      var len = this._instances.length;
      if ( len === 1 ) {
        // don't bother with checking the trail, but assertion should assure that it's what we're looking for
        result = this._instances[0];
      } else {
        var i = len;
        while ( i-- ) {
          if ( this._instances[i].trail.equals( trail ) ) {
            result = this._instances[i];
            break;
          }
        }
        // leave it as undefined if we don't find one
      }
      assert && assert( result, 'Could not find an instance for the trail ' + trail.toString() );
      assert && assert( result.trail.equals( trail ), 'Instance has an incorrect Trail' );
      return result;
    },
    
    removeInstance: function( instance ) {
      var index = _.indexOf( this._instances, instance ); // actual instance equality (NOT capitalized, normal meaning)
      assert && assert( index !== -1, 'Cannot remove an Instance from a Node if it was not there' );
      this._instances.splice( index, 1 );
      if ( this._instances.length === 0 ) {
        this.lastInstanceRemoved();
      }
    },
    
    lastInstanceRemoved: function() {
      // no-op, meant to be overridden in the prototype chain
    },
    
    notifyVisibilityChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyVisibilityChange();
      }
    },
    
    notifyOpacityChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyOpacityChange();
      }
    },
    
    notifyClipChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyClipChange();
      }
    },
    
    notifyBeforeSelfChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyBeforeSelfChange();
      }
    },
    
    notifyBeforeSubtreeChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyBeforeSubtreeChange();
      }
    },
    
    notifyDirtySelfPaint: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyDirtySelfPaint();
      }
    },
    
    notifyDirtySubtreePaint: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyDirtySubtreePaint();
      }
    },
    
    notifyTransformChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyTransformChange();
      }
    },
    
    notifyBoundsAccuracyChange: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyBoundsAccuracyChange();
      }
    },
    
    notifyStitch: function( match ) {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].notifyStitch( match );
      }
    },
    
    markForLayerRefresh: function() {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].markForLayerRefresh();
      }
    },
    
    markForInsertion: function( child, index ) {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].markForInsertion( child, index );
      }
    },
    
    markForRemoval: function( child, index ) {
      var i = this._instances.length;
      while ( i-- ) {
        this._instances[i].markForRemoval( child, index );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * Coordinate transform methods
    *----------------------------------------------------------------------------*/
    
    // apply this node's transform to the point
    localToParentPoint: function( point ) {
      return this._transform.transformPosition2( point );
    },
    
    // apply this node's transform to the bounds
    localToParentBounds: function( bounds ) {
      return this._transform.transformBounds2( bounds );
    },
    
    // apply the inverse of this node's transform to the point
    parentToLocalPoint: function( point ) {
      return this._transform.inversePosition2( point );
    },
    
    // apply the inverse of this node's transform to the bounds
    parentToLocalBounds: function( bounds ) {
      return this._transform.inverseBounds2( bounds );
    },
    
    // mutable optimized form of localToParentBounds
    transformBoundsFromLocalToParent: function( bounds ) {
      return bounds.transform( this._transform.getMatrix() );
    },
    
    // mutable optimized form of parentToLocalBounds
    transformBoundsFromParentToLocal: function( bounds ) {
      return bounds.transform( this._transform.getInverse() );
    },
    
    // returns the matrix (fresh copy) that transforms points from the local coordinate frame into the global coordinate frame
    getLocalToGlobalMatrix: function() {
      var node = this;
      
      // we need to apply the transformations in the reverse order, so we temporarily store them
      var matrices = [];
      
      // concatenation like this has been faster than getting a unique trail, getting its transform, and applying it
      while ( node ) {
        matrices.push( node._transform.getMatrix() );
        assert && assert( node._parents[1] === undefined, 'getLocalToGlobalMatrix unable to work for DAG' );
        node = node._parents[0];
      }

      var matrix = Matrix3.identity(); // will be modified in place
      
      // iterate from the back forwards (from the root node to here)
      for ( var i = matrices.length - 1; i >=0; i-- ) {
        matrix.multiplyMatrix( matrices[i] );
      }
      
      // NOTE: always return a fresh copy, getGlobalToLocalMatrix depends on it to minimize instance usage!
      return matrix;
    },
    
    // equivalent to getUniqueTrail().getTransform(), but faster.
    getUniqueTransform: function() {
      return new Transform3( this.getLocalToGlobalMatrix() );
    },
    
    // returns the matrix (fresh copy) that transforms points in the global coordinate frame into the local coordinate frame
    getGlobalToLocalMatrix: function() {
      return this.getLocalToGlobalMatrix().invert();
    },
    
    // apply this node's transform (and then all of its parents' transforms) to the point
    localToGlobalPoint: function( point ) {
      var node = this;
      var resultPoint = point.copy();
      while ( node ) {
        // in-place multiplication
        node._transform.getMatrix().multiplyVector2( resultPoint );
        assert && assert( node._parents[1] === undefined, 'localToGlobalPoint unable to work for DAG' );
        node = node._parents[0];
      }
      return resultPoint;
    },
    
    globalToLocalPoint: function( point ) {
      var node = this;
      // TODO: performance: test whether it is faster to get a total transform and then invert (won't compute individual inverses)
      
      // we need to apply the transformations in the reverse order, so we temporarily store them
      var transforms = [];
      while ( node ) {
        transforms.push( node._transform );
        assert && assert( node._parents[1] === undefined, 'globalToLocalPoint unable to work for DAG' );
        node = node._parents[0];
      }
      
      // iterate from the back forwards (from the root node to here)
      var resultPoint = point.copy();
      for ( var i = transforms.length - 1; i >=0; i-- ) {
        // in-place multiplication
        transforms[i].getInverse().multiplyVector2( resultPoint );
      }
      return resultPoint;
    },
    
    // apply this node's transform (and then all of its parents' transforms) to the bounds
    localToGlobalBounds: function( bounds ) {
      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
      // it also seems to be a bit faster this way
      return bounds.transformed( this.getLocalToGlobalMatrix() );
    },
    
    globalToLocalBounds: function( bounds ) {
      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
      return bounds.transformed( this.getGlobalToLocalMatrix() );
    },
    
    // like localToGlobalPoint, but without applying this node's transform
    parentToGlobalPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalPoint unable to work for DAG' );
      return this.parents.length ? this.parents[0].localToGlobalPoint( point ) : point;
    },
    
    // like localToGlobalBounds, but without applying this node's transform
    parentToGlobalBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalBounds unable to work for DAG' );
      return this.parents.length ? this.parents[0].localToGlobalBounds( bounds ) : bounds;
    },
    
    globalToParentPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'globalToParentPoint unable to work for DAG' );
      return this.parents.length ? this.parents[0].globalToLocalPoint( point ) : point;
    },
    
    globalToParentBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'globalToParentBounds unable to work for DAG' );
      return this.parents.length ? this.parents[0].globalToLocalBounds( bounds ) : bounds;
    },
    
    // get the Bounds2 of this node in the global coordinate frame.  Does not work for DAG.
    getGlobalBounds: function() {
      assert && assert( this.parents.length <= 1, 'globalBounds unable to work for DAG' );
      return this.parentToGlobalBounds( this.getBounds() );
    },
    
    // get the Bounds2 of any other node by converting to the global coordinate frame.  Does not work for DAG.
    boundsOf: function( node ) {
      return this.globalToLocalBounds( node.getGlobalBounds() );
    },
    
    // get the Bounds2 of this node in the coordinate frame of the parameter node. Does not work for DAG cases.
    boundsTo: function( node ) {
      return node.globalToLocalBounds( this.getGlobalBounds() );
    },
    
    /*---------------------------------------------------------------------------*
    * ES5 get/set
    *----------------------------------------------------------------------------*/
    
    set layerSplit( value ) { this.setLayerSplit( value ); },
    get layerSplit() { return this.isLayerSplit(); },
    
    set renderer( value ) { this.setRenderer( value ); },
    get renderer() { return this.getRenderer(); },
    
    set rendererOptions( value ) { this.setRendererOptions( value ); },
    get rendererOptions() { return this.getRendererOptions(); },
    
    set cursor( value ) { this.setCursor( value ); },
    get cursor() { return this.getCursor(); },
    
    set mouseArea( value ) { this.setMouseArea( value ); },
    get mouseArea() { return this.getMouseArea(); },
    
    set touchArea( value ) { this.setTouchArea( value ); },
    get touchArea() { return this.getTouchArea(); },
    
    set clipArea( value ) { this.setClipArea( value ); },
    get clipArea() { return this.getClipArea(); },
    
    set visible( value ) { this.setVisible( value ); },
    get visible() { return this.isVisible(); },
    
    set opacity( value ) { this.setOpacity( value ); },
    get opacity() { return this.getOpacity(); },
    
    set pickable( value ) { this.setPickable( value ); },
    get pickable() { return this.isPickable(); },
    
    set transform( value ) { this.setTransform( value ); },
    get transform() { return this.getTransform(); },
    
    set matrix( value ) { this.setMatrix( value ); },
    get matrix() { return this.getMatrix(); },
    
    set translation( value ) { this.setTranslation( value ); },
    get translation() { return this.getTranslation(); },
    
    set rotation( value ) { this.setRotation( value ); },
    get rotation() { return this.getRotation(); },
    
    set x( value ) { this.setX( value ); },
    get x() { return this.getX(); },
    
    set y( value ) { this.setY( value ); },
    get y() { return this.getY(); },
    
    set left( value ) { this.setLeft( value ); },
    get left() { return this.getLeft(); },
    
    set right( value ) { this.setRight( value ); },
    get right() { return this.getRight(); },
    
    set top( value ) { this.setTop( value ); },
    get top() { return this.getTop(); },
    
    set bottom( value ) { this.setBottom( value ); },
    get bottom() { return this.getBottom(); },
    
    set center( value ) { this.setCenter( value ); },
    get center() { return this.getCenter(); },
    
    set centerX( value ) { this.setCenterX( value ); },
    get centerX() { return this.getCenterX(); },
    
    set centerY( value ) { this.setCenterY( value ); },
    get centerY() { return this.getCenterY(); },
    
    set leftTop( value ) { this.setLeftTop( value ); },
    get leftTop() { return this.getLeftTop(); },
    set centerTop( value ) { this.setCenterTop( value ); },
    get centerTop() { return this.getCenterTop(); },
    set rightTop( value ) { this.setRightTop( value ); },
    get rightTop() { return this.getRightTop(); },
    set leftCenter( value ) { this.setLeftCenter( value ); },
    get leftCenter() { return this.getLeftCenter(); },
    set rightCenter( value ) { this.setRightCenter( value ); },
    get rightCenter() { return this.getRightCenter(); },
    set leftBottom( value ) { this.setLeftBottom( value ); },
    get leftBottom() { return this.getLeftBottom(); },
    set centerBottom( value ) { this.setCenterBottom( value ); },
    get centerBottom() { return this.getCenterBottom(); },
    set rightBottom( value ) { this.setRightBottom( value ); },
    get rightBottom() { return this.getRightBottom(); },
    
    set children( value ) { this.setChildren( value ); },
    get children() { return this.getChildren(); },
    
    get parents() { return this.getParents(); },
    
    get width() { return this.getWidth(); },
    get height() { return this.getHeight(); },
    get bounds() { return this.getBounds(); },
    get selfBounds() { return this.getSelfBounds(); },
    get childBounds() { return this.getChildBounds(); },
    get localBounds() { return this.getLocalBounds(); },
    set localBounds( value ) { return this.setLocalBounds( value ); },
    get globalBounds() { return this.getGlobalBounds(); },
    get visibleBounds() { return this.getVisibleBounds(); },
    get id() { return this.getId(); },
    get instances() { return this.getInstances(); },
    
    mutate: function( options ) {
      if ( !options ) {
        return this;
      }
      
      var node = this;
      
      _.each( this._mutatorKeys, function( key ) {
        if ( options[key] !== undefined ) {
          var descriptor = Object.getOwnPropertyDescriptor( Node.prototype, key );
          
          // if the key refers to a function that is not ES5 writable, it will execute that function with the single argument
          if ( descriptor && typeof descriptor.value === 'function' ) {
            node[key]( options[key] );
          } else {
            node[key] = options[key];
          }
        }
      } );
      
      return this; // allow chaining
    },
    
    toString: function( spaces, includeChildren ) {
      spaces = spaces || '';
      var props = this.getPropString( spaces + '  ', includeChildren === undefined ? true : includeChildren );
      return spaces + this.getBasicConstructor( props ? ( '\n' + props + '\n' + spaces ) : '' );
    },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Node( {' + propLines + '} )';
    },
    
    getPropString: function( spaces, includeChildren ) {

      var result = '';
      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        } else {
          result += spaces + key + ': ' + value;
        }
      }
      
      if ( this._children.length && includeChildren ) {
        var childString = '';
        _.each( this._children, function( child ) {
          if ( childString ) {
            childString += ',\n';
          }
          childString += child.toString( spaces + '  ' );
        } );
        addProp( 'children', '[\n' + childString + '\n' + spaces + ']', true );
      }
      
      // direct copy props
      if ( this.cursor ) { addProp( 'cursor', this.cursor ); }
      if ( !this.visible ) { addProp( 'visible', this.visible ); }
      if ( this.pickable !== null ) { addProp( 'pickable', this.pickable ); }
      if ( this.opacity !== 1 ) { addProp( 'opacity', this.opacity ); }
      
      if ( !this.transform.isIdentity() ) {
        var m = this.transform.getMatrix();
        addProp( 'matrix', 'dot.Matrix3.createFromPool( ' + m.m00() + ', ' + m.m01() + ', ' + m.m02() + ', ' +
                                                 m.m10() + ', ' + m.m11() + ', ' + m.m12() + ', ' +
                                                 m.m20() + ', ' + m.m21() + ', ' + m.m22() + ' )', true );
      }
      
      if ( this.renderer ) {
        addProp( 'renderer', this.renderer.name );
        if ( this.rendererOptions ) {
          // addProp( 'rendererOptions', JSON.stringify( this.rendererOptions ), true );
        }
      }
      
      if ( this._layerSplit ) {
        addProp( 'layerSplit', true );
      }
      
      return result;
    }
  };
  
  /*
   * This is an array of property (setter) names for Node.mutate(), which are also used when creating nodes with parameter objects.
   *
   * E.g. new scenery.Node( { x: 5, rotation: 20 } ) will create a Path, and apply setters in the order below (node.x = 5; node.rotation = 20)
   *
   * The order below is important! Don't change this without knowing the implications.
   * NOTE: translation-based mutators come before rotation/scale, since typically we think of their operations occuring "after" the rotation / scaling
   * NOTE: left/right/top/bottom/centerX/centerY are at the end, since they rely potentially on rotation / scaling changes of bounds that may happen beforehand
   * TODO: using more than one of {translation,x,left,right,centerX} or {translation,y,top,bottom,centerY} should be considered an error
   * TODO: move fill / stroke setting to mixins
   */
  Node.prototype._mutatorKeys = [ 'children', 'cursor', 'visible', 'pickable', 'opacity', 'matrix', 'translation', 'x', 'y', 'rotation', 'scale',
                                  'leftTop', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom',
                                  'left', 'right', 'top', 'bottom', 'centerX', 'centerY', 'renderer', 'rendererOptions',
                                  'layerSplit', 'mouseArea', 'touchArea', 'clipArea' ];
  
  // mix-in the events for Node
  /* jshint -W064 */
  NodeEvents( Node );
  
  return Node;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Represents a trail (path in the graph) from a 'root' node down to a descendant node.
 * In a DAG, or with different views, there can be more than one trail up from a node,
 * even to the same root node!
 *
 * It has an array of nodes, in order from the 'root' down to the last node,
 * a length, and an array of indices such that node_i.children[index_i] === node_{i+1}.
 *
 * The indices can sometimes become stale when nodes are added and removed, so Trails
 * can have their indices updated with reindex(). It's designed to be as fast as possible
 * on Trails that are already indexed accurately.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Trail',['require','DOT/Matrix3','DOT/Transform3','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
  

  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );

  var scenery = require( 'SCENERY/scenery' );

  require( 'SCENERY/nodes/Node' );
  // require( 'SCENERY/util/TrailPointer' );

  scenery.Trail = function Trail( nodes ) {
    /*
     * Controls the immutability of the trail.
     * If set to true, add/remove descendant/ancestor should fail if assertions are enabled
     * Use setImmutable() or setMutable() to signal a specific type of protection, so it cannot be changed later
     */
    if ( assert ) {
      // only do this if assertions are enabled, otherwise we won't access it at all
      this.immutable = undefined;
    }

    if ( nodes instanceof Trail ) {
      // copy constructor (takes advantage of already built index information)
      var otherTrail = nodes;

      this.nodes = otherTrail.nodes.slice( 0 );
      this.length = otherTrail.length;
      this.uniqueId = otherTrail.uniqueId;
      this.indices = otherTrail.indices.slice( 0 );
      return;
    }

    this.nodes = [];
    this.length = 0;
    this.uniqueId = '';

    // indices[x] stores the index of nodes[x] in nodes[x-1]'s children
    this.indices = [];

    var trail = this;
    if ( nodes ) {
      if ( nodes instanceof scenery.Node ) {
        var node = nodes;

        // add just a single node in
        trail.addDescendant( node );
      }
      else {
        // process it as an array
        var len = nodes.length;
        for ( var i = 0; i < len; i++ ) {
          trail.addDescendant( nodes[i] );
        }
      }
    }

    phetAllocation && phetAllocation( 'Trail' );
  };
  var Trail = scenery.Trail;

  Trail.prototype = {
    constructor: Trail,

    copy: function() {
      return new Trail( this );
    },

    // convenience function to determine whether this trail will render something
    isPainted: function() {
      return this.lastNode().isPainted();
    },

    // this trail is visible only if all nodes on it are marked as visible
    isVisible: function() {
      var i = this.nodes.length;
      while ( i-- ) {
        if ( !this.nodes[i].isVisible() ) {
          return false;
        }
      }
      return true;
    },

    getOpacity: function() {
      var opacity = 1;
      var i = this.nodes.length;
      while ( i-- ) {
        opacity *= this.nodes[i].getOpacity();
      }
      return opacity;
    },

    // essentially whether this node is visited in the hit-testing operation
    isPickable: function() {
      // it won't be if it or any ancestor is pickable: false, or is invisible
      if ( _.some( this.nodes, function( node ) { return node._pickable === false || node._visible === false; } ) ) { return false; }

      // if there is any listener or pickable: true, it will be pickable
      if ( _.some( this.nodes, function( node ) { return node._pickable === true || node._inputListeners.length > 0; } ) ) { return true; }

      if ( this.lastNode()._subtreePickableCount > 0 ) {
        return true;
      }

      // no listeners or pickable: true, so it will be pruned
      return false;
    },

    get: function( index ) {
      if ( index >= 0 ) {
        return this.nodes[index];
      }
      else {
        // negative index goes from the end of the array
        return this.nodes[this.nodes.length + index];
      }
    },

    slice: function( startIndex, endIndex ) {
      return new Trail( this.nodes.slice( startIndex, endIndex ) );
    },

    subtrailTo: function( node, excludeNode ) {
      return this.slice( 0, _.indexOf( this.nodes, node ) + ( excludeNode ? 0 : 1 ) );
    },

    isEmpty: function() {
      return this.nodes.length === 0;
    },

    getInstance: function() {
      return this.lastNode().getInstanceFromTrail( this );
    },

    // from local to global
    getMatrix: function() {
      // TODO: performance: can we cache this ever? would need the scene to not really change in between
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[i]._transform.getMatrix() );
      }
      return matrix;
    },

    // from parent to global
    getParentMatrix: function() {
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length - 1; i++ ) {
        matrix.multiplyMatrix( nodes[i]._transform.getMatrix() );
      }
      return matrix;
    },

    // from local to global
    getTransform: function() {
      return new Transform3( this.getMatrix() );
    },

    // from parent to global
    getParentTransform: function() {
      return new Transform3( this.getParentMatrix() );
    },

    addAncestor: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addAncestor' );
      assert && assert( node, 'cannot add falsy value to a Trail' );


      if ( this.nodes.length ) {
        var oldRoot = this.nodes[0];
        this.indices.unshift( index === undefined ? _.indexOf( node._children, oldRoot ) : index );
      }
      this.nodes.unshift( node );

      this.length++;
      // accelerated version of this.updateUniqueId()
      this.uniqueId = ( this.uniqueId ? node._id + '-' + this.uniqueId : node._id + '' );
      return this;
    },

    removeAncestor: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeAncestor' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );

      this.nodes.shift();
      if ( this.indices.length ) {
        this.indices.shift();
      }

      this.length--;
      this.updateUniqueId();
      return this;
    },

    addDescendant: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addDescendant' );
      assert && assert( node, 'cannot add falsy value to a Trail' );


      if ( this.nodes.length ) {
        var parent = this.lastNode();
        this.indices.push( index === undefined ? _.indexOf( parent._children, node ) : index );
      }
      this.nodes.push( node );

      this.length++;
      // accelerated version of this.updateUniqueId()
      this.uniqueId = ( this.uniqueId ? this.uniqueId + '-' + node._id : node._id + '' );
      return this;
    },

    removeDescendant: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeDescendant' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );

      this.nodes.pop();
      if ( this.indices.length ) {
        this.indices.pop();
      }

      this.length--;
      this.updateUniqueId();
      return this;
    },

    // refreshes the internal index references (important if any children arrays were modified!)
    reindex: function() {
      var length = this.length;
      for ( var i = 1; i < length; i++ ) {
        // only replace indices where they have changed (this was a performance hotspot)
        var currentIndex = this.indices[i - 1];
        var baseNode = this.nodes[i - 1];

        if ( baseNode._children[currentIndex] !== this.nodes[i] ) {
          this.indices[i - 1] = _.indexOf( baseNode._children, this.nodes[i] );
        }
      }
    },

    setImmutable: function() {
      // if assertions are disabled, we hope this is inlined as a no-op
      if ( assert ) {
        assert( this.immutable !== false, 'A trail cannot be made immutable after being flagged as mutable' );
        this.immutable = true;
      }

      // TODO: consider setting mutators to null here instead of the function call check (for performance, and profile the differences)

      return this; // allow chaining
    },

    setMutable: function() {
      // if assertions are disabled, we hope this is inlined as a no-op
      if ( assert ) {
        assert( this.immutable !== true, 'A trail cannot be made mutable after being flagged as immutable' );
        this.immutable = false;
      }

      return this; // allow chaining
    },

    areIndicesValid: function() {
      for ( var i = 1; i < this.length; i++ ) {
        var currentIndex = this.indices[i - 1];
        if ( this.nodes[i - 1]._children[currentIndex] !== this.nodes[i] ) {
          return false;
        }
      }
      return true;
    },

    equals: function( other ) {
      if ( this.length !== other.length ) {
        return false;
      }

      for ( var i = 0; i < this.nodes.length; i++ ) {
        if ( this.nodes[i] !== other.nodes[i] ) {
          return false;
        }
      }

      return true;
    },

    // returns a new Trail from the root up to the parameter node.
    upToNode: function( node ) {
      var nodeIndex = _.indexOf( this.nodes, node );
      assert && assert( nodeIndex >= 0, 'Trail does not contain the node' );
      return this.slice( 0, _.indexOf( this.nodes, node ) + 1 );
    },

    // whether this trail contains the complete 'other' trail, but with added descendants afterwards
    isExtensionOf: function( other, allowSameTrail ) {
      assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed' );
      assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed' );

      if ( this.length <= other.length - ( allowSameTrail ? 1 : 0 ) ) {
        return false;
      }

      for ( var i = 0; i < other.nodes.length; i++ ) {
        if ( this.nodes[i] !== other.nodes[i] ) {
          return false;
        }
      }

      return true;
    },

    // a transform from our local coordinate frame to the other trail's local coordinate frame
    getTransformTo: function( otherTrail ) {
      return new Transform3( this.getMatrixTo( otherTrail ) );
    },

    // returns a matrix that transforms a point in our last node's local coordinate frame to the other trail's last node's local coordinate frame
    getMatrixTo: function( otherTrail ) {
      this.reindex();
      otherTrail.reindex();

      var branchIndex = this.getBranchIndexTo( otherTrail );
      var idx;

      var matrix = Matrix3.IDENTITY;

      // walk our transform down, prepending
      for ( idx = this.length - 1; idx >= branchIndex; idx-- ) {
        matrix = this.nodes[idx].getTransform().getMatrix().timesMatrix( matrix );
      }

      // walk our transform up, prepending inverses
      for ( idx = branchIndex; idx < otherTrail.length; idx++ ) {
        matrix = otherTrail.nodes[idx].getTransform().getInverse().timesMatrix( matrix );
      }

      return matrix;
    },

    // the first index that is different between this trail and the other trail
    getBranchIndexTo: function( otherTrail ) {
      assert && assert( this.nodes[0] === otherTrail.nodes[0], 'To get a branch index, the trails must have the same root' );

      var branchIndex;

      for ( branchIndex = 0; branchIndex < Math.min( this.length, otherTrail.length ); branchIndex++ ) {
        if ( this.nodes[branchIndex] !== otherTrail.nodes[branchIndex] ) {
          break;
        }
      }

      return branchIndex;
    },

    // TODO: phase out in favor of get()
    nodeFromTop: function( offset ) {
      return this.nodes[this.length - 1 - offset];
    },

    lastNode: function() {
      return this.nodeFromTop( 0 );
    },

    rootNode: function() {
      return this.nodes[0];
    },

    // returns the previous graph trail in the order of self-rendering
    previous: function() {
      if ( this.nodes.length <= 1 ) {
        return null;
      }

      var top = this.nodeFromTop( 0 );
      var parent = this.nodeFromTop( 1 );

      var parentIndex = _.indexOf( parent._children, top );
      assert && assert( parentIndex !== -1 );
      var arr = this.nodes.slice( 0, this.nodes.length - 1 );
      if ( parentIndex === 0 ) {
        // we were the first child, so give it the trail to the parent
        return new Trail( arr );
      }
      else {
        // previous child
        arr.push( parent._children[parentIndex - 1] );

        // and find its last terminal
        while ( arr[arr.length - 1]._children.length !== 0 ) {
          var last = arr[arr.length - 1];
          arr.push( last._children[last._children.length - 1] );
        }

        return new Trail( arr );
      }
    },

    // like previous(), but keeps moving back until the trail goes to a node with isPainted() === true
    previousPainted: function() {
      var result = this.previous();
      while ( result && !result.isPainted() ) {
        result = result.previous();
      }
      return result;
    },

    // in the order of self-rendering
    next: function() {
      var arr = this.nodes.slice( 0 );

      var top = this.nodeFromTop( 0 );
      if ( top._children.length > 0 ) {
        // if we have children, return the first child
        arr.push( top._children[0] );
        return new Trail( arr );
      }
      else {
        // walk down and attempt to find the next parent
        var depth = this.nodes.length - 1;

        while ( depth > 0 ) {
          var node = this.nodes[depth];
          var parent = this.nodes[depth - 1];

          arr.pop(); // take off the node so we can add the next sibling if it exists

          var index = _.indexOf( parent._children, node );
          if ( index !== parent._children.length - 1 ) {
            // there is another (later) sibling. use that!
            arr.push( parent._children[index + 1] );
            return new Trail( arr );
          }
          else {
            depth--;
          }
        }

        // if we didn't reach a later sibling by now, it doesn't exist
        return null;
      }
    },

    // like next(), but keeps moving back until the trail goes to a node with isPainted() === true
    nextPainted: function() {
      var result = this.next();
      while ( result && !result.isPainted() ) {
        result = result.next();
      }
      return result;
    },

    // calls callback( trail ) for this trail, and each descendant trail. If callback returns true, subtree will be skipped
    eachTrailUnder: function( callback ) {
      // TODO: performance: should be optimized to be much faster, since we don't have to deal with the before/after
      new scenery.TrailPointer( this, true ).eachTrailBetween( new scenery.TrailPointer( this, false ), callback );
    },

    /*
     * Standard Java-style compare. -1 means this trail is before (under) the other trail, 0 means equal, and 1 means this trail is
     * after (on top of) the other trail.
     * A shorter subtrail will compare as -1.
     *
     * Assumes that the Trails are properly indexed. If not, please reindex them!
     *
     * Comparison is for the rendering order, so an ancestor is 'before' a descendant
     */
    compare: function( other ) {
      assert && assert( !this.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( !other.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( this.nodes[0] === other.nodes[0], 'for Trail comparison, trails must have the same root node' );
      assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed on ' + this.toString() );
      assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed on ' + other.toString() );

      var minNodeIndex = Math.min( this.indices.length, other.indices.length );
      for ( var i = 0; i < minNodeIndex; i++ ) {
        if ( this.indices[i] !== other.indices[i] ) {
          if ( this.indices[i] < other.indices[i] ) {
            return -1;
          }
          else {
            return 1;
          }
        }
      }

      // we scanned through and no nodes were different (one is a subtrail of the other)
      if ( this.nodes.length < other.nodes.length ) {
        return -1;
      }
      else if ( this.nodes.length > other.nodes.length ) {
        return 1;
      }
      else {
        return 0;
      }
    },

    isBefore: function( other ) {
      return this.compare( other ) === -1;
    },

    isAfter: function( other ) {
      return this.compare( other ) === 1;
    },

    localToGlobalPoint: function( point ) {
      // TODO: performance: multiple timesVector2 calls up the chain is probably faster
      return this.getMatrix().timesVector2( point );
    },

    localToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getMatrix() );
    },

    globalToLocalPoint: function( point ) {
      return this.getTransform().inversePosition2( point );
    },

    globalToLocalBounds: function( bounds ) {
      return this.getTransform().inverseBounds2( bounds );
    },

    parentToGlobalPoint: function( point ) {
      // TODO: performance: multiple timesVector2 calls up the chain is probably faster
      return this.getParentMatrix().timesVector2( point );
    },

    parentToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getParentMatrix() );
    },

    globalToParentPoint: function( point ) {
      return this.getParentTransform().inversePosition2( point );
    },

    globalToParentBounds: function( bounds ) {
      return this.getParentTransform().inverseBounds2( bounds );
    },

    updateUniqueId: function() {
      // string concatenation is faster, see http://jsperf.com/string-concat-vs-joins
      var result = '';
      var len = this.nodes.length;
      if ( len > 0 ) {
        result += this.nodes[0]._id;
      }
      for ( var i = 1; i < len; i++ ) {
        result += '-' + this.nodes[i]._id;
      }
      this.uniqueId = result;
      // this.uniqueId = _.map( this.nodes, function( node ) { return node.getId(); } ).join( '-' );
    },

    // concatenates the unique IDs of nodes in the trail, so that we can do id-based lookups
    getUniqueId: function() {
      // sanity checks
      if ( assert ) {
        var oldUniqueId = this.uniqueId;
        this.updateUniqueId();
        assert( oldUniqueId === this.uniqueId );
      }
      return this.uniqueId;
    },

    toString: function() {
      this.reindex();
      if ( !this.length ) {
        return 'Empty Trail';
      }
      return '[Trail ' + this.indices.join( '.' ) + ' ' + this.getUniqueId() + ']';
    }
  };

  // like eachTrailBetween, but only fires for painted trails. If callback returns true, subtree will be skipped
  Trail.eachPaintedTrailBetween = function( a, b, callback, excludeEndTrails, scene ) {
    Trail.eachTrailBetween( a, b, function( trail ) {
      if ( trail && trail.isPainted() ) {
        return callback( trail );
      }
    }, excludeEndTrails, scene );
  };

  // global way of iterating across trails. when callback returns true, subtree will be skipped
  Trail.eachTrailBetween = function( a, b, callback, excludeEndTrails, scene ) {
    var aPointer = a ? new scenery.TrailPointer( a.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( scene ), true );
    var bPointer = b ? new scenery.TrailPointer( b.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( scene ), false );

    // if we are excluding endpoints, just bump the pointers towards each other by one step
    if ( excludeEndTrails ) {
      aPointer.nestedForwards();
      bPointer.nestedBackwards();

      // they were adjacent, so no callbacks will be executed
      if ( aPointer.compareNested( bPointer ) === 1 ) {
        return;
      }
    }

    aPointer.depthFirstUntil( bPointer, function( pointer ) {
      if ( pointer.isBefore ) {
        return callback( pointer.trail );
      }
    }, false );
  };

  // The index at which the two trails diverge. If a.length === b.length === branchIndex, the trails are identical
  Trail.branchIndex = function( a, b ) {
    assert && assert( a.nodes[0] === b.nodes[0], 'Branch changes require roots to be the same' );
    var branchIndex;
    var shortestLength = Math.min( a.length, b.length );
    for ( branchIndex = 0; branchIndex < shortestLength; branchIndex++ ) {
      if ( a.nodes[branchIndex] !== b.nodes[branchIndex] ) {
        break;
      }
    }
    return branchIndex;
  };

  // The subtrail from the root that both trails share
  Trail.sharedTrail = function( a, b ) {
    return a.slice( 0, Trail.branchIndex( a, b ) );
  };

  /*
   * Fires subtree(trail) or self(trail) on the callbacks to create disjoint subtrees (trails) that cover exactly the nodes
   * inclusively between a and b in rendering order.
   * We try to consolidate these as much as possible.
   *
   * "a" and "b" are treated like self painted trails in the rendering order
   * 
   *
   * Example tree:
   *   a
   *   - b
   *   --- c
   *   --- d
   *   - e
   *   --- f
   *   ----- g
   *   ----- h
   *   ----- i
   *   --- j
   *   ----- k
   *   - l
   *   - m
   *   --- n
   *
   * spannedSubtrees( a, a ) -> self( a );
   * spannedSubtrees( c, n ) -> subtree( a ); NOTE: if b is painted, that wouldn't work!
   * spannedSubtrees( h, l ) -> subtree( h ); subtree( i ); subtree( j ); self( l );
   * spannedSubtrees( c, i ) -> [b,f] --- wait, include e self?
   */
  Trail.spannedSubtrees = function( a, b ) {
    // assert && assert( a.nodes[0] === b.nodes[0], 'Spanned subtrees for a and b requires that a and b have the same root' );

    // a.reindex();
    // b.reindex();

    // var subtrees = [];

    // var branchIndex = Trail.branchIndex( a, b );
    // assert && assert( branchIndex > 0, 'Branch index should always be > 0' );

    // if ( a.length === branchIndex && b.length === branchIndex ) {
    //   // the two trails are equal
    //   subtrees.push( a );
    // } else {
    //   // find the first place where our start isn't the first child
    //   for ( var before = a.length - 1; before >= branchIndex; before-- ) {
    //     if ( a.indices[before-1] !== 0 ) {
    //       break;
    //     }
    //   }

    //   // find the first place where our end isn't the last child
    //   for ( var after = a.length - 1; after >= branchIndex; after-- ) {
    //     if ( b.indices[after-1] !== b.nodes[after-1]._children.length - 1 ) {
    //       break;
    //     }
    //   }

    //   if ( before < branchIndex && after < branchIndex ) {
    //     // we span the entire tree up to nodes[branchIndex-1], so return only that subtree
    //     subtrees.push( a.slice( 0, branchIndex ) );
    //   } else {
    //     // walk the subtrees down from the start
    //     for ( var ia = before; ia >= branchIndex; ia-- ) {
    //       subtrees.push( a.slice( 0, ia + 1 ) );
    //     }

    //     // walk through the middle
    //     var iStart = a.indices[branchIndex-1];
    //     var iEnd = b.indices[branchIndex-1];
    //     var base = a.slice( 0, branchIndex );
    //     var children = base.lastNode()._children;
    //     for ( var im = iStart; im <= iEnd; im++ ) {
    //       subtrees.push( base.copy().addDescendant( children[im], im ) );
    //     }

    //     // walk the subtrees up to the end
    //     for ( var ib = branchIndex; ib <= after; ib++ ) {
    //       subtrees.push( b.slice( 0, ib + 1 ) );
    //     }
    //   }
    // }

    // return subtrees;
  };

  return Trail;
} );



// Copyright 2002-2013, University of Colorado

/**
 * An instance that is specific to the display (not necessarily a global instance, could be in a Canvas cache, etc),
 * that is needed to tracking instance-specific display information, and signals to the display system when other
 * changes are necessary.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/display/DisplayInstance',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var globalIdCounter = 1;
  
  /**
   * @param {DisplayInstance|null} parent
   */
  scenery.DisplayInstance = function DisplayInstance( trail ) {
    this.id = globalIdCounter++;
    this.trail = trail;
    this.parent = null; // will be set as needed
    this.children = [];
    this.proxyChild = null;
    this.proxyParent = null;
    this.state = null; // filled in with rendering state later
    this.renderer = null; // filled in later
    
    // references into the linked list of effectively painted instances (null if nothing is effectively painted under this, both self if we are effectively painted)
    this.firstPainted = null;
    this.lastPainted = null;
    
    // basically, our linked list of effectively painted instances
    this.nextPainted = null;
    this.previousPainted = null;
  };
  var DisplayInstance = scenery.DisplayInstance;
  
  inherit( Object, DisplayInstance, {
    appendInstance: function( instance ) {
      this.children.push( instance );
    },
    
    // since backbone/canvas caches can create stub instances that are effectively painted
    isEffectivelyPainted: function() {
      return this.renderer !== null;
    }
  } );
  
  return DisplayInstance;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A description of layer settings and the ability to create a layer with those settings.
 * Used internally for the layer building process.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/LayerType',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  scenery.LayerType = function LayerType( Constructor, name, bitmask, renderer, args ) {
    this.Constructor = Constructor;
    this.name = name;
    this.bitmask = bitmask;
    this.renderer = renderer;
    this.args = args;
  };
  var LayerType = scenery.LayerType;
  
  LayerType.prototype = {
    constructor: LayerType,
    
    supportsRenderer: function( renderer ) {
      // NOTE: if this is changed off of instance equality, update supportsNode below
      return this.renderer === renderer;
    },
    
    supportsBitmask: function( bitmask ) {
      return ( this.bitmask & bitmask ) !== 0;
    },
    
    supportsNode: function( node ) {
      // for now, only check the renderer that we are interested in
      return node.supportsRenderer( this.renderer );
    },
    
    createLayer: function( args ) {
      var Constructor = this.Constructor;
      return new Constructor( _.extend( {}, args, this.args ) ); // allow overriding certain arguments if necessary by the LayerType
    }
  };
  
  return LayerType;
} );



// Copyright 2002-2013, University of Colorado

/**
 * Base code for layers that helps with shared layer functions
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/Layer',['require','DOT/Bounds2','DOT/Transform3','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  
  
  var Bounds2 = require( 'DOT/Bounds2' );
  var Transform3 = require( 'DOT/Transform3' );
  
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  
  var globalIdCounter = 1;
  
  /*
   * Required arguments:
   * $main     - the jQuery-wrapped container for the scene
   * scene     - the scene itself
   * baseNode  - the base node for this layer
   */
  scenery.Layer = function Layer( args ) {
    
    // assign a unique ID to this layer
    this._id = globalIdCounter++;
    
    this.$main = args.$main;
    this.scene = args.scene;
    this.baseNode = args.baseNode;
    
    // TODO: cleanup of flags!
    this.usesPartialCSSTransforms = args.cssTranslation || args.cssRotation || args.cssScale;
    this.cssTranslation = args.cssTranslation; // CSS for the translation
    this.cssRotation = args.cssRotation;       // CSS for the rotation
    this.cssScale = args.cssScale;             // CSS for the scaling
    this.cssTransform = args.cssTransform;     // CSS for the entire base node (will ignore other partial transforms)
    assert && assert( !( this.usesPartialCSSTransforms && this.cssTransform ), 'Do not specify both partial and complete CSS transform arguments.' );
    
    // initialize to fully dirty so we draw everything the first time
    // bounds in global coordinate frame
    this.dirtyBounds = Bounds2.EVERYTHING;
    
    this.setStartBoundary( args.startBoundary );
    this.setEndBoundary( args.endBoundary );
    
    // set baseTrail from the scene to our baseNode
    if ( this.baseNode === this.scene ) {
      this.baseTrail = new scenery.Trail( this.scene );
    } else {
      this.baseTrail = this.startPaintedTrail.upToNode( this.baseNode );
      assert && assert( this.baseTrail.lastNode() === this.baseNode );
    }
    
    // we reference all painted trails in an unordered way
    this._layerTrails = []; // TODO: performance: remove layerTrails if possible!
    this._instanceCount = 0; // track how many instances we are tracking (updated in stitching by instances)
    
    var layer = this;
    
    // whenever the base node's children or self change bounds, signal this. we want to explicitly ignore the base node's main bounds for
    // CSS transforms, since the self / children bounds may not have changed
    this.baseNodeBoundsListener = function( bounds ) {
      layer.baseNodeInternalBoundsChange(); // TODO: verify that this is working as expected
    };
    this.baseNode.addEventListener( 'selfBounds', this.baseNodeBoundsListener );
    this.baseNode.addEventListener( 'childBounds', this.baseNodeBoundsListener );
    
    this.fitToBounds = this.usesPartialCSSTransforms || this.cssTransform;
    assert && assert( this.fitToBounds || this.baseNode === this.scene, 'If the baseNode is not the scene, we need to fit the bounds' );
    
    // used for CSS transforms where we need to transform our base node's bounds into the (0,0,w,h) bounds range
    this.baseNodeTransform = new Transform3();
    //this.baseNodeInteralBounds = Bounds2.NOTHING; // stores the bounds transformed into (0,0,w,h)
    
    this.disposed = false; // track whether we have been disposed or not
  };
  var Layer = scenery.Layer;
  
  Layer.prototype = {
    constructor: Layer,
    
    setStartBoundary: function( boundary ) {
      // console.log( 'setting start boundary on layer ' + this.getId() + ': ' + boundary.toString() );
      this.startBoundary = boundary;
      
      // TODO: deprecate these, use boundary references instead? or boundary convenience functions
      this.startPaintedTrail = this.startBoundary.nextPaintedTrail;
      
      // set immutability guarantees
      this.startPaintedTrail.setImmutable();
    },
    
    setEndBoundary: function( boundary ) {
      // console.log( 'setting end boundary on layer ' + this.getId() + ': ' + boundary.toString() );
      this.endBoundary = boundary;
      
      // TODO: deprecate these, use boundary references instead? or boundary convenience functions
      this.endPaintedTrail = this.endBoundary.previousPaintedTrail;
      
      // set immutability guarantees
      this.endPaintedTrail.setImmutable();
    },
    
    toString: function() {
      return this.getName() + ' ' + ( this.startPaintedTrail ? this.startPaintedTrail.toString() : '!' ) + ' => ' + ( this.endPaintedTrail ? this.endPaintedTrail.toString() : '!' );
    },
    
    getId: function() {
      return this._id;
    },
    get id() { return this._id; }, // ES5 version
    
    // painted trails associated with the layer, NOT necessarily in order
    getLayerTrails: function() {
      return this._layerTrails.slice( 0 );
    },
    
    getPaintedTrailCount: function() {
      return this._layerTrails.length;
    },
    
    /*---------------------------------------------------------------------------*
    * Abstract
    *----------------------------------------------------------------------------*/
    
    render: function( state ) {
      throw new Error( 'Layer.render unimplemented' );
    },
    
    // TODO: consider a stack-based model for transforms?
    // TODO: is this necessary? verify with the render state
    applyTransformationMatrix: function( matrix ) {
      throw new Error( 'Layer.applyTransformationMatrix unimplemented' );
    },
    
    // adds a trail (with the last node) to the layer
    addInstance: function( instance ) {
      var trail = instance.trail;
      
      if ( assert ) {
        _.each( this._layerTrails, function( otherTrail ) {
          assert( !trail.equals( otherTrail ), 'trail in addInstance should not already exist in a layer' );
        } );
      }
      
      // TODO: sync this with DOMLayer's implementation
      this._layerTrails.push( trail );
      trail.setImmutable(); // don't allow this Trail to be changed
    },
    
    // removes a trail (with the last node) to the layer
    removeInstance: function( instance ) {
      // TODO: sync this with DOMLayer's implementation
      var i;
      for ( i = 0; i < this._layerTrails.length; i++ ) {
        this._layerTrails[i].reindex();
        if ( this._layerTrails[i].compare( instance.trail ) === 0 ) {
          break;
        }
      }
      assert && assert( i < this._layerTrails.length );
      
      this._layerTrails.splice( i, 1 );
    },
    
    // returns next zIndex in place. allows layers to take up more than one single zIndex
    reindex: function( zIndex ) {
      this.startBoundary.reindex();
      this.endBoundary.reindex();
    },
    
    pushClipShape: function( shape ) {
      throw new Error( 'Layer.pushClipShape unimplemented' );
    },
    
    popClipShape: function() {
      throw new Error( 'Layer.popClipShape unimplemented' );
    },
    
    renderToCanvas: function( canvas, context, delayCounts ) {
      throw new Error( 'Layer.renderToCanvas unimplemented' );
    },
    
    dispose: function() {
      assert && assert( !this.disposed, 'Layer has already been disposed!' );
      
      this.disposed = true;
      
      // clean up listeners
      this.baseNode.removeEventListener( 'selfBounds', this.baseNodeBoundsListener );
      this.baseNode.removeEventListener( 'childBounds', this.baseNodeBoundsListener );
    },
    
    getName: function() {
      throw new Error( 'Layer.getName unimplemented' );
    },
    
    // called when the base node's "internal" (self or child) bounds change, but not when it is just from the base node's own transform changing
    baseNodeInternalBoundsChange: function() {
      // no error, many times this doesn't need to be handled
    }
    
  };
  
  Layer.cssTransformPadding = 3;
  
  return Layer;
} );



// Copyright 2002-2013, University of Colorado

/**
 * Wraps the context and contains a reference to the canvas, so that we can absorb unnecessary state changes,
 * and possibly combine certain fill operations.
 *
 * TODO: performance analysis, possibly axe this and use direct modification.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/CanvasContextWrapper',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  scenery.CanvasContextWrapper = function CanvasContextWrapper( canvas, context ) {
    this.canvas = canvas;
    this.context = context;
    
    this.resetStyles();
    
    phetAllocation && phetAllocation( 'CanvasContextWrapper' );
  };
  var CanvasContextWrapper = scenery.CanvasContextWrapper;
  
  CanvasContextWrapper.prototype = {
    constructor: CanvasContextWrapper,
    
    // set local styles to undefined, so that they will be invalidated later
    resetStyles: function() {
      this.fillStyle = undefined; // null
      this.strokeStyle = undefined; // null
      this.lineWidth = undefined; // 1
      this.lineCap = undefined; // 'butt'
      this.lineJoin = undefined; // 'miter'
      this.lineDash = undefined; // []
      this.lineDashOffset = undefined; // 0
      this.miterLimit = undefined; // 10
      
      this.font = undefined; // '10px sans-serif'
      this.direction = undefined; // 'inherit'
    },

    /**
     * Sets a (possibly) new width and height, and clears the canvas.
     * @param width
     * @param height
     */
    setDimensions: function( width, height ) {

      //Don't guard against width and height, because we need to clear the canvas.
      //TODO: Is it expensive to clear by setting both the width and the height?  Maybe we just need to set the width to clear it.
      this.canvas.width = width;
      this.canvas.height = height;

      // assume all persistent data could have changed
      this.resetStyles();
    },
    
    setFillStyle: function( style ) {
      if ( this.fillStyle !== style ) {
        this.fillStyle = style;
        
        // allow gradients / patterns
        this.context.fillStyle = ( style && style.getCanvasStyle ) ? style.getCanvasStyle() : style;
      }
    },
    
    setStrokeStyle: function( style ) {
      if ( this.strokeStyle !== style ) {
        this.strokeStyle = style;
        
        // allow gradients / patterns
        this.context.strokeStyle = ( style && style.getCanvasStyle ) ? style.getCanvasStyle() : style;
      }
    },
    
    setLineWidth: function( width ) {
      if ( this.lineWidth !== width ) {
        this.lineWidth = width;
        this.context.lineWidth = width;
      }
    },
    
    setLineCap: function( cap ) {
      if ( this.lineCap !== cap ) {
        this.lineCap = cap;
        this.context.lineCap = cap;
      }
    },
    
    setLineJoin: function( join ) {
      if ( this.lineJoin !== join ) {
        this.lineJoin = join;
        this.context.lineJoin = join;
      }
    },
    
    setLineDash: function( dash ) {
      assert && assert( dash !== undefined, 'undefined line dash would cause hard-to-trace errors' );
      if ( this.lineDash !== dash ) {
        this.lineDash = dash;
        if ( this.context.setLineDash ) {
          this.context.setLineDash( dash === null ? [] : dash ); // see https://github.com/phetsims/scenery/issues/101 for null line-dash workaround
        } else if ( this.context.mozDash !== undefined ) {
          this.context.mozDash = dash;
        } else if ( this.context.webkitLineDash !== undefined ) {
          this.context.webkitLineDash = dash ? dash : [];
        } else {
          // unsupported line dash! do... nothing?
        }
      }
    },
    
    setLineDashOffset: function( lineDashOffset ) {
      if ( this.lineDashOffset !== lineDashOffset ) {
        this.lineDashOffset = lineDashOffset;
        if ( this.context.lineDashOffset !== undefined ) {
          this.context.lineDashOffset = lineDashOffset;
        } else if ( this.context.webkitLineDashOffset !== undefined ) {
          this.context.webkitLineDashOffset = lineDashOffset;
        } else {
          // unsupported line dash! do... nothing?
        }
      }
    },
    
    setFont: function( font ) {
      if ( this.font !== font ) {
        this.font = font;
        this.context.font = font;
      }
    },
    
    setDirection: function( direction ) {
      if ( this.direction !== direction ) {
        this.direction = direction;
        this.context.direction = direction;
      }
    }
  };
  
  return CanvasContextWrapper;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Points to a specific node (with a trail), and whether it is conceptually before or after the node.
 *
 * There are two orderings:
 * - rendering order: the order that node selves would be rendered, matching the Trail implicit order
 * - nesting order:   the order in depth first with entering a node being "before" and exiting a node being "after"
 *
 * TODO: more seamless handling of the orders. or just exclusively use the nesting order
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/TrailPointer',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  require( 'SCENERY/util/Trail' );
  
  /*
   * isBefore: whether this points to before the node (and its children) have been rendered, or after
   */
  scenery.TrailPointer = function TrailPointer( trail, isBefore ) {
    assert && assert( trail instanceof scenery.Trail, 'trail is not a trail' );
    this.trail = trail;
    
    this.setBefore( isBefore );
    
    phetAllocation && phetAllocation( 'TrailPointer' );
  };
  var TrailPointer = scenery.TrailPointer;
  
  TrailPointer.prototype = {
    constructor: TrailPointer,
    
    copy: function() {
      return new TrailPointer( this.trail.copy(), this.isBefore );
    },
    
    setBefore: function( isBefore ) {
      this.isBefore = isBefore;
      this.isAfter = !isBefore;
    },
    
    // return the equivalent pointer that swaps before and after (may return null if it doesn't exist)
    getRenderSwappedPointer: function() {
      var newTrail = this.isBefore ? this.trail.previous() : this.trail.next();
      
      if ( newTrail === null ) {
        return null;
      } else {
        return new TrailPointer( newTrail, !this.isBefore );
      }
    },
    
    getRenderBeforePointer: function() {
      return this.isBefore ? this : this.getRenderSwappedPointer();
    },
    
    getRenderAfterPointer: function() {
      return this.isAfter ? this : this.getRenderSwappedPointer();
    },
    
    /*
     * In the render order, will return 0 if the pointers are equivalent, -1 if this pointer is before the
     * other pointer, and 1 if this pointer is after the other pointer.
     */
    compareRender: function( other ) {
      assert && assert( other !== null );
      
      var a = this.getRenderBeforePointer();
      var b = other.getRenderBeforePointer();
      
      if ( a !== null && b !== null ) {
        // normal (non-degenerate) case
        return a.trail.compare( b.trail );
      } else {
        // null "before" point is equivalent to the "after" pointer on the last rendered node.
        if ( a === b ) {
          return 0; // uniqueness guarantees they were the same
        } else {
          return a === null ? 1 : -1;
        }
      }
    },
    
    /*
     * Like compareRender, but for the nested (depth-first) order
     *
     * TODO: optimization?
     */
    compareNested: function( other ) {
      assert && assert( other );
      
      var comparison = this.trail.compare( other.trail );
      
      if ( comparison === 0 ) {
        // if trails are equal, just compare before/after
        if ( this.isBefore === other.isBefore ) {
          return 0;
        } else {
          return this.isBefore ? -1 : 1;
        }
      } else {
        // if one is an extension of the other, the shorter isBefore flag determines the order completely
        if ( this.trail.isExtensionOf( other.trail ) ) {
          return other.isBefore ? 1 : -1;
        } else if ( other.trail.isExtensionOf( this.trail ) ) {
          return this.isBefore ? -1 : 1;
        } else {
          // neither is a subtrail of the other, so a straight trail comparison should give the answer
          return comparison;
        }
      }
    },
    
    equalsRender: function( other ) {
      return this.compareRender( other ) === 0;
    },
    
    equalsNested: function( other ) {
      return this.compareNested( other ) === 0;
    },
    
    // will return false if this pointer has gone off of the beginning or end of the tree (will be marked with isAfter or isBefore though)
    hasTrail: function() {
      return !!this.trail;
    },
    
    // TODO: refactor with "Side"-like handling
    // moves this pointer forwards one step in the nested order
    nestedForwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.lastNode()._children.length > 0 ) {
          // stay as before, just walk to the first child
          this.trail.addDescendant( this.trail.lastNode()._children[0], 0 );
        } else {
          // stay on the same node, but switch to after
          this.setBefore( false );
        }
      } else {
        if ( this.trail.indices.length === 0 ) {
          // nothing else to jump to below, so indicate the lack of existence
          this.trail = null;
          // stays isAfter
          return null;
        } else {
          var index = this.trail.indices[this.trail.indices.length - 1];
          this.trail.removeDescendant();
          
          if ( this.trail.lastNode()._children.length > index + 1 ) {
            // more siblings, switch to the beginning of the next one
            this.trail.addDescendant( this.trail.lastNode()._children[index+1], index + 1 );
            this.setBefore( true );
          } else {
            // no more siblings. exit on parent. nothing else needed since we're already isAfter
          }
        }
      }
      return this;
    },
    
    // moves this pointer backwards one step in the nested order
    nestedBackwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.indices.length === 0 ) {
          // jumping off the front
          this.trail = null;
          // stays isBefore
          return null;
        } else {
          var index = this.trail.indices[this.trail.indices.length - 1];
          this.trail.removeDescendant();
          
          if ( index - 1 >= 0 ) {
            // more siblings, switch to the beginning of the previous one and switch to isAfter
            this.trail.addDescendant( this.trail.lastNode()._children[index-1], index - 1 );
            this.setBefore( false );
          } else {
            // no more siblings. enter on parent. nothing else needed since we're already isBefore
          }
        }
      } else {
        if ( this.trail.lastNode()._children.length > 0 ) {
          // stay isAfter, but walk to the last child
          var children = this.trail.lastNode()._children;
          this.trail.addDescendant( children[children.length-1], children.length - 1 );
        } else {
          // switch to isBefore, since this is a leaf node
          this.setBefore( true );
        }
      }
      return this;
    },
    
    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
    eachNodeBetween: function( other, callback ) {
      this.eachTrailBetween( other, function( trail ) {
        return callback( trail.lastNode() );
      } );
    },
    
    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
    eachTrailBetween: function( other, callback ) {
      // this should trigger on all pointers that have the 'before' flag, except a pointer equal to 'other'.
      
      // since we exclude endpoints in the depthFirstUntil call, we need to fire this off first
      if ( this.isBefore ) {
        callback( this.trail );
      }
      
      this.depthFirstUntil( other, function( pointer ) {
        if ( pointer.isBefore ) {
          return callback( pointer.trail );
        }
      }, true ); // exclude the endpoints so we can ignore the ending 'before' case
    },
    
    /*
     * Recursively (depth-first) iterates over all pointers between this pointer and 'other', calling
     * callback( pointer ) for each pointer. If excludeEndpoints is truthy, the callback will not be
     * called if pointer is equivalent to this pointer or 'other'.
     *
     * If the callback returns a truthy value, the subtree for the current pointer will be skipped
     * (applies only to before-pointers)
     */
    depthFirstUntil: function( other, callback, excludeEndpoints ) {
      // make sure this pointer is before the other, but allow start === end if we are not excluding endpoints
      assert && assert( this.compareNested( other ) <= ( excludeEndpoints ? -1 : 0 ), 'TrailPointer.depthFirstUntil pointers out of order, possibly in both meanings of the phrase!' );
      assert && assert( this.trail.rootNode() === other.trail.rootNode(), 'TrailPointer.depthFirstUntil takes pointers with the same root' );
      
      // sanity check TODO: remove later
      this.trail.reindex();
      other.trail.reindex();
      
      var pointer = this.copy();
      pointer.trail.setMutable(); // this trail will be modified in the iteration, so references to it may be modified
      
      var first = true;
      
      while ( !pointer.equalsNested( other ) ) {
        assert && assert( pointer.compareNested( other ) !== 1, 'skipped in depthFirstUntil' );
        var skipSubtree = false;
        
        if ( first ) {
          // start point
          if ( !excludeEndpoints ) {
            skipSubtree = callback( pointer );
          }
          first = false;
        } else {
          // between point
          skipSubtree = callback( pointer );
        }
        
        if ( skipSubtree && pointer.isBefore ) {
          // to skip the subtree, we just change to isAfter
          pointer.setBefore( false );
          
          // if we skip a subtree, make sure we don't run past the ending pointer
          if ( pointer.compareNested( other ) === 1 ) {
            break;
          }
        } else {
          pointer.nestedForwards();
        }
      }
      
      // end point
      if ( !excludeEndpoints ) {
        callback( pointer );
      }
    },
    
    toString: function() {
      return '[' + ( this.isBefore ? 'before' : 'after' ) + ' ' + this.trail.toString().slice( 1 );
    }
  };
  
  // same as new TrailPointer( trailA, isBeforeA ).compareNested( new TrailPointer( trailB, isBeforeB ) )
  TrailPointer.compareNested = function( trailA, isBeforeA, trailB, isBeforeB ) {
    var comparison = trailA.compare( trailB );
    
    if ( comparison === 0 ) {
      // if trails are equal, just compare before/after
      if ( isBeforeA === isBeforeB ) {
        return 0;
      } else {
        return isBeforeA ? -1 : 1;
      }
    } else {
      // if one is an extension of the other, the shorter isBefore flag determines the order completely
      if ( trailA.isExtensionOf( trailB ) ) {
        return isBeforeB ? 1 : -1;
      } else if ( trailB.isExtensionOf( trailA ) ) {
        return isBeforeA ? -1 : 1;
      } else {
        // neither is a subtrail of the other, so a straight trail comparison should give the answer
        return comparison;
      }
    }
  };
  
  return TrailPointer;
} );


// Copyright 2002-2013, University of Colorado

/**
 * Feature detection
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Features',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Features = scenery.Features = {};
  
  function supportsDataURLFormatOutput( format ) {
    try {
      var canvas = document.createElement( 'canvas' );
      canvas.width = 1;
      canvas.height = 1;
      var context = canvas.getContext( '2d' );
      context.fillStyle = 'black';
      context.fillRect( 0, 0, 1, 1 );
      var url = canvas.toDataURL( [ format ] );
      
      var target = 'data:' + format;

      return url.slice( 0, target.length ) === target;
    } catch ( e ) {
      return false;
    }
  }
  
  function supportsDataURLFormatOrigin( name, black1x1Url ) {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext( '2d' );
    
    var img = document.createElement( 'img' );
    img.crossOrigin = 'Anonymous'; // maybe setting the CORS attribute will help?
    
    var loadCall = function() {
      try {
        context.drawImage( img, 0, 0 );
        canvas.toDataURL();
        Features[name] = true;
      } catch ( e ) {
        Features[name] = false;
      }
    };
    img.onload = loadCall;
    try {
      img.src = black1x1Url;
      if ( img.complete ) {
        loadCall();
      }
    } catch ( e ) {
      Features[name] = false;
    }
  }
  
  function prefixed( name ) {
    var result = [];
    result.push( name );
    
    // prepare for camel case
    name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );
    
    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe
    result.push( 'moz' + name );
    result.push( 'Moz' + name ); // some prefixes seem to have all-caps?
    result.push( 'webkit' + name );
    result.push( 'ms' + name );
    result.push( 'o' + name );
    
    return result;
  }
  
  function detect( obj, names ) {
    for ( var i = 0; i < names.length; i++ ) {
      if ( obj[names[i]] !== undefined ) {
        return names[i];
      }
    }
    return undefined;
  }
  
  Features.canvasPNGOutput = supportsDataURLFormatOutput( 'image/png' );
  Features.canvasJPEGOutput = supportsDataURLFormatOutput( 'image/jpeg' );
  Features.canvasGIFOutput = supportsDataURLFormatOutput( 'image/gif' );
  Features.canvasICONOutput = supportsDataURLFormatOutput( 'image/x-icon' );
  
  // 1x1 black output from Chrome Canvas in PNG
  supportsDataURLFormatOrigin( 'canvasPNGInput', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==' );
  
  // 1x1 black output from Chrome Canvas in JPEG
  supportsDataURLFormatOrigin( 'canvasJPEGInput', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqKKKAP/2Q==' );
  
  /*
   * This is from the following SVG:
   *
   * <?xml version="1.0"?>
   * <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewport="0 0 1 1" width="1" height="1" >
   *   <rect x="0" y="0" width="1" height="1" rx="0" ry="0" style="fill: black; stroke: none;"></rect>
   * </svg>
   */
  supportsDataURLFormatOrigin( 'canvasSVGInput', 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3cG9ydD0iMCAwIDEgMSIgd2lkdGg9IjEiIGhlaWdodD0iMSIgPg0KICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiByeD0iMCIgcnk9IjAiIHN0eWxlPSJmaWxsOiBibGFjazsgc3Ryb2tlOiBub25lOyI+PC9yZWN0Pg0KPC9zdmc+DQo=' );
  
  // 1x1 black output from Photoshop in GIF
  supportsDataURLFormatOrigin( 'canvasGIFInput', 'data:image/gif;base64,R0lGODlhAQABAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAABAAEAAAICRAEAOw==' );
  
  // canvas prefixed names
  var canvas = document.createElement( 'canvas' );
  var ctx = canvas.getContext( '2d' );
  Features.toDataURLHD = detect( canvas, prefixed( 'toDataURLHD' ) );
  Features.createImageDataHD = detect( ctx, prefixed( 'createImageDataHD' ) );
  Features.getImageDataHD = detect( ctx, prefixed( 'getImageDataHD' ) );
  Features.putImageDataHD = detect( ctx, prefixed( 'putImageDataHD' ) );
  Features.currentTransform = detect( ctx, prefixed( 'currentTransform' ) );
  
  var span = document.createElement( 'span' );
  var div = document.createElement( 'div' );
  Features.textStroke = detect( span.style, prefixed( 'textStroke' ) );
  Features.textStrokeColor = detect( span.style, prefixed( 'textStrokeColor' ) );
  Features.textStrokeWidth = detect( span.style, prefixed( 'textStrokeWidth' ) );
  
  Features.transform = detect( div.style, prefixed( 'transform' ) );
  Features.transformOrigin = detect( div.style, prefixed( 'transformOrigin' ) );
  Features.backfaceVisibility = detect( div.style, prefixed( 'backfaceVisibility' ) );
  Features.borderRadius = detect( div.style, prefixed( 'borderRadius' ) );
  
  return Features;
} );

// Copyright 2002-2013, University of Colorado

/**
 * General utility functions for Scenery
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Util',['require','SCENERY/scenery','DOT/Matrix3','DOT/Transform3','DOT/Bounds2','DOT/Vector2','SCENERY/util/Features'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Features = require( 'SCENERY/util/Features' );
  
  // convenience function
  function p( x, y ) {
    return new Vector2( x, y );
  }
  
  // TODO: remove flag and tests after we're done
  var debugChromeBoundsScanning = false;
  
  // detect properly prefixed transform and transformOrigin properties
  var transformProperty = Features.transform;
  var transformOriginProperty = Features.transformOrigin || 'transformOrigin'; // fallback, so we don't try to set an empty string property later
  
  scenery.Util = {
    // like _.extend, but with hardcoded support for https://github.com/documentcloud/underscore/pull/986
    extend: function( obj ) {
      _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
        if ( source ) {
          for ( var prop in source ) {
            Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
          }
        }
      });
      return obj;
    },
    
    // Object.create polyfill
    objectCreate: Object.create || function ( o ) {
      if ( arguments.length > 1 ) {
        throw new Error( 'Object.create implementation only accepts the first parameter.' );
      }
      function F() {}

      F.prototype = o;
      return new F();
    },
    
    applyCSSTransform: function( matrix, element, forceAcceleration ) {
      var transformCSS = matrix.getCSSTransform();
      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/
      
      if ( forceAcceleration ) {
        element.style.webkitBackfaceVisibility = 'hidden';
        transformCSS += ' translateZ(0)';
      }
      
      element.style[transformProperty] = transformCSS;
      element.style[transformOriginProperty] = 'top left'; // TODO: performance: this only needs to be set once!
    },
    
    testAssert: function() {
      return 'assert.basic: ' + ( assert ? 'true' : 'false' );
    },
    
    testAssertExtra: function() {
      return 'assert.slow: ' + ( assertSlow ? 'true' : 'false' );
    },
    
    /*---------------------------------------------------------------------------*
     * window.requestAnimationFrame polyfill, by Erik Moller (http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating)
     * referenced by initial Paul Irish article at http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     *----------------------------------------------------------------------------*/
    polyfillRequestAnimationFrame: function() {
      var lastTime = 0;
      var vendors = [ 'ms', 'moz', 'webkit', 'o' ];
      for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
      }
     
      if ( !window.requestAnimationFrame ) {
        window.requestAnimationFrame = function(callback) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = window.setTimeout(function() { callback(currTime + timeToCall); },
            timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
     
      if ( !window.cancelAnimationFrame ) {
        window.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      }
    },
    
    backingStorePixelRatio: function( context ) {
      return context.webkitBackingStorePixelRatio ||
             context.mozBackingStorePixelRatio ||
             context.msBackingStorePixelRatio ||
             context.oBackingStorePixelRatio ||
             context.backingStorePixelRatio || 1;
    },
    
    // see http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html#//apple_ref/doc/uid/TP40010542-CH2-SW5
    // and updated based on http://www.html5rocks.com/en/tutorials/canvas/hidpi/
    backingScale: function ( context ) {
      if ( 'devicePixelRatio' in window ) {
        var backingStoreRatio = Util.backingStorePixelRatio( context );
        
        return window.devicePixelRatio / backingStoreRatio;
      }
      return 1;
    },
    
    // given a data snapshot and transform, calculate range on how large / small the bounds can be
    // very conservative, with an effective 1px extra range to allow for differences in anti-aliasing
    // for performance concerns, this does not support skews / rotations / anything but translation and scaling
    scanBounds: function( imageData, resolution, transform ) {
      
      // entry will be true if any pixel with the given x or y value is non-rgba(0,0,0,0)
      var dirtyX = _.map( _.range( resolution ), function() { return false; } );
      var dirtyY = _.map( _.range( resolution ), function() { return false; } );
      
      for ( var x = 0; x < resolution; x++ ) {
        for ( var y = 0; y < resolution; y++ ) {
          var offset = 4 * ( y * resolution + x );
          if ( imageData.data[offset] !== 0 || imageData.data[offset+1] !== 0 || imageData.data[offset+2] !== 0 || imageData.data[offset+3] !== 0 ) {
            dirtyX[x] = true;
            dirtyY[y] = true;
          }
        }
      }
      
      var minX = _.indexOf( dirtyX, true );
      var maxX = _.lastIndexOf( dirtyX, true );
      var minY = _.indexOf( dirtyY, true );
      var maxY = _.lastIndexOf( dirtyY, true );
      
      // based on pixel boundaries. for minBounds, the inner edge of the dirty pixel. for maxBounds, the outer edge of the adjacent non-dirty pixel
      // results in a spread of 2 for the identity transform (or any translated form)
      var extraSpread = resolution / 16; // is Chrome antialiasing really like this? dear god... TODO!!!
      return {
        minBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( minX + 1 + extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, minY + 1 + extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( maxX - extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, maxY - extraSpread ) ).y
        ),
        maxBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( minX - 1 - extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, minY - 1 - extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( maxX + 2 + extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, maxY + 2 + extraSpread ) ).y
        )
      };
    },
    
    canvasAccurateBounds: function( renderToContext, options ) {
      // how close to the actual bounds do we need to be?
      var precision = ( options && options.precision ) ? options.precision : 0.001;
      
      // 512x512 default square resolution
      var resolution = ( options && options.resolution ) ? options.resolution : 128;
      
      // at 1/16x default, we want to be able to get the bounds accurately for something as large as 16x our initial resolution
      // divisible by 2 so hopefully we avoid more quirks from Canvas rendering engines
      var initialScale = ( options && options.initialScale ) ? options.initialScale : (1/16);
      
      var minBounds = Bounds2.NOTHING;
      var maxBounds = Bounds2.EVERYTHING;
      
      var canvas = document.createElement( 'canvas' );
      canvas.width = resolution;
      canvas.height = resolution;
      var context = canvas.getContext( '2d' );
      
      if ( debugChromeBoundsScanning ) {
        $( window ).ready( function() {
          var header = document.createElement( 'h2' );
          $( header ).text( 'Bounds Scan' );
          $( '#display' ).append( header );
        } );
      }
      
      function scan( transform ) {
        // save/restore, in case the render tries to do any funny stuff like clipping, etc.
        context.save();
        transform.matrix.canvasSetTransform( context );
        renderToContext( context );
        context.restore();
        
        var data = context.getImageData( 0, 0, resolution, resolution );
        var minMaxBounds = Util.scanBounds( data, resolution, transform );
        
        function snapshotToCanvas( snapshot ) {
            var canvas = document.createElement( 'canvas' );
            canvas.width = resolution;
            canvas.height = resolution;
            var context = canvas.getContext( '2d' );
            context.putImageData( snapshot, 0, 0 );
            $( canvas ).css( 'border', '1px solid black' );
            $( window ).ready( function() {
              //$( '#display' ).append( $( document.createElement( 'div' ) ).text( 'Bounds: ' +  ) );
              $( '#display' ).append( canvas );
            } );
          }
        
        // TODO: remove after debug
        if ( debugChromeBoundsScanning ) {
          snapshotToCanvas( data );
        }
        
        context.clearRect( 0, 0, resolution, resolution );
        
        return minMaxBounds;
      }
      
      // attempts to map the bounds specified to the entire testing canvas (minus a fine border), so we can nail down the location quickly
      function idealTransform( bounds ) {
        // so that the bounds-edge doesn't land squarely on the boundary
        var borderSize = 2;
        
        var scaleX = ( resolution - borderSize * 2 ) / ( bounds.maxX - bounds.minX );
        var scaleY = ( resolution - borderSize * 2 ) / ( bounds.maxY - bounds.minY );
        var translationX = -scaleX * bounds.minX + borderSize;
        var translationY = -scaleY * bounds.minY + borderSize;
        
        return new Transform3( Matrix3.translation( translationX, translationY ).timesMatrix( Matrix3.scaling( scaleX, scaleY ) ) );
      }
      
      var initialTransform = new Transform3( );
      // make sure to initially center our object, so we don't miss the bounds
      initialTransform.append( Matrix3.translation( resolution / 2, resolution / 2 ) );
      initialTransform.append( Matrix3.scaling( initialScale ) );
      
      var coarseBounds = scan( initialTransform );
      
      minBounds = minBounds.union( coarseBounds.minBounds );
      maxBounds = maxBounds.intersection( coarseBounds.maxBounds );
      
      var tempMin, tempMax, refinedBounds;
      
      // minX
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.minX ) && isFinite( maxBounds.minX ) && Math.abs( minBounds.minX - maxBounds.minX ) > precision ) {
        // use maximum bounds except for the x direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( maxBounds.minX, tempMin, minBounds.minX, tempMax ) ) );
        
        if ( minBounds.minX <= refinedBounds.minBounds.minX && maxBounds.minX >= refinedBounds.maxBounds.minX ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
            console.log( 'transformed "min" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( minBounds.minX, 0 ) ) );
            console.log( 'transformed "max" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( maxBounds.minX, 0 ) ) );
          }
          break;
        }
        
        minBounds = minBounds.withMinX( Math.min( minBounds.minX, refinedBounds.minBounds.minX ) );
        maxBounds = maxBounds.withMinX( Math.max( maxBounds.minX, refinedBounds.maxBounds.minX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }
      
      // maxX
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.maxX ) && isFinite( maxBounds.maxX ) && Math.abs( minBounds.maxX - maxBounds.maxX ) > precision ) {
        // use maximum bounds except for the x direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( minBounds.maxX, tempMin, maxBounds.maxX, tempMax ) ) );
        
        if ( minBounds.maxX >= refinedBounds.minBounds.maxX && maxBounds.maxX <= refinedBounds.maxBounds.maxX ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }
        
        minBounds = minBounds.withMaxX( Math.max( minBounds.maxX, refinedBounds.minBounds.maxX ) );
        maxBounds = maxBounds.withMaxX( Math.min( maxBounds.maxX, refinedBounds.maxBounds.maxX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }
      
      // minY
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.minY ) && isFinite( maxBounds.minY ) && Math.abs( minBounds.minY - maxBounds.minY ) > precision ) {
        // use maximum bounds except for the y direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, maxBounds.minY, tempMax, minBounds.minY ) ) );
        
        if ( minBounds.minY <= refinedBounds.minBounds.minY && maxBounds.minY >= refinedBounds.maxBounds.minY ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }
        
        minBounds = minBounds.withMinY( Math.min( minBounds.minY, refinedBounds.minBounds.minY ) );
        maxBounds = maxBounds.withMinY( Math.max( maxBounds.minY, refinedBounds.maxBounds.minY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }
      
      // maxY
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.maxY ) && isFinite( maxBounds.maxY ) && Math.abs( minBounds.maxY - maxBounds.maxY ) > precision ) {
        // use maximum bounds except for the y direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, minBounds.maxY, tempMax, maxBounds.maxY ) ) );
        
        if ( minBounds.maxY >= refinedBounds.minBounds.maxY && maxBounds.maxY <= refinedBounds.maxBounds.maxY ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }
        
        minBounds = minBounds.withMaxY( Math.max( minBounds.maxY, refinedBounds.minBounds.maxY ) );
        maxBounds = maxBounds.withMaxY( Math.min( maxBounds.maxY, refinedBounds.maxBounds.maxY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }
      
      if ( debugChromeBoundsScanning ) {
        console.log( 'minBounds: ' + minBounds );
        console.log( 'maxBounds: ' + maxBounds );
      }
      
      var result = new Bounds2(
        ( minBounds.minX + maxBounds.minX ) / 2,
        ( minBounds.minY + maxBounds.minY ) / 2,
        ( minBounds.maxX + maxBounds.maxX ) / 2,
        ( minBounds.maxY + maxBounds.maxY ) / 2
      );
      
      // extra data about our bounds
      result.minBounds = minBounds;
      result.maxBounds = maxBounds;
      result.isConsistent = maxBounds.containsBounds( minBounds );
      result.precision = Math.max(
        Math.abs( minBounds.minX - maxBounds.minX ),
        Math.abs( minBounds.minY - maxBounds.minY ),
        Math.abs( minBounds.maxX - maxBounds.maxX ),
        Math.abs( minBounds.maxY - maxBounds.maxY )
      );
      
      // return the average
      return result;
    }
  };
  var Util = scenery.Util;
  
  return Util;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A Canvas-backed layer in the scene graph. Each layer handles dirty-region handling separately,
 * and corresponds to a single canvas / svg element / DOM element in the main container.
 * Importantly, it does not contain rendered content from a subtree of the main
 * scene graph. It only will render a contiguous block of nodes visited in a depth-first
 * manner.
 *
 * Backing store pixel ratio info: http://www.html5rocks.com/en/tutorials/canvas/hidpi/
 *
 * TODO: update internal documentation
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/CanvasLayer',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','KITE/Shape','SCENERY/layers/Layer','SCENERY/util/CanvasContextWrapper','SCENERY/util/Trail','SCENERY/util/TrailPointer','SCENERY/util/Util'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Shape = require( 'KITE/Shape' );
  
  var Layer = require( 'SCENERY/layers/Layer' ); // uses Layer's prototype for inheritance
  require( 'SCENERY/util/CanvasContextWrapper' );
  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/util/TrailPointer' );
  require( 'SCENERY/util/Util' );
  
  // stores CanvasContextWrappers to be re-used
  var canvasContextPool = [];
  
  // assumes main is wrapped with JQuery
  /*
   *
   */
  scenery.CanvasLayer = function CanvasLayer( args ) {
    sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' constructor' );
    Layer.call( this, args );
    
    // TODO: deprecate Scene's backing scale, and handle this on a layer-by-layer option?
    this.backingScale = args.scene.backingScale;
    if ( args.fullResolution !== undefined ) {
      this.backingScale = args.fullResolution ? scenery.Util.backingScale( document.createElement( 'canvas' ).getContext( '2d' ) ) : 1;
    }
    
    this.logicalWidth = this.scene.sceneBounds.width;
    this.logicalHeight = this.scene.sceneBounds.height;
    
    var canvas = document.createElement( 'canvas' );
    canvas.width = this.logicalWidth * this.backingScale;
    canvas.height = this.logicalHeight * this.backingScale;
    canvas.style.width = this.logicalWidth + 'px';
    canvas.style.height = this.logicalHeight + 'px';
    canvas.style.position = 'absolute';
    canvas.style.left = '0';
    canvas.style.top = '0';
    
    // add this layer on top (importantly, the constructors of the layers are called in order)
    this.$main.append( canvas );
    
    this.canvas = canvas;
    // this.context = new DebugContext( canvas.getContext( '2d' ) );
    this.context = canvas.getContext( '2d' );
    this.scene = args.scene;
    
    // workaround for Chrome (WebKit) miterLimit bug: https://bugs.webkit.org/show_bug.cgi?id=108763
    this.context.miterLimit = 20;
    this.context.miterLimit = 10;
    
    this.isCanvasLayer = true;
    
    this.wrapper = new scenery.CanvasContextWrapper( this.canvas, this.context );
    
    this.boundlessCount = 0; // count of how many trails do not support bounds. we only will use dirty region repainting if this number is 0.
  };
  var CanvasLayer = scenery.CanvasLayer;
  
  inherit( Layer, CanvasLayer, {
    
    /*
     * Renders the canvas layer from the scene
     *
     * Supported args: {
     *   fullRender: true, // disables drawing to just dirty rectangles
     *   TODO: pruning with bounds and flag to disable
     * }
     */
    render: function( scene, args ) {
      args = args || {};
      
      var dirtyBoundsEnabled = this.canUseDirtyRegions() && !args.fullRender;
      
      // bail out quickly if possible
      if ( dirtyBoundsEnabled && this.dirtyBounds.isEmpty() ) {
        return;
      }
      
      // switch to an identity transform
      this.context.setTransform( this.backingScale, 0, 0, this.backingScale, 0, 0 );
      
      var visibleDirtyBounds = dirtyBoundsEnabled ? this.dirtyBounds.intersection( scene.sceneBounds ) : scene.sceneBounds;
      
      if ( !visibleDirtyBounds.isEmpty() ) {
        this.clearGlobalBounds( visibleDirtyBounds );
        
        if ( dirtyBoundsEnabled ) {
          this.pushClipShape( Shape.bounds( visibleDirtyBounds ) );
        }
        
        // dirty bounds (clear, possibly set restricted bounds and handling for that)
        // visibility checks
        this.recursiveRender( scene, args );
        
        // exists for now so that we pop the necessary context state
        if ( dirtyBoundsEnabled ) {
          this.popClipShape();
        }
      }
      
      // we rendered everything, no more dirty bounds
      this.dirtyBounds = Bounds2.NOTHING;
    },
    
    recursiveRender: function( scene, args ) {
      var layer = this;
      var i;
      var startPointer = new scenery.TrailPointer( this.startPaintedTrail, true );
      var endPointer = new scenery.TrailPointer( this.endPaintedTrail, true );
      
      // stack for canvases that need to be painted, since some effects require scratch canvases
      var wrapperStack = [ this.wrapper ]; // type {CanvasContextWrapper}
      this.wrapper.resetStyles(); // let's be defensive, save() and restore() may have been called previously
      
      function requiresScratchCanvas( trail ) {
        return trail.lastNode().getOpacity() < 1;
      }
      
      function getCanvasWrapper() {
        var width = layer.logicalWidth * layer.backingScale;
        var height = layer.logicalHeight * layer.backingScale;
        
        if ( canvasContextPool.length ) {
          // use a pooled wrapper
          var wrapper = canvasContextPool.pop();
          wrapper.setDimensions( width, height );
          return wrapper;
        } else {
          // create a new wrapper
          var canvas = document.createElement( 'canvas' );
          canvas.width = layer.logicalWidth * layer.backingScale;
          canvas.height = layer.logicalHeight * layer.backingScale;
          var context = canvas.getContext( '2d' );
          
          return new scenery.CanvasContextWrapper( canvas, context );
        }
      }
      
      function topWrapper() {
        return wrapperStack[wrapperStack.length-1];
      }
      
      function enter( trail ) {
        var node = trail.lastNode();
        
        if ( requiresScratchCanvas( trail ) ) {
          var wrapper = getCanvasWrapper();
          wrapperStack.push( wrapper );
          
          var newContext = wrapper.context;
          
          // switch to an identity transform
          newContext.setTransform( layer.backingScale, 0, 0, layer.backingScale, 0, 0 );
          
          // properly set the necessary transform on the context
          var length = trail.nodes.length;
          for ( var i = 0; i < length; i++ ) {
            trail.nodes[i].transform.getMatrix().canvasAppendTransform( newContext );
          }
        } else {
          node.transform.getMatrix().canvasAppendTransform( topWrapper().context );
        }
        
        if ( node._clipArea ) {
          // TODO: move to wrapper-specific part
          layer.pushClipShape( node._clipArea );
        }
      }
      
      function exit( trail ) {
        var node = trail.lastNode();
        
        if ( node._clipArea ) {
          // TODO: move to wrapper-specific part
          layer.popClipShape();
        }
        
        if ( requiresScratchCanvas( trail ) ) {
          var baseContext = wrapperStack[wrapperStack.length-2].context;
          var topCanvas = wrapperStack[wrapperStack.length-1].canvas;
          
          // apply necessary style transforms before painting our popped canvas onto the next canvas
          var opacityChange = trail.lastNode().getOpacity() < 1;
          if ( opacityChange ) {
            baseContext.globalAlpha = trail.lastNode().getOpacity();
          }
          
          // paint our canvas onto the level below with a straight transform
          baseContext.save();
          baseContext.setTransform( 1, 0, 0, 1, 0, 0 );
          baseContext.drawImage( topCanvas, 0, 0 );
          baseContext.restore();
          
          // reset styles
          if ( opacityChange ) {
            baseContext.globalAlpha = 1;
          }
          
          var wrapper = wrapperStack.pop();
          if ( wrapper !== layer.wrapper ) {
            // store the CanvasContextWrapper for recycling if it isn't our core wrapper
            canvasContextPool.push( wrapper );
          }
        } else {
          node.transform.getInverse().canvasAppendTransform( topWrapper().context );
        }
      }
      
      /*
       * We count how many invisible nodes are in our trail, so we can properly iterate without inspecting everything.
       * Additionally, state changes (enter/exit) are only done when nodes are visible, so we skip overhead. If
       * invisibleCount > 0, then the current node is invisible.
       */
      var invisibleCount = 0;
      
      var boundaryTrail;
      
      // sanity check, and allows us to get faster speed
      startPointer.trail.reindex();
      endPointer.trail.reindex();
      
      // first, we need to walk the state up to before our pointer (as far as the recursive handling is concerned)
      // if the pointer is 'before' the node, don't call its enterState since this will be taken care of as the first step.
      // if the pointer is 'after' the node, call enterState since it will call exitState immediately inside the loop
      var startWalkLength = startPointer.trail.length - ( startPointer.isBefore ? 1 : 0 );
      boundaryTrail = new scenery.Trail();
      for ( i = 0; i < startWalkLength; i++ ) {
        var startNode = startPointer.trail.nodes[i];
        boundaryTrail.addDescendant( startNode );
        invisibleCount += startNode.isVisible() ? 0 : 1;
        
        if ( invisibleCount === 0 ) {
          // walk up initial state
          enter( boundaryTrail );
        }
      }
      
      startPointer.depthFirstUntil( endPointer, function renderPointer( pointer ) {
        // handle render here
        
        var node = pointer.trail.lastNode();
        
        if ( pointer.isBefore ) {
          invisibleCount += node.isVisible() ? 0 : 1;
          
          if ( invisibleCount === 0 ) {
            enter( pointer.trail );
            
            if ( node.isPainted() ) {
              var wrapper = wrapperStack[wrapperStack.length-1];
              
              // TODO: consider just passing the wrapper. state not needed (for now), context easily accessible
              node.paintCanvas( wrapper );
            }
            
            // TODO: restricted bounds rendering, and possibly generalize depthFirstUntil
            // var children = node._children;
            
            // check if we need to filter the children we render, and ignore nodes with few children (but allow 2, since that may prevent branches)
            // if ( state.childRestrictedBounds && children.length > 1 ) {
            //   var localRestrictedBounds = node.globalToLocalBounds( state.childRestrictedBounds );
              
            //   // don't filter if every child is inside the bounds
            //   if ( !localRestrictedBounds.containsBounds( node.parentToLocalBounds( node._bounds ) ) ) {
            //     children = node.getChildrenWithinBounds( localRestrictedBounds );
            //   }
            // }
            
            // _.each( children, function( child ) {
            //   fullRender( child, state );
            // } );
          } else {
            // not visible, so don't render the entire subtree
            return true;
          }
        } else {
          if ( invisibleCount === 0 ) {
            exit( pointer.trail );
          }
          
          invisibleCount -= node.isVisible() ? 0 : 1;
        }
        
      }, false ); // include endpoints (for now)
      
      // then walk the state back so we don't muck up any context saving that is going on, similar to how we walked it at the start
      // if the pointer is 'before' the node, call exitState since it called enterState inside the loop on it
      // if the pointer is 'after' the node, don't call its exitState since this was already done
      boundaryTrail = endPointer.trail.copy();
      var endWalkLength = endPointer.trail.length - ( endPointer.isAfter ? 1 : 0 );
      for ( i = endWalkLength - 1; i >= 0; i-- ) {
        var endNode = endPointer.trail.nodes[i];
        invisibleCount -= endNode.isVisible() ? 0 : 1;
        
        if ( invisibleCount === 0 ) {
          // walk back the state
          exit( boundaryTrail );
        }
        
        boundaryTrail.removeDescendant();
      }
    },
    
    dispose: function() {
      Layer.prototype.dispose.call( this );
      
      this.canvas.parentNode.removeChild( this.canvas );
    },
    
    // TODO: consider a stack-based model for transforms?
    applyTransformationMatrix: function( matrix ) {
      matrix.canvasAppendTransform( this.context );
    },
    
    // returns next zIndex in place. allows layers to take up more than one single zIndex
    reindex: function( zIndex ) {
      Layer.prototype.reindex.call( this, zIndex );
      
      if ( this.zIndex !== zIndex ) {
        this.canvas.style.zIndex = zIndex;
        this.zIndex = zIndex;
      }
      return zIndex + 1;
    },
    
    pushClipShape: function( shape ) {
      // store the current state, since browser support for context.resetClip() is not yet in the stable browser versions
      this.context.save();
      
      this.writeClipShape( shape );
    },
    
    popClipShape: function() {
      this.context.restore();
    },
    
    // canvas-specific
    writeClipShape: function( shape ) {
      // set up the clipping
      this.context.beginPath();
      shape.writeToContext( this.context );
      this.context.clip();
    },
    
    clearGlobalBounds: function( bounds ) {
      if ( !bounds.isEmpty() ) {
        this.context.save();
        this.context.setTransform( this.backingScale, 0, 0, this.backingScale, 0, 0 );
        this.context.clearRect( bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight() );
        // use this for debugging cleared (dirty) regions for now
        // this.context.fillStyle = '#' + Math.floor( Math.random() * 0xffffff ).toString( 16 );
        // this.context.fillRect( bounds.x, bounds.y, bounds.width, bounds.height );
        this.context.restore();
      }
    },
    
    getSVGString: function() {
      return '<image xmlns:xlink="' + scenery.xlinkns + '" xlink:href="' + this.canvas.toDataURL() + '" x="0" y="0" height="' + this.canvas.height + 'px" width="' + this.canvas.width + 'px"/>';
    },
    
    // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas
    renderToCanvas: function( canvas, context, delayCounts ) {
      context.drawImage( this.canvas, 0, 0 );
    },
    
    addInstance: function( instance ) {
      var trail = instance.trail;
      
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' addInstance: ' + trail.toString() );
      Layer.prototype.addInstance.call( this, instance );
      
      // since the node's getBounds() are in the parent coordinate frame, we peel off the last node to get the correct (relevant) transform
      // TODO: more efficient way of getting this transform?
      this.canvasMarkLocalBounds( trail.lastNode().getBounds(), trail.slice( 0, trail.length - 1 ) );
      
      if ( trail.lastNode().boundsInaccurate ) {
        this.boundlessCount++;
      }
    },
    
    removeInstance: function( instance ) {
      var trail = instance.trail;
      
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' removeInstance: ' + trail.toString() );
      Layer.prototype.removeInstance.call( this, instance );
      
      // since the node's getBounds() are in the parent coordinate frame, we peel off the last node to get the correct (relevant) transform
      // TODO: more efficient way of getting this transform?
      this.canvasMarkLocalBounds( trail.lastNode().getBounds(), trail.slice( 0, trail.length - 1 ) );
      
      if ( trail.lastNode().boundsInaccurate ) {
        this.boundlessCount--;
      }
    },
    
    canUseDirtyRegions: function() {
      assert && assert( this.boundlessCount >= 0 );
      return this.boundlessCount === 0;
    },
    
    // NOTE: for performance, we will mutate the bounds passed in (they are almost assuredly from the local or parent bounds functions)
    canvasMarkGlobalBounds: function( globalBounds ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkGlobalBounds: ' + globalBounds.toString() );
      assert && assert( globalBounds.isEmpty() || globalBounds.isFinite(), 'Infinite (non-empty) dirty bounds passed to canvasMarkGlobalBounds' );
      
      // TODO: for performance, consider more than just a single dirty bounding box
      this.dirtyBounds = this.dirtyBounds.union( globalBounds.dilate( 2 ).roundOut() );
    },
    
    canvasMarkLocalBounds: function( localBounds, trail ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkLocalBounds: ' + localBounds.toString() + ' on ' + trail.toString() );
      if ( !this.canUseDirtyRegions() ) {
        this.dirtyBounds = Bounds2.EVERYTHING;
      } else {
        this.canvasMarkGlobalBounds( trail.localToGlobalBounds( localBounds ) );
      }
    },
    
    canvasMarkParentBounds: function( parentBounds, trail ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkParentBounds: ' + parentBounds.toString() + ' on ' + trail.toString() );
      if ( !this.canUseDirtyRegions() ) {
        this.dirtyBounds = Bounds2.EVERYTHING;
      } else {
        this.canvasMarkGlobalBounds( trail.parentToGlobalBounds( parentBounds ) );
      }
    },
    
    canvasMarkSelf: function( instance ) {
      this.canvasMarkLocalBounds( instance.getNode().getSelfBounds(), instance.trail );
    },
    
    canvasMarkSubtree: function( instance ) {
      this.canvasMarkParentBounds( instance.getNode().getBounds(), instance.trail );
    },
    
    getName: function() {
      return 'canvas';
    },
    
    /*---------------------------------------------------------------------------*
    * Events from Instances
    *----------------------------------------------------------------------------*/
    
    notifyVisibilityChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );
      // old paint taken care of in notifyBeforeSubtreeChange()
      
      if ( instance.trail.isVisible() ) {
        this.canvasMarkSubtree( instance );
      }
    },
    
    notifyOpacityChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );
      // old paint taken care of in notifyBeforeSubtreeChange()
      
      this.canvasMarkSubtree( instance );
    },
    
    notifyClipChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyClipChange: ' + instance.trail.toString() );
      // old paint taken care of in notifyBeforeSubtreeChange()
      
      this.canvasMarkSubtree( instance );
    },
    
    // only a painted trail under this layer
    notifyBeforeSelfChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );
      this.canvasMarkSelf( instance );
    },
    
    notifyBeforeSubtreeChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );
      this.canvasMarkSubtree( instance );
    },
    
    // only a painted trail under this layer
    notifyDirtySelfPaint: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );
      this.canvasMarkSelf( instance );
    },
    
    notifyDirtySubtreePaint: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyDirtySubtreePaint: ' + instance.trail.toString() );
      this.canvasMarkSubtree( instance );
    },
    
    notifyTransformChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );
      // TODO: how best to mark this so if there are multiple 'movements' we don't get called more than needed?
      // this.canvasMarkSubtree( instance );
    },
    
    // only a painted trail under this layer (for now)
    notifyBoundsAccuracyChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );
      
      if ( instance.node.boundsInaccurate ) {
        this.boundlessCount++;
      } else {
        this.boundlessCount--;
      }
    }
  } );
  
  return CanvasLayer;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A DOM-based layer in the scene graph. Each layer handles dirty-region handling separately,
 * and corresponds to a single canvas / svg element / DOM element in the main container.
 * Importantly, it does not contain rendered content from a subtree of the main
 * scene graph. It only will render a contiguous block of nodes visited in a depth-first
 * manner.
 *
 * Nodes supporting the DOM renderer should have the following functions:
 *   allowsMultipleDOMInstances:               {Boolean} whether getDOMElement will return the same element every time, or new elements.
 *   getDOMElement():                          Returns a DOM element that represents this node.
 *   updateDOMElement( element ):              Updates the DOM element with any changes that were made.
 *   updateCSSTransform( transform, element ): Updates the CSS transform of the element
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/DOMLayer',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/layers/Layer','SCENERY/util/Trail'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );

  var scenery = require( 'SCENERY/scenery' );
  
  var Layer = require( 'SCENERY/layers/Layer' ); // DOMLayer inherits from Layer
  require( 'SCENERY/util/Trail' );
  
  scenery.DOMLayer = function DOMLayer( args ) {
    sceneryLayerLog && sceneryLayerLog( 'DOMLayer constructor' );
    
    Layer.call( this, args );
    
    var width = args.scene.sceneBounds.width;
    var height = args.scene.sceneBounds.height;
    
    this.div = document.createElement( 'div' );
    var div = this.div;
    div.style.position = 'absolute';
    div.style.left = '0';
    div.style.top = '0';
    div.style.width = '0';
    div.style.height = '0';
    div.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
    this.$div = $( this.div );
    this.$main.append( this.div );
    
    this.scene = args.scene; // TODO: should already be set in the supertype Layer
    
    this.isDOMLayer = true;
    
    // maps trail ID => DOM element fragment
    this.idElementMap = {};
    
    // maps trail ID => Trail. trails need to be reindexed
    this.idTrailMap = {};
    
    this.trails = [];
  };
  var DOMLayer = scenery.DOMLayer;
  
  inherit( Layer, DOMLayer, {
    
    addInstance: function( instance ) {
      Layer.prototype.addInstance.call( this, instance );
      
      var trail = instance.trail;
      this.reindexTrails();
      
      var node = trail.lastNode();
      
      var element = node.getDOMElement();
      node.updateDOMElement( element );
      this.updateVisibility( trail, element );
      
      this.idElementMap[trail.getUniqueId()] = element;
      this.idTrailMap[trail.getUniqueId()] = trail;
      
      // walk the insertion index up the array. TODO: performance: binary search version?
      var insertionIndex;
      for ( insertionIndex = 0; insertionIndex < this.trails.length; insertionIndex++ ) {
        var otherTrail = this.trails[insertionIndex];
        otherTrail.reindex();
        var comparison = otherTrail.compare( trail );
        assert && assert( comparison !== 0, 'Trail has already been inserted into the DOMLayer' );
        if ( comparison === 1 ) { // TODO: enum values!
          break;
        }
      }
      
      if ( insertionIndex === this.div.childNodes.length ) {
        this.div.appendChild( element );
        this.trails.push( trail );
      } else {
        this.div.insertBefore( this.getElementFromTrail( this.trails[insertionIndex] ) );
        this.trails.splice( insertionIndex, 0, trail );
      }
      node.updateCSSTransform( trail.getTransform(), element );
    },
    
    removeInstance: function( instance ) {
      Layer.prototype.removeInstance.call( this, instance );
      
      var trail = instance.trail;
      this.reindexTrails();
      
      var element = this.getElementFromTrail( trail );
      assert && assert( element, 'Trail does not exist in the DOMLayer' );
      
      delete this.idElementMap[trail.getUniqueId];
      delete this.idTrailMap[trail.getUniqueId];
      
      this.div.removeChild( element );
      
      var removalIndex = this.getIndexOfTrail( trail );
      this.trails.splice( removalIndex, 1 );
    },
    
    getElementFromTrail: function( trail ) {
      return this.idElementMap[trail.getUniqueId()];
    },
    
    reindexTrails: function( zIndex ) {
      Layer.prototype.reindex.call( this, zIndex );
      
      var i = this.trails.length;
      while ( i-- ) {
        this.trails[i].reindex();
      }
    },
    
    getIndexOfTrail: function( trail ) {
      // find the index where our trail is at. strict equality won't work, we want to compare differently
      var i;
      for ( i = 0; i < this.trails.length; i++ ) {
        if ( this.trails[i].compare( trail ) === 0 ) {
          return i;
        }
      }
      throw new Error( 'DOMLayer.getIndexOfTrail unable to find trail: ' + trail.toString() );
    },
    
    render: function( scene, args ) {
      // nothing at all needed here, CSS transforms taken care of when dirty regions are notified
    },
    
    dispose: function() {
      Layer.prototype.dispose.call( this );
      
      this.div.parentNode.removeChild( this.div );
    },
    
    updateVisibility: function( trail, element ) {
      if ( trail.isVisible() ) {
        element.style.visibility = 'visible';
      } else {
        element.style.visibility = 'hidden';
      }
    },
    
    // TODO: consider a stack-based model for transforms?
    // TODO: deprecated? remove this?
    applyTransformationMatrix: function( matrix ) {
      // nothing at all needed here
    },
    
    getContainer: function() {
      return this.div;
    },
    
    // returns next zIndex in place. allows layers to take up more than one single zIndex
    reindex: function( zIndex ) {
      Layer.prototype.reindex.call( this, zIndex );
      
      if ( this.zIndex !== zIndex ) {
        this.div.style.zIndex = zIndex;
        this.zIndex = zIndex;
      }
      return zIndex + 1;
    },
    
    pushClipShape: function( shape ) {
      // TODO: clipping
    },
    
    popClipShape: function() {
      // TODO: clipping
    },
    
    getSVGString: function() {
      return "<svg xmlns='" + scenery.svgns + "' width='" + this.$main.width() + "' height='" + this.$main.height() + "'>" +
        "<foreignObject width='100%' height='100%'>" +
        $( this.div ).html() +
        "</foreignObject></svg>";
    },
    
    // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas
    // TODO: note that http://pbakaus.github.com/domvas/ may work better, but lacks IE support
    renderToCanvas: function( canvas, context, delayCounts ) {
      // TODO: consider not silently failing?
      // var data = "<svg xmlns='" + scenery.svgns + "' width='" + this.$main.width() + "' height='" + this.$main.height() + "'>" +
      //   "<foreignObject width='100%' height='100%'>" +
      //   $( this.div ).html() +
      //   "</foreignObject></svg>";
      
      // var DOMURL = window.URL || window.webkitURL || window;
      // var img = new Image();
      // var svg = new Blob( [ data ] , { type: "image/svg+xml;charset=utf-8" } );
      // var url = DOMURL.createObjectURL( svg );
      // delayCounts.increment();
      // img.onload = function() {
      //   context.drawImage( img, 0, 0 );
      //   // TODO: this loading is delayed!!! ... figure out a solution to potentially delay?
      //   DOMURL.revokeObjectURL( url );
      //   delayCounts.decrement();
      // };
      // img.src = url;
    },
    
    getName: function() {
      return 'dom';
    },
    
    /*---------------------------------------------------------------------------*
    * Events from Instances
    *----------------------------------------------------------------------------*/
    
    notifyVisibilityChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );
      var trail = instance.trail;
      
      // TODO: performance: faster way to iterate through!
      for ( var trailId in this.idTrailMap ) {
        var subtrail = this.idTrailMap[trailId];
        subtrail.reindex();
        if ( subtrail.isExtensionOf( trail, true ) ) {
          this.updateVisibility( subtrail, this.idElementMap[trailId] );
        }
      }
    },
    
    notifyOpacityChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );
      // TODO: BROKEN: FIXME: DOM opacity is not handled yet, see issue #31: https://github.com/phetsims/scenery/issues/31
    },
    
    notifyClipChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyClipChange: ' + instance.trail.toString() );
      // TODO: BROKEN: FIXME: DOM clipping is not handled, see issue #31: https://github.com/phetsims/scenery/issues/31
    },
    
    // only a painted trail under this layer
    notifyBeforeSelfChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );
      // no-op, we don't need paint changes
    },
    
    notifyBeforeSubtreeChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );
      // no-op, we don't need paint changes
    },
    
    // only a painted trail under this layer
    notifyDirtySelfPaint: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );
      var node = instance.getNode();
      var trail = instance.trail;
      
      // TODO: performance: store this in the Instance itself?
      var dirtyElement = this.idElementMap[trail.getUniqueId()];
      if ( dirtyElement ) {
        node.updateDOMElement( dirtyElement );
        
        if ( node.domUpdateTransformOnRepaint ) {
          node.updateCSSTransform( trail.getTransform(), dirtyElement );
        }
      }
    },

    notifyDirtySubtreePaint: function( instance ) {
      if ( instance.layer === this ) {
        this.notifyDirtySelfPaint( instance );
      }
    },
    
    notifyTransformChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );
      var layer = this;
      
      var baseTrail = instance.trail;
      
      // TODO: performance: efficiency! this computes way more matrix transforms than needed
      scenery.Trail.eachPaintedTrailBetween( this.startPaintedTrail, this.endPaintedTrail, function( trail ) {
        if ( trail.isExtensionOf( baseTrail, true ) ) {
          // TODO: put the element on the instance?
          var element = layer.idElementMap[trail.getUniqueId()];
          var node = trail.lastNode();
          node.updateCSSTransform( trail.getTransform(), element );
        }
      }, false, this.scene );
    },
    
    // only a painted trail under this layer (for now)
    notifyBoundsAccuracyChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );
      // no-op, we don't care about bounds
    }
    
  } );
  
  return DOMLayer;
} );



// Copyright 2002-2013, University of Colorado

/**
 * An SVG-based layer in the scene graph. Each layer handles dirty-region handling separately,
 * and corresponds to a single canvas / svg element / DOM element in the main container.
 * Importantly, it does not contain rendered content from a subtree of the main
 * scene graph. It only will render a contiguous block of nodes visited in a depth-first
 * manner.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/SVGLayer',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','SCENERY/scenery','SCENERY/layers/Layer','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Transform3 = require( 'DOT/Transform3' );
  var Matrix3 = require( 'DOT/Matrix3' );
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Layer = require( 'SCENERY/layers/Layer' ); // extends Layer
  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/util/Util' );
  
  scenery.SVGLayer = function SVGLayer( args ) {
    sceneryLayerLog && sceneryLayerLog( 'SVGLayer constructor' );
    var $main = args.$main;
    
    this.scene = args.scene;
    
    // main SVG element
    this.svg = document.createElementNS( scenery.svgns, 'svg' );
    
    // the SVG has a single group under it, which corresponds to the transform of the layer's base node
    // TODO: consider renaming to 'this.baseGroup'
    this.g = document.createElementNS( scenery.svgns, 'g' );
    
    // the <defs> block that we will be stuffing gradients and patterns into
    this.defs = document.createElementNS( scenery.svgns, 'defs' );
    
    var width = args.scene.sceneBounds.width;
    var height = args.scene.sceneBounds.height;
    
    this.svg.appendChild( this.defs );
    this.svg.appendChild( this.g );
    this.$svg = $( this.svg );
    this.svg.setAttribute( 'width', width );
    this.svg.setAttribute( 'height', height );
    this.svg.setAttribute( 'stroke-miterlimit', 10 ); // to match our Canvas brethren so we have the same default behavior
    this.svg.style.position = 'absolute';
    this.svg.style.left = '0';
    this.svg.style.top = '0';
    this.svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
    this.svg.style['pointer-events'] = 'none';
    $main.append( this.svg );
    
    this.isSVGLayer = true;
    
    // maps trail ID => SVG self fragment (that displays shapes, text, etc.)
    this.idFragmentMap = {};
    
    // maps trail ID => SVG <g> that contains that node's self and everything under it
    this.idGroupMap = {};
    
    
    Layer.call( this, args );
    
    this.baseTransformDirty = true;
    this.baseTransformChange = true;
  };
  var SVGLayer = scenery.SVGLayer;
  
  // used as an object pool for marking internal base node bounds
  
  var scratchBounds1 = Bounds2.NOTHING.copy();
  
  inherit( Layer, SVGLayer, {
    
    /*
     * Notes about how state is tracked here:
     * Trails are stored on group.trail so that we can look this up when inserting new groups
     */
    addInstance: function( instance ) {
      var trail = instance.trail;
      
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' addInstance: ' + trail.toString() );
      
      assert && assert( !( trail.getUniqueId() in this.idFragmentMap ), 'Already contained that trail!' );
      assert && assert( trail.isPainted(), 'Don\'t add nodes without isPainted() to SVGLayer' );
      
      Layer.prototype.addInstance.call( this, instance );
      
      var subtrail = this.baseTrail.copy(); // grab the trail up to (and including) the base node, so we don't create superfluous groups
      var lastId = null;
      
      // walk a subtrail up from the root node all the way to the full trail, creating groups where necessary
      while ( subtrail.length <= trail.length ) {
        var id = subtrail.getUniqueId();
        var group = this.idGroupMap[id];
        
        if ( !group ) {
          // we need to create a new group
          
          if ( lastId ) {
            // we have a parent group to which we need to be added
            group = document.createElementNS( scenery.svgns, 'g' );
            
            // apply the node's transform to the group
            this.applyTransform( subtrail.lastNode().getTransform(), group );
            
            // add the group to its parent
            this.insertGroupIntoParent( group, this.idGroupMap[lastId], subtrail );
          } else {
            // we are ensuring the base group
            assert && assert( subtrail.lastNode() === this.baseNode );
            
            group = this.g;
            
            // sets up the proper transform for the base
            this.initializeBase();
            
            // immediately update the base transform so we don't temporarily display.
            // fixes https://github.com/phetsims/beers-law-lab/issues/20
            this.refreshBaseTransform();
          }
          
          // apply any stylings to the group (opacity, visibility)
          this.updateNodeGroup( subtrail.lastNode(), group );
          
          group.referenceCount = 0; // initialize a reference count, so we can know when to remove unused groups
          group.trail = subtrail.copy(); // put a reference to the trail on the group, so we can efficiently scan and see where to insert future groups
          
          this.idGroupMap[id] = group;
        }
        
        // this trail will depend on this group, so increment the reference counter
        group.referenceCount++;
        
        if ( subtrail.length === trail.length ) {
          // TODO: cleaner control structures
          break;
        }
        
        // step down towards our full trail
        subtrail.addDescendant( trail.nodes[subtrail.length] );
        lastId = id;
      }
      
      // actually add the node into its own group
      var node = trail.lastNode();
      var trailId = trail.getUniqueId();
      
      var nodeGroup = this.idGroupMap[trailId];
      var svgFragment = node.createSVGFragment( this.svg, this.defs, nodeGroup );
      this.updateNode( node, svgFragment );
      this.updateNodeGroup( node, nodeGroup );
      this.idFragmentMap[trailId] = svgFragment;
      nodeGroup.appendChild( svgFragment );
    },
    
    removeInstance: function( instance ) {
      var trail = instance.trail;
      
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' removeInstance: ' + trail.toString() );
      assert && assert( trail.getUniqueId() in this.idFragmentMap, 'Did not contain that trail!' );
      
      Layer.prototype.removeInstance.call( this, instance );
      
      // clean up the fragment and defs directly died to the node
      var trailId = trail.getUniqueId();
      var node = trail.lastNode();
      var fragment = this.idFragmentMap[trailId];
      this.idGroupMap[trailId].removeChild( fragment );
      delete this.idFragmentMap[trailId];
      if ( node.removeSVGDefs ) {
        node.removeSVGDefs( this.svg, this.defs );
      }
      
      // clean up any unneeded groups
      var subtrail = trail.copy();
      while ( subtrail.length > this.baseTrail.length ) {
        var id = subtrail.getUniqueId();
        
        var group = this.idGroupMap[id];
        group.referenceCount--;
        if ( group.referenceCount === 0 ) {
          // completely kill the group
          group.parentNode.removeChild( group );
          delete group.trail; // just in case someone held a reference
          delete this.idGroupMap[id];
        }
        
        subtrail.removeDescendant();
      }
      this.g.referenceCount--; // since we don't go down to the base group, adjust its reference count
    },
    
    // subtrail is to group, and should include parentGroup below
    insertGroupIntoParent: function( group, parentGroup, subtrail ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' insertGroupIntoParent subtrail:' + subtrail.toString() );
      if ( !parentGroup.childNodes.length ) {
        parentGroup.appendChild( group );
      } else {
        // if there is already a child, we need to do a scan to ensure we place our group as a child in the correct order (above/below)
        
        // scan other child groups in the parentGroup to find where we need to be (index i)
        var indexIndex = subtrail.length - 2; // index into the trail's indices
        var ourIndex = subtrail.indices[indexIndex];
        var i;
        for ( i = 0; i < parentGroup.childNodes.length; i++ ) {
          var child = parentGroup.childNodes[i];
          if ( child.trail ) {
            child.trail.reindex();
            var otherIndex = child.trail.indices[indexIndex];
            if ( otherIndex > ourIndex ) {
              // this other group is above us
              break;
            }
          }
        }
        
        // insert our group before parentGroup.childNodes[i] (or append if that doesn't exist)
        if ( i === parentGroup.childNodes.length ) {
          parentGroup.appendChild( group );
        } else {
          parentGroup.insertBefore( group, parentGroup.childNodes[i] );
        }
      }
    },
    
    // updates visual styles on an existing SVG fragment
    updateNode: function( node, fragment ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateNode: ' + node.constructor.name + ' #' + node.id );
      if ( node.updateSVGFragment ) {
        node.updateSVGFragment( fragment );
      }
      if ( node.updateSVGDefs ) {
        node.updateSVGDefs( this.svg, this.defs );
      }
    },
    
    // updates necessary paint attributes on a group (not including transform)
    updateNodeGroup: function( node, group ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateNodeGroup: ' + node.constructor.name + ' #' + node.id );
      this.updateGroupVisibility( node, group );
      this.updateGroupOpacity( node, group );
      this.updateGroupClip( node, group );
    },
    
    updateGroupVisibility: function( node, group ) {
      // if we're updating visibility for the base trail, apply its visibility and everything beneath it
      if ( node === this.baseNode ? this.baseTrail.isVisible() : node.isVisible() ) {
        group.style.display = 'inherit';
      } else {
        group.style.display = 'none';
      }
    },
    
    updateGroupOpacity: function( node, group ) {
      var opacity;
      if ( node === this.baseNode ) {
        opacity = this.baseTrail.getOpacity(); // multiplied by opacities of all ancestors
      } else {
        opacity = node.getOpacity();
      }
      group.setAttribute( 'opacity', opacity );
    },
    
    updateGroupClip: function( node, group ) {
      // TODO: optimization! this is not the fastest way of doing things
      var clipId = 'clip' + node.getId();
      
      assert && assert( !( node === this.baseNode && node !== this.scene && node._clipArea ), 'clipArea not supported on CSS-transformed SVG elements (or the base for now)' );
      
      // remove any old defs
      var oldDef = this.svg.getElementById( clipId );
      if ( oldDef ) {
        this.defs.removeChild( oldDef );
      }
      
      if ( node._clipArea ) {
        var definition = document.createElementNS( scenery.svgns, 'clipPath' );
        definition.setAttribute( 'id', clipId );
        definition.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
        
        var path = document.createElementNS( scenery.svgns, 'path' );
        path.setAttribute( 'd', node._clipArea.getSVGPath() );
        definition.appendChild( path );
        
        this.defs.appendChild( definition );
        
        group.setAttribute( 'clip-path', 'url(#' + clipId + ')' );
      } else {
        group.removeAttribute( 'clip-path' );
      }
    },
    
    getFragmentFromInstance: function( instance ) {
      // TODO: performance: key optimization point for SVG layers
      return this.idFragmentMap[instance.trail.getUniqueId()];
    },
    
    getGroupFromInstance: function( instance ) {
      // TODO: performance: key optimization point for SVG layers
      return this.idGroupMap[instance.trail.getUniqueId()];
    },
    
    applyTransform: function( transform, group ) {
      if ( transform.isIdentity() ) {
        if ( group.hasAttribute( 'transform' ) ) {
          group.removeAttribute( 'transform' );
        }
      } else {
        group.setAttribute( 'transform', transform.getMatrix().getSVGTransform() );
      }
    },
    
    render: function( scene, args ) {
      this.refreshBaseTransform();
    },
    
    refreshBaseTransform: function() {
      if ( this.baseTransformDirty ) {
        // this will be run either now or at the end of flushing changes
        var includesBaseTransformChange = this.baseTransformChange;
        this.updateBaseTransform( includesBaseTransformChange );
        
        this.baseTransformDirty = false;
        this.baseTransformChange = false;
      }
    },
    
    dispose: function() {
      Layer.prototype.dispose.call( this );
      
      this.svg.parentNode.removeChild( this.svg );
    },
    
    markBaseTransformDirty: function( changed ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' markBaseTransformDirty' );
      var baseTransformChange = this.baseTransformChange || !!changed;
      this.baseTransformDirty = true;
      this.baseTransformChange = baseTransformChange;
    },
    
    initializeBase: function() {
      // we don't want to call updateBaseTransform() twice, since baseNodeInternalBoundsChange() will call it if we use CSS transform
      if ( this.cssTransform ) {
        this.baseNodeInternalBoundsChange();
      } else {
        this.markBaseTransformDirty( true );
      }
    },
    
    // called when the base node's "internal" (self or child) bounds change, but not when it is just from the base node's own transform changing
    baseNodeInternalBoundsChange: function() {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' baseNodeInternalBoundsChange' );
      if ( this.cssTransform ) {
        // we want to set the baseNodeTransform to a translation so that it maps the baseNode's self/children in the baseNode's local bounds to (0,0,w,h)
        var internalBounds = scratchBounds1; // pooled copy
        internalBounds.set( this.baseNode.getBounds() );
        this.baseNode.transformBoundsFromParentToLocal( internalBounds );
        var padding = scenery.Layer.cssTransformPadding;
        
        // if there is nothing, or the bounds are empty for some reason, skip this!
        if ( !internalBounds.isEmpty() ) {
          this.baseNodeTransform.setMatrix( Matrix3.translation( Math.ceil( -internalBounds.minX + padding), Math.ceil( -internalBounds.minY + padding ) ) );
          
          // NOTE: this is mutable! don't use internalBounds after this
          var baseNodeInternalBounds = internalBounds.transform( this.baseNodeTransform.getMatrix() );
          
          // sanity check to ensure we are within that range
          assert && assert( baseNodeInternalBounds.minX >= 0 && baseNodeInternalBounds.minY >= 0 );
          
          this.updateContainerDimensions( Math.ceil( baseNodeInternalBounds.maxX + padding ),
                                          Math.ceil( baseNodeInternalBounds.maxY + padding ) );
        }
        
        // if this gets removed, update initializeBase()
        this.markBaseTransformDirty( true );
      } else if ( this.usesPartialCSSTransforms ) {
        this.markBaseTransformDirty( true );
      }
    },
    
    updateContainerDimensions: function( width, height ) {
      this.svg.setAttribute( 'width', width );
      this.svg.setAttribute( 'height', height );
    },
    
    updateBaseTransform: function( includesBaseTransformChange ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateBaseTransform' );
      var transform = this.baseTrail.getTransform(); // TODO: consider improving this, CSS+SVG bottleneck
      
      if ( this.cssTransform ) {
        // set the full transform!
        scenery.Util.applyCSSTransform( transform.getMatrix().timesMatrix( this.baseNodeTransform.getInverse() ), this.svg );
        
        if ( includesBaseTransformChange ) {
          this.applyTransform( this.baseNodeTransform, this.g );
        }
      } else if ( this.usesPartialCSSTransforms ) {
        // calculate what our CSS transform should be
        var cssTransform = new Transform3();
        var matrix = transform.getMatrix();
        if ( this.cssTranslation ) {
          cssTransform.append( Matrix3.translation( matrix.m02(), matrix.m12() ) );
        }
        if ( this.cssRotation ) {
          cssTransform.append( Matrix3.rotation2( matrix.getRotation() ) );
        }
        if ( this.cssScale ) {
          var scaleVector = matrix.getScaleVector();
          cssTransform.append( Matrix3.scaling( scaleVector.x, scaleVector.y ) );
        }
        
        // take the CSS transform out of what we will apply to the group
        transform.prepend( cssTransform.getInverse() );
        
        // now we need to see where our baseNode bounds are mapped to with our transform,
        // so that we can apply an extra translation and adjust dimensions as necessary
        var padding = scenery.Layer.cssTransformPadding;
        var internalBounds = this.baseNode.parentToLocalBounds( this.baseNode.getBounds() );
        var mappedBounds = transform.transformBounds2( internalBounds );
        var translation = Matrix3.translation( Math.ceil( -mappedBounds.minX + padding ), Math.ceil( -mappedBounds.minY + padding ) );
        var inverseTranslation = translation.inverted();
        this.updateContainerDimensions( Math.ceil( mappedBounds.getWidth()  + 2 * padding ),
                                        Math.ceil( mappedBounds.getHeight() + 2 * padding ) );
        
        // put the translation adjustment and its inverse in-between the two transforms
        cssTransform.append( inverseTranslation );
        transform.prepend( translation );
        
        // apply the transforms
        // TODO: checks to make sure we don't apply them in a row if one didn't change!
        scenery.Util.applyCSSTransform( cssTransform.getMatrix(), this.svg );
        this.applyTransform( transform, this.g );
      } else {
        this.applyTransform( transform, this.g );
      }
    },
    
    // TODO: consider a stack-based model for transforms?
    applyTransformationMatrix: function( matrix ) {
      // nothing at all needed here
    },
    
    getContainer: function() {
      return this.svg;
    },
    
    // returns next zIndex in place. allows layers to take up more than one single zIndex
    reindex: function( zIndex ) {
      Layer.prototype.reindex.call( this, zIndex );
      
      if ( this.zIndex !== zIndex ) {
        this.svg.style.zIndex = zIndex;
        this.zIndex = zIndex;
      }
      return zIndex + 1;
    },
    
    pushClipShape: function( shape ) {
      // TODO: clipping
    },
    
    popClipShape: function() {
      // TODO: clipping
    },
    
    getSVGString: function() {
      // TODO: jQuery seems to be stripping namespaces, so figure that one out?
      return $( '<div>' ).append( this.$svg.clone() ).html();
      
      // also note:
      // var doc = document.implementation.createHTMLDocument("");
      // doc.write(html);
       
      // // You must manually set the xmlns if you intend to immediately serialize the HTML
      // // document to a string as opposed to appending it to a <foreignObject> in the DOM
      // doc.documentElement.setAttribute("xmlns", doc.documentElement.namespaceURI);
       
      // // Get well-formed markup
      // html = (new XMLSerializer).serializeToString(doc);
    },
    
    // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas
    renderToCanvas: function( canvas, context, delayCounts ) {
      // temporarily put the full transform on the containing group so the rendering is correct (CSS transforms can take this away)
      this.applyTransform( this.baseTrail.getTransform(), this.g );
      
      if ( window.canvg ) {
        delayCounts.increment();
        
        // TODO: if we are using CSS3 transforms, run that here
        canvg( canvas, this.getSVGString(), {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          renderCallback: function() {
            delayCounts.decrement();
          }
        } );
      } else {
        // will not work on Internet Explorer 9/10
        
        // TODO: very much not convinced that this is better than setting src of image
        var DOMURL = window.URL || window.webkitURL || window;
        var img = new Image();
        var raw = this.getSVGString();
        console.log( raw );
        var svg = new Blob( [ raw ] , { type: "image/svg+xml;charset=utf-8" } );
        var url = DOMURL.createObjectURL( svg );
        delayCounts.increment();
        img.onload = function() {
          context.drawImage( img, 0, 0 );
          // TODO: this loading is delayed!!! ... figure out a solution to potentially delay?
          DOMURL.revokeObjectURL( url );
          delayCounts.decrement();
        };
        img.src = url;
        
        throw new Error( 'this implementation hits Chrome bugs, won\'t work on IE9/10, etc. deprecated' );
      }
      
      // revert the transform damage that we did to our base group
      this.updateBaseTransform();
    },
    
    getName: function() {
      return 'svg';
    },
    
    /*---------------------------------------------------------------------------*
    * Events from Instances
    *----------------------------------------------------------------------------*/
    
    notifyVisibilityChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );
      var group = this.getGroupFromInstance( instance );
      if ( group ) {
        this.updateGroupVisibility( instance.getNode(), group );
      } else if ( this.baseNode !== this.scene ) {
        // if we are using a CSS transform (basically)
        this.updateGroupVisibility( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );
      }
    },
    
    notifyOpacityChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );
      var group = this.getGroupFromInstance( instance );
      if ( group ) {
        this.updateGroupOpacity( instance.getNode(), group );
      } else if ( this.baseNode !== this.scene ) {
        // if we are using a CSS transform (basically)
        this.updateGroupOpacity( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );
      }
    },
    
    notifyClipChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyClipChange: ' + instance.trail.toString() );
      var group = this.getGroupFromInstance( instance );
      if ( group ) {
        this.updateGroupClip( instance.getNode(), group );
      } else if ( this.baseNode !== this.scene ) {
        // if we are using a CSS transform (basically)
        // TODO: clip combinations don't work yet, this won't really do anything (probably errors out)
        this.updateGroupClip( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );
      }
    },
    
    // only a painted trail under this layer
    notifyBeforeSelfChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );
      // no-op, we don't need paint changes
    },
    
    notifyBeforeSubtreeChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );
      // no-op, we don't need paint changes
    },
    
    // only a painted trail under this layer
    notifyDirtySelfPaint: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );
      var fragment = this.getFragmentFromInstance( instance );
      
      if ( fragment ) {
        var node = instance.getNode();
        
        if ( node.updateSVGFragment ) {
          // TODO: performance: don't re-do all of the fragment here! intelligent updating?
          node.updateSVGFragment( fragment );
        }
        if ( node.updateSVGDefs ) {
          // TODO: performance: don't re-do all of the defs here! intelligent updating?
          node.updateSVGDefs( this.svg, this.defs );
        }
      }
    },
    
    notifyDirtySubtreePaint: function( instance ) {
      // TODO: performance: this caused a 50% increase for the fast-svg transform steps, what were we missing?
      if ( instance.layer === this ) {
        this.notifyDirtySelfPaint( instance );
      }
    },
    
    notifyTransformChange: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );
      var node = instance.node;
      var trail = instance.trail;
      
      if ( trail.lastNode() === this.baseNode ) {
        // our trail points to the base node. handle this case as special
        this.markBaseTransformDirty();
      } else if ( _.contains( trail.nodes, this.baseNode ) ) { // TODO: performance: this linear scan looks slower than needed
        var group = this.idGroupMap[trail.getUniqueId()];
        
        // apply the transform to the group
        this.applyTransform( node.getTransform(), group );
      } else {
        // ancestor node changed a transform. rebuild the base transform
        this.markBaseTransformDirty();
      }
    },
    
    // only a painted trail under this layer (for now)
    notifyBoundsAccuracyChange: function( instance ) {
      // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );
      // no-op, we don't care about bounds
    }
    
  } );
  
  return SVGLayer;
} );



// Copyright 2002-2013, University of Colorado

/**
 * An enumeration of different back-end technologies used for rendering. It also essentially
 * represents the API that nodes need to implement to be used with this specified back-end.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/Renderer',['require','SCENERY/scenery','SCENERY/layers/LayerType','SCENERY/layers/CanvasLayer','SCENERY/layers/DOMLayer','SCENERY/layers/SVGLayer'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  require( 'SCENERY/layers/LayerType' );
  require( 'SCENERY/layers/CanvasLayer' );
  require( 'SCENERY/layers/DOMLayer' );
  require( 'SCENERY/layers/SVGLayer' );
  
  scenery.Renderer = function Renderer( layerConstructor, name, bitmask, defaultOptions ) {
    this.layerConstructor = layerConstructor;
    this.name = name;
    this.bitmask = bitmask;
    this.defaultOptions = defaultOptions;
    
    this.defaultLayerType = this.createLayerType( {} ); // default options are handled in createLayerType
  };
  var Renderer = scenery.Renderer;
  
  Renderer.prototype = {
    constructor: Renderer,
    
    createLayerType: function( rendererOptions ) {
      return new scenery.LayerType( this.layerConstructor, this.name, this.bitmask, this, _.extend( {}, this.defaultOptions, rendererOptions ) );
    }
  };
  
  Renderer.Canvas = new Renderer( scenery.CanvasLayer, 'canvas', scenery.bitmaskSupportsCanvas, {} );
  Renderer.DOM = new Renderer( scenery.DOMLayer, 'dom', scenery.bitmaskSupportsDOM, {} );
  Renderer.SVG = new Renderer( scenery.SVGLayer, 'svg', scenery.bitmaskSupportsSVG, {} );
  
  // add shortcuts for the default layer types
  scenery.CanvasDefaultLayerType = Renderer.Canvas.defaultLayerType;
  scenery.DOMDefaultLayerType    = Renderer.DOM.defaultLayerType;
  scenery.SVGDefaultLayerType    = Renderer.SVG.defaultLayerType;
  
  // and shortcuts so we can index in with shorthands like 'svg', 'dom', etc.
  Renderer.canvas = Renderer.Canvas;
  Renderer.dom = Renderer.DOM;
  Renderer.svg = Renderer.SVG;
  Renderer.webgl = Renderer.WebGL;
  
  return Renderer;
} );

// Copyright 2002-2013, University of Colorado

/**
 * API for RenderState
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/display/RenderState',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/layers/Renderer','SCENERY/util/Trail'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/layers/Renderer' );
  require( 'SCENERY/util/Trail' );
  
  scenery.RenderState = function RenderState() {
    
  };
  var RenderState = scenery.RenderState;
  
  inherit( Object, RenderState, {
    isBackbone: function() {
      return false;
    },
    
    isCanvasCache: function() {
      return false;
    },
    
    isCacheShared: function() {
      return false;
    },
    
    requestsSplit: function() {
      return false;
    },
    
    getStateForDescendant: function( trail ) {
      // new state
    },
    
    getPaintedRenderer: function() {
      
    },
    
    // renderer for the (Canvas) cache
    getCacheRenderer: function() {
      
    },
    
    // what is our absolute transform relative to (hah)? we assume all transforms up to the last node of this trail have already been applied
    getTransformBaseTrail: function() {
      
    },
    
    // whether our backbone child has a CSS transform applied
    isBackboneTransformed: function() {
      
    }
  } );
  
  // NOTE: assumes that the trail is not mutable
  RenderState.TestState = function TestState( trail, renderers, isProxy, isUnderCanvasCache, transformBaseTrail ) {
    trail.setImmutable();
    
    var node = trail.lastNode();
    
    // this should be accurate right now, the pass to update these should have been completed earlier
    var combinedBitmask = node._subtreeRendererBitmask;
    
    this.trail = trail;
    this.renderers = renderers;
    this.isProxy = isProxy;
    this.isUnderCanvasCache;
    
    this.nextRenderers = null; // will be filled with Array?
    
    this.backbone = false;
    this.canvasCache = false;
    this.cacheShared = false;
    this.splits = false;
    this.renderer = null;
    this.cacheRenderer = null;
    this.transformBaseTrail = transformBaseTrail;
    this.nextTransformBaseTrail = transformBaseTrail; // what descendant states will have as their base trail. affected by CSS transformed backbones and single caches
    this.backboneTransformed = false;
    
    var hints = node.hints || {}; // TODO: reduce allocation here
    
    if ( !isProxy ) {
      // check if we need a backbone or cache
      if ( node.opacity !== 1 || hints.requireElement || hints.cssTransformBackbone ) {
        this.backbone = true;
        this.backboneTransformed = !!hints.cssTransformBackbone; // for now, only trigger CSS transform if we have the specific hint
        if ( this.backboneTransformed ) {
          // everything under here should not apply transforms from this trail, but only any transforms beneath it
          this.nextTransformBaseTrail = trail;
        }
        this.renderer = scenery.Renderer.DOM; // probably won't be used
        this.nextRenderers = renderers;
      } else if ( hints.canvasCache ) {
        if ( combinedBitmask & scenery.bitmaskSupportsCanvas !== 0 ) {
          this.canvasCache = true;
          if ( hints.singleCache ) {
            this.cacheShared = true;
            this.nextTransformBaseTrail = new scenery.Trail();
          }
          this.renderer = scenery.Renderer.Canvas; // TODO: allow SVG (toDataURL) and DOM (direct Canvas)
          this.nextRenderers = [scenery.Renderer.Canvas]; // TODO: full resolution!
        } else {
          assert && assert( false, 'Attempting to canvas cache when nodes underneath can\'t be rendered with Canvas' );
        }
      }
    }
    
    if ( !this.backbone && !this.canvasCache ) {
      if ( hints.layerSplit ) {
        this.splits = true;
      }
      
      // if a node isn't painted (and no backbone/cache), we'll leave the renderer as null
      if ( node.isPainted() ) {
        // pick the top-most renderer that will work
        for ( var i = renderers.length - 1; i >= 0; i-- ) {
          var renderer = renderers[i];
          if ( renderer.bitmask & node._rendererBitmask !== 0 ) {
            this.renderer = renderer;
            break;
          }
        }
      }
      
      this.nextRenderers = renderers;
    }
  };
  RenderState.TestState.prototype = {
    constructor: RenderState.TestState,
    
    isBackbone: function() {
      return this.backbone;
    },
    
    isCanvasCache: function() {
      return this.canvasCache;
    },
    
    isCacheShared: function() {
      return this.cacheShared;
    },
    
    requestsSplit: function() {
      return this.splits;
    },
    
    getStateForDescendant: function( trail ) {
      if ( this.backbone || this.canvasCache ) {
        // proxy instance
        assert && assert( trail === this.trail, 'backbone/cache trail should be passed in again for the proxy instance' );
        // TODO: full resolution handling
        return new RenderState.TestState( trail, this.nextRenderers, true, true, this.nextTransformBaseTrail ); // TODO: allocation
      } else {
        return new RenderState.TestState( trail, this.nextRenderers, false, this.isUnderCanvasCache, this.nextTransformBaseTrail ); // TODO: allocation
      }
    },
    
    getPaintedRenderer: function() {
      return this.renderer;
    },
    
    getCacheRenderer: function() {
      return this.renderer;
    },
    
    getTransformBaseTrail: function() {
      return this.transformBaseTrail;
    },
    
    isBackboneTransformed: function() {
      return this.backboneTransformed;
    }
  };
  
  return RenderState;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A persistent display of a specific Node and its descendants
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/display/Display',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail','SCENERY/display/DisplayInstance','SCENERY/display/RenderState','SCENERY/layers/Renderer'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/display/DisplayInstance' );
  require( 'SCENERY/display/RenderState' );
  require( 'SCENERY/layers/Renderer' );
  
  scenery.Display = function Display( rootNode ) {
    this._rootNode = rootNode;
    this._domElement = null; // TODO: potentially allow immediate export of this?
    this._sharedCanvasInstances = {}; // map from Node ID to DisplayInstance, for fast lookup
    this._baseInstance = null; // will be filled with the root DisplayInstance
  };
  var Display = scenery.Display;
  
  // recursively compute the bitmask intersection (bitwise AND) for a node and all of its children, and store it to that node's _subtreeRendererBitmask
  function recursiveUpdateRendererBitmask( node ) {
    var bitmask = scenery.bitmaskAll;
    bitmask &= node._rendererBitmask;
    
    // include all children
    var children = node._children;
    var numChildren = children.length;
    for ( var i = 0; i < numChildren; i++ ) {
      bitmask &= recursiveUpdateRendererBitmask( children[i] );
    }
    
    node._subtreeRendererBitmask = bitmask;
    return bitmask; // return the bitmask so we have direct access at the call site
  }
  
  // display instance linked list ops
  function connectInstances( a, b ) {
    a.nextPainted = b;
    b.previousPainted = a;
  }
  
  function createBackbone( display, trail, state ) {
    var blockInstance = new scenery.DisplayInstance( trail );
    blockInstance.state = state;
    blockInstance.renderer = scenery.Renderer.DOM;
    
    createProxyInstance( display, trail, state, blockInstance );
    return blockInstance;
  }
  
  function createCanvasCache( display, trail, state ) {
    var blockInstance = new scenery.DisplayInstance( trail );
    blockInstance.state = state;
    blockInstance.renderer = state.getCacheRenderer();
    
    createProxyInstance( display, trail, state, blockInstance );
    return blockInstance;
  }
  
  function createSharedCanvasCache( display, trail, state ) {
    var instanceKey = trail.lastNode().getId();
    var sharedInstance = display._sharedCanvasInstances[instanceKey];
    if ( sharedInstance ) {
      // TODO: assert state is the same?
      // TODO: increment reference counting?
      return sharedInstance;
    } else {
      var blockInstance = new scenery.DisplayInstance( new scenery.Trail( trail.lastNode() ) );
      blockInstance.state = state;
      blockInstance.renderer = state.getCacheRenderer();
      
      createProxyInstance( display, trail, state, blockInstance );
      // TODO: increment reference counting?
      display._sharedCanvasInstances[instanceKey] = blockInstance;
      return blockInstance;
    }
  }
  
  // For when we have a block/stub instance (for a backbone/cache), and we want an instance for the same trail, but to render itself and its subtree.
  // Basically, this involves another getStateForDescendant (called in createInstance), and for now we set up proxy variables
  function createProxyInstance( display, trail, state, blockInstance ) {
    var instance = createInstance( display, trail, state );
    // TODO: better way of handling this?
    blockInstance.proxyChild = instance;
    instance.proxyParent = blockInstance;
    
    blockInstance.firstPainted = blockInstance;
    blockInstance.lastPainted = blockInstance;
    return instance; // if we need it
  }
  
  function createSplitInstance() {
    return new scenery.DisplayInstance( null ); // null trail
  }
  
  function createInstance( display, trail, ancestorState ) {
    var state = ancestorState.getStateForDescendant( trail );
    if ( state.isBackbone() ) {
      return createBackbone( display, trail, state );
    } else if ( state.isCanvasCache() ) {
      return state.isCacheShared() ? createSharedCanvasCache( display, trail, state ) : createCanvasCache( display, trail, state );
    } else {
      var instance = new scenery.DisplayInstance( trail );
      var node = trail.lastNode();
      instance.state = state;
      instance.renderer = node.isPainted() ? state.getPaintedRenderer() : null;
      
      var currentPaintedInstance = null;
      if ( instance.isEffectivelyPainted() ) {
        currentPaintedInstance = instance;
        instance.firstPainted = instance;
      }
      
      var children = trail.lastNode().children;
      var numChildren = children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        var childInstance = createInstance( display, trail.copy().addDescendant( children[i], i ), state );
        instance.appendInstance( childInstance );
        if ( childInstance.firstPainted ) {
          assert && assert( childInstance.lastPainted, 'Any display instance with firstPainted should also have lastPainted' );
          
          if ( currentPaintedInstance ) {
            connectInstances( currentPaintedInstance, childInstance.firstPainted );
          } else {
            instance.firstPainted = childInstance.firstPainted;
          }
          currentPaintedInstance = childInstance.lastPainted;
        }
      }
      
      if ( currentPaintedInstance !== null ) {
        instance.lastPainted = currentPaintedInstance;
      }
      
      if ( state.requestsSplit() ) {
        if ( instance.firstPainted ) {
          var beforeSplit = createSplitInstance();
          var afterSplit = createSplitInstance();
          connectInstances( beforeSplit, instance.firstPainted );
          connectInstances( instance.lastPainted, afterSplit );
          instance.firstPainted = beforeSplit;
          instance.lastPainted = afterSplit;
        } else {
          instance.firstPainted = instance.lastPainted = createSplitInstance();
        }
      }
      
      return instance;
    }
  }
  
  inherit( Object, Display, {
    getRootNode: function() {
      return this._rootNode;
    },
    get rootNode() { return this.getRootNode(); },
    
    // NOTE: to be replaced with a full stitching/update version
    buildTemporaryDisplay: function() {
      // compute updated _subtreeRendererBitmask for every Node // TODO: add and use dirty flag for this, and decide how the flags get set!
      recursiveUpdateRendererBitmask( this._rootNode );
      
      var baseTrail = new scenery.Trail( this._rootNode );
      var baseState = new scenery.RenderState.TestState( baseTrail, [
        scenery.Renderer.DOM,
        scenery.Renderer.Canvas,
        scenery.Renderer.SVG,
        new scenery.Trail()
      ], false, false );
      this._baseInstance = createBackbone( this, baseTrail, baseState );
    }
  } );
  
  return Display;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Basic down/up pointer handling for a Node, so that it's easy to handle buttons
 *
 * TODO: test hand handle down, go off screen, up. How to handle that properly?
 * TODO: tests
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/DownUpListener',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  
  /*
   * The 'trail' parameter passed to down/upInside/upOutside will end with the node to which this DownUpListener has been added.
   *
   * Allowed options: {
   *    mouseButton: 0  // The mouse button to use: left: 0, middle: 1, right: 2, see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
   *    down: null      // down( event, trail ) is called when the pointer is pressed down on this node
   *                    // (and another pointer is not already down on it).
   *    up: null        // up( event, trail ) is called after 'down', regardless of the pointer's current location.
   *                    // Additionally, it is called AFTER upInside or upOutside, whichever is relevant
   *    upInside: null  // upInside( event, trail ) is called after 'down', when the pointer is released inside
   *                    // this node (it or a descendant is the top pickable node under the pointer)
   *    upOutside: null // upOutside( event, trail ) is called after 'down', when the pointer is released outside
   *                    // this node (it or a descendant is the not top pickable node under the pointer, even if the
   *                    // same instance is still directly under the pointer)
   * }
   */
  scenery.DownUpListener = function DownUpListener( options ) {
    var handler = this;
    
    this.options = _.extend( {
      mouseButton: 0 // allow a different mouse button 
    }, options );
    this.isDown = false;   // public, whether this listener is down
    this.downCurrentTarget = null; // 'up' is handled via a pointer lister, which will have null currentTarget, so save the 'down' currentTarget
    this.downTrail = null;
    this.pointer = null;
    
    // this listener gets added to the pointer on a 'down'
    this.downListener = {
      // mouse/touch up
      up: function( event ) {
        sceneryEventLog && sceneryEventLog( 'DownUpListener (pointer) up for ' + handler.downTrail.toString() );
        assert && assert( event.pointer === handler.pointer );
        if ( !event.pointer.isMouse || event.domEvent.button === handler.options.mouseButton ) {
          handler.buttonUp( event );
        }
      },
      
      // touch cancel
      cancel: function( event ) {
        sceneryEventLog && sceneryEventLog( 'DownUpListener (pointer) cancel for ' + handler.downTrail.toString() );
        assert && assert( event.pointer === handler.pointer );
        handler.buttonUp( event );
      }
    };
  };
  var DownUpListener = scenery.DownUpListener;
  
  DownUpListener.prototype = {
    constructor: DownUpListener,
    
    buttonDown: function( event ) {
      // already down from another pointer, don't do anything
      if ( this.isDown ) { return; }
      
      // ignore other mouse buttons
      if ( event.pointer.isMouse && event.domEvent.button !== this.options.mouseButton ) { return; }
      
      // add our listener so we catch the up wherever we are
      event.pointer.addInputListener( this.downListener );
      
      this.isDown = true;
      this.downCurrentTarget = event.currentTarget;
      this.downTrail = event.trail.subtrailTo( event.currentTarget, false );
      this.pointer = event.pointer;
      
      sceneryEventLog && sceneryEventLog( 'DownUpListener buttonDown for ' + this.downTrail.toString() ); 
      if ( this.options.down ) {
        this.options.down( event, this.downTrail );
      }
    },
    
    buttonUp: function( event ) {
      this.isDown = false;
      this.pointer.removeInputListener( this.downListener );

      var currentTargetSave = event.currentTarget;
      event.currentTarget = this.downCurrentTarget; // up is handled by a pointer listener, so currentTarget would be null.
      if ( this.options.upInside || this.options.upOutside ) {
        var trailUnderPointer = event.trail;
        
        // TODO: consider changing this so that it just does a hit check and ignores anything in front?
        var isInside = trailUnderPointer.isExtensionOf( this.downTrail, true );
        
        if ( isInside && this.options.upInside ) {
          this.options.upInside( event, this.downTrail );
        } else if ( !isInside && this.options.upOutside ) {
          this.options.upOutside( event, this.downTrail );
        }
      }
      sceneryEventLog && sceneryEventLog( 'DownUpListener buttonUp for ' + this.downTrail.toString() ); 
      if ( this.options.up ) {
        this.options.up( event, this.downTrail );
      }
      event.currentTarget = currentTargetSave; // be polite to other listeners, restore currentTarget
    },
    
    /*---------------------------------------------------------------------------*
    * events called from the node input listener
    *----------------------------------------------------------------------------*/
    
    // mouse/touch down on this node
    down: function( event ) {
      this.buttonDown( event );
    }
  };
  
  return DownUpListener;
} );



// Copyright 2002-2013, University of Colorado

/**
 * Basic button handling.
 *
 * Uses 4 states:
 * up: mouse not over, not pressed
 * over: mouse over, not pressed
 * down: mouse over, pressed
 * out: mouse not over, pressed
 *
 * TODO: offscreen handling
 * TODO: fix enter/exit edge cases for moving nodes or add/remove child, and when touches are created
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/ButtonListener',['require','SCENERY/scenery','SCENERY/util/Trail','PHET_CORE/inherit','SCENERY/input/DownUpListener'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var inherit = require( 'PHET_CORE/inherit' );
  
  var DownUpListener = require( 'SCENERY/input/DownUpListener' );
  
  /**
   * Options for the ButtonListener:
   *
   * mouseButton: 0
   * fireOnDown: false // default is to fire on 'up' after 'down', but passing fireOnDown: true will fire on 'down' instead
   * up: null          // Called on an 'up' state change, as up( event, oldState )
   * over: null        // Called on an 'over' state change, as over( event, oldState )
   * down: null        // Called on an 'down' state change, as down( event, oldState )
   * out: null         // Called on an 'out' state change, as out( event, oldState )
   * fire: null        // Called on a state change to/from 'down' (depending on fireOnDown), as fire( event ). Called after the triggering up/over/down event.
   */
  scenery.ButtonListener = function ButtonListener( options ) {

    this.buttonState = 'up'; // public: 'up', 'over', 'down' or 'out'
    
    this._overCount = 0; // how many pointers are over us (track a count, so we can handle multiple pointers gracefully)
    
    this._buttonOptions = options; // store the options object so we can call the callbacks
    
    var buttonListener = this;
    DownUpListener.call( this, {

      mouseButton: options.mouseButton || 0, // forward the mouse button, default to 0 (LMB)
      
      down: function( event, trail ) {
        buttonListener.setButtonState( event, 'down' );
      },
      
      up: function( event, trail ) {
        buttonListener.setButtonState( event, buttonListener._overCount > 0 ? 'over' : 'up' );
      }
    } );
  };

  var ButtonListener = scenery.ButtonListener;
  
  inherit( DownUpListener, ButtonListener, {

    setButtonState: function( event, state ) {
      if ( state !== this.buttonState ) {
        sceneryEventLog && sceneryEventLog( 'ButtonListener state change to ' + state + ' from ' + this.buttonState + ' for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
        var oldState = this.buttonState;
        
        this.buttonState = state;
        
        if ( this._buttonOptions[state] ) {
          this._buttonOptions[state]( event, oldState );
        }
        
        if ( this._buttonOptions.fire &&
             this._overCount > 0 &&
             ( this._buttonOptions.fireOnDown ? ( state === 'down' ) : ( oldState === 'down' ) ) ) {
          this._buttonOptions.fire( event );
        }
      }
    },
    
    enter: function( event ) {
      sceneryEventLog && sceneryEventLog( 'ButtonListener enter for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      this._overCount++;
      if ( this._overCount === 1 ) {
        this.setButtonState( event, this.isDown ? 'down' : 'over' );
      }
    },

    exit: function( event ) {
      sceneryEventLog && sceneryEventLog( 'ButtonListener exit for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      assert && assert( this._overCount > 0, 'Exit events not matched by an enter' );
      this._overCount--;
      if ( this._overCount === 0 ) {
        this.setButtonState( event, this.isDown ? 'out' : 'up' );
      }
    }
  } );

  //TODO delete this after work is completed on sun.Button and scenery.ButtonListener
  ButtonListener.TEST_LISTENER = new ButtonListener( {

    up: function( event, oldState ) {
      console.log( "ButtonListener.up oldState=" + oldState );
    },

    over: function( event, oldState ) {
      console.log( "ButtonListener.over oldState=" + oldState );
    },

    down: function( event, oldState ) {
      console.log( "ButtonListener.down oldState=" + oldState );
    },

    out: function( event, oldState ) {
      console.log( "ButtonListener.out oldState=" + oldState );
    },

    fire: function( event ) {
      console.log( "ButtonListener.fire" );
    }
  } );

  return ButtonListener;
} );



// Copyright 2002-2013, University of Colorado

/*
 * An event in Scenery that has similar event-handling characteristics to DOM events.
 * The original DOM event (if any) is available as event.domEvent.
 *
 * Multiple events can be triggered by a single domEvent, so don't assume it is unique.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */
 
define( 'SCENERY/input/Event',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  scenery.Event = function Event( args ) {
    // ensure that all of the required args are supplied
    assert && assert( args.trail &&
                      args.type &&
                      args.pointer &&
                      args.target, 'Missing required scenery.Event argument' );
    
    this.handled = false;
    this.aborted = false;
    
    // {Trail} path to the leaf-most node, ordered list, from root to leaf
    this.trail = args.trail;
    
    // {String} what event was triggered on the listener
    this.type = args.type;
    
    // {Pointer}
    this.pointer = args.pointer;
    
    // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
    this.domEvent = args.domEvent;
    
    // {Node} whatever node you attached the listener to, or null when firing events on a Pointer
    this.currentTarget = args.currentTarget;
    
    // {Node} leaf-most node in trail
    this.target = args.target;
    
    // TODO: add extended information based on an event here?
  };
  var Event = scenery.Event;
  
  Event.prototype = {
    constructor: Event,
    
    // like DOM Event.stopPropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
    handle: function() {
      this.handled = true;
    },
    
    // like DOM Event.stopImmediatePropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
    abort: function() {
      this.handled = true;
      this.aborted = true;
    }
  };
  
  return Event;
} );

// Copyright 2002-2013, University of Colorado

/*
 * A pointer is an abstraction that includes a mouse and touch points (and possibly keys).
 *
 * TODO: add state tracking (dragging/panning/etc.) to pointer for convenience
 * TODO: consider an 'active' flag?
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Pointer',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  scenery.Pointer = function Pointer() {
    this.listeners = [];
    
    phetAllocation && phetAllocation( 'Pointer' );
    
    this.active = false; // whether a control is being actively manipulated by this pointer
  };
  var Pointer = scenery.Pointer;
  
  Pointer.prototype = {
    constructor: Pointer,
    
    addInputListener: function( listener ) {
      assert && assert( !_.contains( this.listeners, listener ) );
      
      this.listeners.push( listener );
    },
    
    removeInputListener: function( listener ) {
      var index = _.indexOf( this.listeners, listener );
      assert && assert( index !== -1 );
      
      this.listeners.splice( index, 1 );
    },
    
    // for mouse/touch/pen
    hasPointChanged: function( point ) {
      return this.point !== point && ( !point || !this.point || !this.point.equals( point ) );
    }
  };
  
  return Pointer;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Tracks the mouse state
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Mouse',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var Pointer = require( 'SCENERY/input/Pointer' ); // inherits from Pointer
  
  scenery.Mouse = function Mouse() {
    Pointer.call( this );
    
    this.point = null;
    
    this.leftDown = false;
    this.middleDown = false;
    this.rightDown = false;
    
    this.isMouse = true;
    
    this.trail = null;
    
    this.isDown = false;
    
    // overrides the cursor of whatever is under it when set
    this._cursor = null;
    
    this.type = 'mouse';
  };
  var Mouse = scenery.Mouse;
  
  inherit( Pointer, Mouse, {
    set cursor( value ) { return this.setCursor( value ); },
    get cursor() { return this._cursor; },
    
    setCursor: function( value ) {
      this._cursor = value;
      return this; // allow chaining
    },
    
    clearCursor: function() {
      this.setCursor( null );
    },
    
    down: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      sceneryEventLog && point && sceneryEventLog( 'mouse down at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = true;
      switch( event.button ) {
        case 0: this.leftDown = true; break;
        case 1: this.middleDown = true; break;
        case 2: this.rightDown = true; break;
      }
      return pointChanged;
    },
    
    up: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      sceneryEventLog && point && sceneryEventLog( 'mouse up at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      switch( event.button ) {
        case 0: this.leftDown = false; break;
        case 1: this.middleDown = false; break;
        case 2: this.rightDown = false; break;
      }
      return pointChanged;
    },
    
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      sceneryEventLog && point && sceneryEventLog( 'mouse move at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },
    
    over: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      sceneryEventLog && point && sceneryEventLog( 'mouse over at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },
    
    out: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      sceneryEventLog && point && sceneryEventLog( 'mouse out at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      // TODO: how to handle the mouse out-of-bounds
      this.point = null;
      return pointChanged;
    },
    
    toString: function() {
      return 'Mouse';
    }
  } );
  
  return Mouse;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Tracks a single touch point
 *
 * IE guidelines for Touch-friendly sites: http://blogs.msdn.com/b/ie/archive/2012/04/20/guidelines-for-building-touch-friendly-sites.aspx
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Touch',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer
  
  scenery.Touch = function Touch( id, point, event ) {
    Pointer.call( this );
    
    this.id = id;
    this.point = point;
    this.isTouch = true;
    this.trail = null;
    
    this.isDown = true; // touches always start down
    
    this.type = 'touch';
  };
  var Touch = scenery.Touch;
  
  inherit( Pointer, Touch, {
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },
    
    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    
    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    
    toString: function() {
      return 'Touch#' + this.id;
    }
  } );
  
  return Touch;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Tracks a stylus ('pen') or something with tilt and pressure information
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Pen',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer
  
  scenery.Pen = function Pen( id, point, event ) {
    Pointer.call( this );
    
    this.id = id;
    this.point = point;
    this.isPen = true;
    this.trail = null;
    
    this.isDown = true; // pens always start down? TODO: is this true with pointer events?
    
    this.type = 'pen';
  };
  var Pen = scenery.Pen;
  
  inherit( Pointer, Pen, {
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },
    
    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    
    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    
    toString: function() {
      return 'Pen#' + this.id;
    }
  } );
  
  return Pen;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Tracks a single key-press
 *
 * TODO: general key-press implementation
 * TODO: consider separate handling for keys in general.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Key',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var Pointer = require( 'SCENERY/input/Pointer' ); // Inherits from Pointer
  
  scenery.Key = function Key( event ) {
    Pointer.call( this );
    
    this.event = event; // event.keyCode event.charCode
    this.isKey = true; // compared to isMouse/isPen/isTouch
    this.trail = null;
    this.type = 'key';
  };
  var Key = scenery.Key;
  
  inherit( Pointer, Key, {
    
  } );
  
  return Key;
} );

// Copyright 2002-2013, University of Colorado

/**
 * API for handling mouse / touch / keyboard events.
 *
 * A 'pointer' is an abstract way of describing either the mouse, a single touch point, or a key being pressed.
 * touch points and key presses go away after being released, whereas the mouse 'pointer' is persistent.
 *
 * Events will be called on listeners with a single event object. Supported event types are:
 * 'up', 'down', 'out', 'over', 'enter', 'exit', 'move', and 'cancel'. Scenery also supports more specific event
 * types that constrain the type of pointer, so 'mouse' + type, 'touch' + type and 'pen' + type will fire
 * on each listener before the generic event would be fined. E.g. for mouse movement, listener.mousemove will be
 * fired before listener.move.
 *
 * DOM Level 3 events spec: http://www.w3.org/TR/DOM-Level-3-Events/
 * Touch events spec: http://www.w3.org/TR/touch-events/
 * Pointer events spec draft: https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/Input',['require','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Mouse','SCENERY/input/Touch','SCENERY/input/Pen','SCENERY/input/Key','SCENERY/input/Event'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/input/Mouse' );
  require( 'SCENERY/input/Touch' );
  require( 'SCENERY/input/Pen' );
  require( 'SCENERY/input/Key' );
  require( 'SCENERY/input/Event' );
  
  // listenerTarget is the DOM node (window/document/element) to which DOM event listeners will be attached
  scenery.Input = function Input( scene, listenerTarget, batchDOMEvents ) {
    this.scene = scene;
    this.listenerTarget = listenerTarget;
    this.batchDOMEvents = batchDOMEvents;
    
    this.batchedCallbacks = []; // cleared every frame

    //Pointer for mouse, only created lazily on first mouse event, so no mouse is allocated on tablets
    this.mouse = null;

    this.pointers = [];
    
    this.listenerReferences = [];
    
    this.eventLog = [];     // written when recording event input. can be overwritten to the empty array to reset. Strings relative to this class (prefix "scene.input.")
    this.logEvents = false; // can be set to true to cause Scenery to record all input calls to eventLog

    this.pointerAddedListeners = [];
  };
  var Input = scenery.Input;
  
  Input.prototype = {
    constructor: Input,

    addPointer: function( pointer ) {
      this.pointers.push( pointer );

      //Callback for showing pointer events.  Optimized for performance.
      if ( this.pointerAddedListeners.length ) {
        for ( var i = 0; i < this.pointerAddedListeners.length; i++ ) {
          this.pointerAddedListeners[i]( pointer );
        }
      }
    },

    addPointerAddedListener: function( listener ) {
      this.pointerAddedListeners.push(listener);
    },

    removePointerAddedListener: function( listener ) {
      var index = this.pointerAddedListeners.indexOf( listener );
      if ( index !== -1 ) {
        this.pointerAddedListeners.splice( index, index + 1 );
      }
    },
    
    removePointer: function( pointer ) {
      // sanity check version, will remove all instances
      for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
        if ( this.pointers[i] === pointer ) {
          this.pointers.splice( i, 1 );
        }
      }
    },
    
    findTouchById: function( id ) {
      var i = this.pointers.length;
      while ( i-- ) {
        var pointer = this.pointers[i];
        if ( pointer.id === id ) {
          return pointer;
        }
      }
      return undefined;
    },
    
    findKeyByEvent: function( event ) {
      assert && assert( event.hasOwnProperty( 'keyCode' ) && event.hasOwnProperty('charCode'), 'Assumes the KeyboardEvent has keyCode and charCode properties' );
      var result = _.find( this.pointers, function( pointer ) {
        // TODO: also check location (if that exists), so we don't mix up left and right shift, etc.
        return pointer.keyCode === event.keyCode && pointer.charCode === event.charCode;
      } );
      // assert && assert( result, 'No key found for the combination of key:' + event.key + ' and location:' + event.location );
      return result;
    },

    //Init the mouse on the first mouse event (if any!)
    initMouse: function() {
      this.mouse = new scenery.Mouse();
      this.addPointer( this.mouse );
    },
    
    mouseDown: function( point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'mouseDown(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      var pointChanged = this.mouse.down( point, event );
      if ( pointChanged ) {
        this.moveEvent( this.mouse, event );
      }
      this.downEvent( this.mouse, event );
    },
    
    mouseUp: function( point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'mouseUp(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      var pointChanged = this.mouse.up( point, event );
      if ( pointChanged ) {
        this.moveEvent( this.mouse, event );
      }
      this.upEvent( this.mouse, event );
    },
    
    mouseUpImmediate: function( point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'mouseUpImmediate(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      if ( this.mouse.point ) {
        // if the pointer's point hasn't been initialized yet, ignore the immediate up
        this.upImmediateEvent( this.mouse, event );
      }
    },
    
    mouseMove: function( point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'mouseMove(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.move( point, event );
      this.moveEvent( this.mouse, event );
    },
    
    mouseOver: function( point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'mouseOver(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.over( point, event );
      // TODO: how to handle mouse-over (and log it)
    },
    
    mouseOut: function( point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'mouseOut(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.out( point, event );
      // TODO: how to handle mouse-out (and log it)
    },
    
    keyDown: function( event ) {
      if ( this.logEvents ) { this.eventLog.push( 'keyDown(' + Input.serializeDomEvent( event ) + ');' ); }
      var key = new scenery.Key( event );
      this.addPointer( key );
      
      var trail = this.scene.getTrailFromKeyboardFocus();
      this.dispatchEvent( trail, 'keyDown', key, event, true );
    },
    
    keyUp: function( event ) {
      if ( this.logEvents ) { this.eventLog.push( 'keyUp(' + Input.serializeDomEvent( event ) + ');' ); }
      var key = this.findKeyByEvent( event );
      if ( key ) {
        this.removePointer( key );
        
        var trail = this.scene.getTrailFromKeyboardFocus();
        this.dispatchEvent( trail, 'keyUp', key, event, true );
      }
    },
    
    keyPress: function( event ) {
      if ( this.logEvents ) { this.eventLog.push( 'keyPress(' + Input.serializeDomEvent( event ) + ');' ); }
      // NOTE: do we even need keyPress?
    },
    
    // called for each touch point
    touchStart: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'touchStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = new scenery.Touch( id, point, event );
      this.addPointer( touch );
      this.downEvent( touch, event );
    },
    
    touchEnd: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'touchEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findTouchById( id );
      if ( touch ) {
        var pointChanged = touch.end( point, event );
        if ( pointChanged ) {
          this.moveEvent( touch, event );
        }
        this.removePointer( touch );
        this.upEvent( touch, event );
      } else {
        assert && assert( false, 'Touch not found for touchEnd: ' + id );
      }
    },
    
    touchEndImmediate: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'touchEndImmediate(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findTouchById( id );
      if ( touch ) {
        this.upImmediateEvent( touch, event );
      } else {
        assert && assert( false, 'Touch not found for touchEndImmediate: ' + id );
      }
    },
    
    touchMove: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'touchMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findTouchById( id );
      if ( touch ) {
        touch.move( point, event );
        this.moveEvent( touch, event );
      } else {
        assert && assert( false, 'Touch not found for touchMove: ' + id );
      }
    },
    
    touchCancel: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'touchCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findTouchById( id );
      if ( touch ) {
        var pointChanged = touch.cancel( point, event );
        if ( pointChanged ) {
          this.moveEvent( touch, event );
        }
        this.removePointer( touch );
        this.cancelEvent( touch, event );
      } else {
        assert && assert( false, 'Touch not found for touchCancel: ' + id );
      }
    },
    
    // called for each touch point
    penStart: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'penStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = new scenery.Pen( id, point, event );
      this.addPointer( pen );
      this.downEvent( pen, event );
    },
    
    penEnd: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'penEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findTouchById( id );
      if ( pen ) {
        var pointChanged = pen.end( point, event );
        if ( pointChanged ) {
          this.moveEvent( pen, event );
        }
        this.removePointer( pen );
        this.upEvent( pen, event );
      } else {
        assert && assert( false, 'Pen not found for penEnd: ' + id );
      }
    },
    
    penEndImmediate: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'penEndImmediate(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findTouchById( id );
      if ( pen ) {
        this.upImmediateEvent( pen, event );
      } else {
        assert && assert( false, 'Pen not found for penEndImmediate: ' + id );
      }
    },
    
    penMove: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'penMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findTouchById( id );
      if ( pen ) {
        pen.move( point, event );
        this.moveEvent( pen, event );
      } else {
        assert && assert( false, 'Pen not found for penMove: ' + id );
      }
    },
    
    penCancel: function( id, point, event ) {
      if ( this.logEvents ) { this.eventLog.push( 'penCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findTouchById( id );
      if ( pen ) {
        var pointChanged = pen.cancel( point, event );
        if ( pointChanged ) {
          this.moveEvent( pen, event );
        }
        this.removePointer( pen );
        this.cancelEvent( pen, event );
      } else {
        assert && assert( false, 'Pen not found for penCancel: ' + id );
      }
    },
    
    pointerDown: function( id, type, point, event ) {
      switch ( type ) {
        case 'mouse':
          this.mouseDown( point, event );
          break;
        case 'touch':
          this.touchStart( id, point, event );
          break;
        case 'pen':
          this.penStart( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    
    pointerUp: function( id, type, point, event ) {
      switch ( type ) {
        case 'mouse':
          this.mouseUp( point, event );
          break;
        case 'touch':
          this.touchEnd( id, point, event );
          break;
        case 'pen':
          this.penEnd( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    
    pointerUpImmediate: function( id, type, point, event ) {
      switch ( type ) {
        case 'mouse':
          this.mouseUpImmediate( point, event );
          break;
        case 'touch':
          this.touchEndImmediate( id, point, event );
          break;
        case 'pen':
          this.penEndImmediate( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    
    pointerCancel: function( id, type, point, event ) {
      switch ( type ) {
        case 'mouse':
          if ( console && console.log ) {
            console.log( 'WARNING: Pointer mouse cancel was received' );
          }
          break;
        case 'touch':
          this.touchCancel( id, point, event );
          break;
        case 'pen':
          this.penCancel( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    
    pointerMove: function( id, type, point, event ) {
      switch ( type ) {
        case 'mouse':
          this.mouseMove( point, event );
          break;
        case 'touch':
          this.touchMove( id, point, event );
          break;
        case 'pen':
          this.penMove( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    
    pointerOver: function( id, type, point, event ) {
      
    },
    
    pointerOut: function( id, type, point, event ) {
      
    },
    
    pointerEnter: function( id, type, point, event ) {
      
    },
    
    pointerLeave: function( id, type, point, event ) {
      
    },
    
    upEvent: function( pointer, event ) {
      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
      
      this.dispatchEvent( trail, 'up', pointer, event, true );
      
      // touch pointers are transient, so fire exit/out to the trail afterwards
      if ( pointer.isTouch ) {
        this.exitEvents( pointer, event, trail, 0, true );
      }
      
      pointer.trail = trail;
    },
    
    upImmediateEvent: function( pointer, event ) {
      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
      
      this.dispatchEvent( trail, 'upImmediate', pointer, event, true );
    },
    
    downEvent: function( pointer, event ) {
      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
      
      // touch pointers are transient, so fire enter/over to the trail first
      if ( pointer.isTouch ) {
        this.enterEvents( pointer, event, trail, 0, true );
      }
      
      this.dispatchEvent( trail, 'down', pointer, event, true );
      
      pointer.trail = trail;
    },
    
    moveEvent: function( pointer, event ) {
      var changed = this.branchChangeEvents( pointer, event, true );
      if ( changed ) {
        sceneryEventLog && sceneryEventLog( 'branch change due to move event' );
      }
    },
    
    cancelEvent: function( pointer, event ) {
      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
      
      this.dispatchEvent( trail, 'cancel', pointer, event, true );
      
      // touch pointers are transient, so fire exit/out to the trail afterwards
      if ( pointer.isTouch ) {
        this.exitEvents( pointer, event, trail, 0, true );
      }
      
      pointer.trail = trail;
    },
    
    // return whether there was a change
    branchChangeEvents: function( pointer, event, isMove ) {
      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );
      sceneryEventLog && sceneryEventLog( 'checking branch change: ' + trail.toString() + ' at ' + pointer.point.toString() );
      var oldTrail = pointer.trail || new scenery.Trail( this.scene ); // TODO: consider a static trail reference
      
      var lastNodeChanged = oldTrail.lastNode() !== trail.lastNode();
      if ( !lastNodeChanged && !isMove ) {
        // bail out if nothing needs to be done
        return false;
      }
      
      var branchIndex = scenery.Trail.branchIndex( trail, oldTrail );
      var isBranchChange = branchIndex !== trail.length || branchIndex !== oldTrail.length;
      sceneryEventLog && isBranchChange && sceneryEventLog( 'branch change from ' + oldTrail.toString() + ' to ' + trail.toString() );
      
      // event order matches http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
      if ( isMove ) {
        this.dispatchEvent( trail, 'move', pointer, event, true );
      }
      
      // we want to approximately mimic http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
      // TODO: if a node gets moved down 1 depth, it may see both an exit and enter?
      this.exitEvents( pointer, event, oldTrail, branchIndex, lastNodeChanged );
      this.enterEvents( pointer, event, trail, branchIndex, lastNodeChanged );
      
      pointer.trail = trail;
      return isBranchChange;
    },
    
    enterEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
      if ( trail.length > branchIndex ) {
        for ( var newIndex = trail.length - 1; newIndex >= branchIndex; newIndex-- ) {
          this.dispatchEvent( trail.slice( 0, newIndex + 1 ), 'enter', pointer, event, false );
        }
      }
      
      if ( lastNodeChanged ) {
        this.dispatchEvent( trail, 'over', pointer, event, true );
      }
    },
    
    exitEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
      if ( lastNodeChanged ) {
        this.dispatchEvent( trail, 'out', pointer, event, true );
      }
      
      if ( trail.length > branchIndex ) {
        for ( var oldIndex = branchIndex; oldIndex < trail.length; oldIndex++ ) {
          this.dispatchEvent( trail.slice( 0, oldIndex + 1 ), 'exit', pointer, event, false );
        }
      }
    },
    
    validatePointers: function() {
      var that = this;
      
      var i = this.pointers.length;
      while ( i-- ) {
        var pointer = this.pointers[i];
        if ( pointer.point ) {
          var changed = that.branchChangeEvents( pointer, null, false );
          if ( changed ) {
            sceneryEventLog && sceneryEventLog( 'branch change due validatePointers' );
          }
        }
      }
    },
    
    dispatchEvent: function( trail, type, pointer, event, bubbles ) {
      sceneryEventLog && sceneryEventLog( 'Input: ' + type + ' on ' + trail.toString() + ' for pointer ' + pointer.toString() + ' at ' + pointer.point.toString() );
      if ( !trail ) {
        try {
          throw new Error( 'falsy trail for dispatchEvent' );
        } catch ( e ) {
          console.log( e.stack );
          throw e;
        }
      }
      
      // TODO: is there a way to make this event immutable?
      var inputEvent = new scenery.Event( {
        trail: trail, // {Trail} path to the leaf-most node, ordered list, from root to leaf
        type: type, // {String} what event was triggered on the listener
        pointer: pointer, // {Pointer}
        domEvent: event, // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
        currentTarget: null, // {Node} whatever node you attached the listener to, null when passed to a Pointer,
        target: trail.lastNode() // {Node} leaf-most node in trail
      } );
      
      // first run through the pointer's listeners to see if one of them will handle the event
      this.dispatchToPointer( type, pointer, inputEvent );
      
      // if not yet handled, run through the trail in order to see if one of them will handle the event
      // at the base of the trail should be the scene node, so the scene will be notified last
      this.dispatchToTargets( trail, pointer, type, inputEvent, bubbles );
      
      // TODO: better interactivity handling?
      if ( !trail.lastNode().interactive && !pointer.isKey && event && event.preventDefault ) {
        event.preventDefault();
      }
    },
    
    // TODO: reduce code sharing between here and dispatchToTargets!
    dispatchToPointer: function( type, pointer, inputEvent ) {
      if ( inputEvent.aborted || inputEvent.handled ) {
        return;
      }
      
      var specificType = pointer.type + type; // e.g. mouseup, touchup, keyup
      
      var pointerListeners = pointer.listeners.slice( 0 ); // defensive copy
      for ( var i = 0; i < pointerListeners.length; i++ ) {
        var listener = pointerListeners[i];
        
        // if a listener returns true, don't handle any more
        var aborted = false;
        
        if ( !aborted && listener[specificType] ) {
          listener[specificType]( inputEvent );
          aborted = inputEvent.aborted;
        }
        if ( !aborted && listener[type] ) {
          listener[type]( inputEvent );
          aborted = inputEvent.aborted;
        }
        
        // bail out if the event is aborted, so no other listeners are triggered
        if ( aborted ) {
          return;
        }
      }
    },
    
    dispatchToTargets: function( trail, pointer, type, inputEvent, bubbles ) {
      if ( inputEvent.aborted || inputEvent.handled ) {
        return;
      }
      
      var specificType = pointer.type + type; // e.g. mouseup, touchup, keyup
      
      for ( var i = trail.length - 1; i >= 0; bubbles ? i-- : i = -1 ) {
        var target = trail.nodes[i];
        inputEvent.currentTarget = target;
        
        var listeners = target.getInputListeners();
        
        for ( var k = 0; k < listeners.length; k++ ) {
          var listener = listeners[k];
          
          // if a listener returns true, don't handle any more
          var aborted = false;
          
          if ( !aborted && listener[specificType] ) {
            listener[specificType]( inputEvent );
            aborted = inputEvent.aborted;
          }
          if ( !aborted && listener[type] ) {
            listener[type]( inputEvent );
            aborted = inputEvent.aborted;
          }
          
          // bail out if the event is aborted, so no other listeners are triggered
          if ( aborted ) {
            return;
          }
        }
        
        // if the input event was handled, don't follow the trail down another level
        if ( inputEvent.handled ) {
          return;
        }
      }
    },
    
    addListener: function( type, callback, useCapture ) {
      var input = this;
      
      //Cancel propagation of mouse events but not key events.  Key Events need to propagate for tab navigability
      var usePreventDefault = type !== 'keydown' && type !== 'keyup' && type !== 'keypress';
      
      // work around iOS Safari 7 not sending touch events to Scenes contained in an iframe
      if ( this.listenerTarget === window ) {
        document.addEventListener( type, function( domEvent ) {} );
      }
      
      if ( this.batchDOMEvents ) {
        var batchedCallback = function batchedEvent( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'Batching event for ' + type );
          
          if ( usePreventDefault ) {
            domEvent.preventDefault(); // TODO: should we batch the events in a different place so we don't preventDefault on something bad?
          }
          input.batchedCallbacks.push( function batchedEventCallback() {
            // process whether anything under the pointers changed before running additional input events
            sceneryEventLog && sceneryEventLog( 'validatePointers from batched event' );
            input.validatePointers();
            if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }
            
            callback( domEvent );
          } );
        };
        this.listenerTarget.addEventListener( type, batchedCallback, useCapture );
        this.listenerReferences.push( { type: type, callback: batchedCallback, useCapture: useCapture } );
      } else {
        this.listenerTarget.addEventListener( type, callback, useCapture );
        this.listenerReferences.push( { type: type, callback: function synchronousEvent( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'Running event for ' + type );
          
          // process whether anything under the pointers changed before running additional input events
          sceneryEventLog && sceneryEventLog( 'validatePointers from non-batched event' );
          input.validatePointers();
          if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }
          
          callback( domEvent );
        }, useCapture: useCapture } );
      }
    },
    
    // temporary, for mouse events
    addImmediateListener: function( type, callback, useCapture ) {
      this.listenerTarget.addEventListener( type, callback, useCapture );
      this.listenerReferences.push( { type: type, callback: function immediateEvent( domEvent ) {
        sceneryEventLog && sceneryEventLog( 'Running immediate event for ' + type );
        
        // process whether anything under the pointers changed before running additional input events
        // input.validatePointers();
        // if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }
        
        callback( domEvent );
      }, useCapture: useCapture } );
    },
    
    disposeListeners: function() {
      var input = this;
      _.each( this.listenerReferences, function( ref ) {
        input.listenerTarget.removeEventListener( ref.type, ref.callback, ref.useCapture );
      } );
    },
    
    fireBatchedEvents: function() {
      if ( this.batchedCallbacks.length ) {
        sceneryEventLog && sceneryEventLog( 'Input.fireBatchedEvents length:' + this.batchedCallbacks.length );
        var len = this.batchedCallbacks.length;
        for ( var i = 0; i < len; i++ ) {
          this.batchedCallbacks[i]();
        }
        this.batchedCallbacks.length = 0;
      }
    }
  };
  
  Input.serializeDomEvent = function serializeDomEvent( domEvent ) {
    var lines = [];
    for ( var prop in domEvent ) {
      if ( domEvent.hasOwnProperty( prop ) ) {
        // stringifying dom event object properties can cause circular references, so we avoid that completely
        if ( prop === 'touches' || prop === 'targetTouches' || prop === 'changedTouches' ) {
          var arr = [];
          for ( var i = 0; i < domEvent[prop].length; i++ ) {
            // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
            var touch = domEvent[prop].item( i );
            
            arr.push( serializeDomEvent( touch ) );
          }
          lines.push( prop + ':[' + arr.join( ',' ) + ']' );
        } else {
          lines.push( prop + ':' + ( ( typeof domEvent[prop] === 'object' ) && ( domEvent[prop] !== null ) ? '{}' : JSON.stringify( domEvent[prop] ) ) );
        }
      }
    }
    return '{' + lines.join( ',' ) + '}';
  };
  
  Input.serializeVector2 = function( vector ) {
    return 'dot(' + vector.x + ',' + vector.y + ')';
  };
  
  return Input;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Basic dragging for a node.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/input/SimpleDragHandler',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  /*
   * Allowed options: {
   *    allowTouchSnag: false // allow touch swipes across an object to pick it up. If a function is passed, the value allowTouchSnag( event ) is used
   *    dragCursor: 'pointer' // while dragging with the mouse, sets the cursor to this value (or use null to not override the cursor while dragging)
   *    mouseButton: 0        // allow changing the mouse button that activates the drag listener. -1 should activate on any mouse button, 0 on left, 1 for middle, 2 for right, etc.
   *    start: null           // if non-null, called when a drag is started. start( event, trail )
   *    drag: null            // if non-null, called when the user moves something with a drag (not a start or end event).
   *                                                                         drag( event, trail )
   *    end: null             // if non-null, called when a drag is ended.   end( event, trail )
   *    translate:            // if this exists, translate( { delta: _, oldPosition: _, position: _ } ) will be called.
   * }
   */
  scenery.SimpleDragHandler = function SimpleDragHandler( options ) {
    var handler = this;
    
    this.options = _.extend( {
      allowTouchSnag: false,
      mouseButton: 0,
      dragCursor: 'pointer'
    }, options );
    
    this.dragging              = false;     // whether a node is being dragged with this handler
    this.pointer               = null;      // the pointer doing the current dragging
    this.trail                 = null;      // stores the path to the node that is being dragged
    this.transform             = null;      // transform of the trail to our node (but not including our node, so we can prepend the deltas)
    this.node                  = null;      // the node that we are handling the drag for
    this.lastDragPoint         = null;      // the location of the drag at the previous event (so we can calculate a delta)
    this.startTransformMatrix  = null;      // the node's transform at the start of the drag, so we can reset on a touch cancel
    this.mouseButton           = undefined; // tracks which mouse button was pressed, so we can handle that specifically
    // TODO: consider mouse buttons as separate pointers?
    
    // if an ancestor is transformed, pin our node
    this.transformListener = {
      transform: function( args ) {
        if ( !handler.trail.isExtensionOf( args.trail, true ) ) {
          return;
        }
        
        var newMatrix = args.trail.getTransform().getMatrix();
        var oldMatrix = handler.transform.getMatrix();
        
        // if A was the trail's old transform, B is the trail's new transform, we need to apply (B^-1 A) to our node
        handler.node.prependMatrix( newMatrix.inverted().timesMatrix( oldMatrix ) );
        
        // store the new matrix so we can do deltas using it now
        handler.transform.setMatrix( newMatrix );
      }
    };
    
    // this listener gets added to the pointer when it starts dragging our node
    this.dragListener = {
      // mouse/touch up
      up: function( event ) {
        assert && assert( event.pointer === handler.pointer );
        if ( !event.pointer.isMouse || event.domEvent.button === handler.mouseButton ) {
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          handler.endDrag( event );
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      },
      
      // touch cancel
      cancel: function( event ) {
        assert && assert( event.pointer === handler.pointer );

        var saveCurrentTarget = event.currentTarget;
        event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
        handler.endDrag( event );
        event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget

        // since it's a cancel event, go back!
        if ( !handler.transform ) {
          handler.node.setMatrix( handler.startTransformMatrix );
        }
      },
      
      // mouse/touch move
      move: function( event ) {
        assert && assert( event.pointer === handler.pointer );
        
        var globalDelta = handler.pointer.point.minus( handler.lastDragPoint );
        
        // ignore move events that have 0-length (Chrome seems to be auto-firing these on Windows, see https://code.google.com/p/chromium/issues/detail?id=327114)
        if ( globalDelta.magnitudeSquared() === 0 ) {
          return;
        }
        
        var delta = handler.transform.inverseDelta2( globalDelta );
        
        // move by the delta between the previous point, using the precomputed transform
        // prepend the translation on the node, so we can ignore whatever other transform state the node has
        if ( handler.options.translate ) {
          var translation = handler.node.getTransform().getMatrix().getTranslation();
          handler.options.translate( {
            delta: delta,
            oldPosition: translation,
            position: translation.plus( delta )
          } );
        }
        handler.lastDragPoint = handler.pointer.point;
        
        if ( handler.options.drag ) {
          // TODO: consider adding in a delta to the listener
          // TODO: add the position in to the listener
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = handler.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          handler.options.drag( event, handler.trail ); // new position (old position?) delta
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      }
    };
  };
  var SimpleDragHandler = scenery.SimpleDragHandler;
  
  SimpleDragHandler.prototype = {
    constructor: SimpleDragHandler,
    
    startDrag: function( event ) {
      // set a flag on the pointer so it won't pick up other nodes
      event.pointer.active = true;
      event.pointer.cursor = this.options.dragCursor;
      event.pointer.addInputListener( this.dragListener );
      // event.trail.rootNode().addEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution
      
      // set all of our persistent information
      this.dragging = true;
      this.pointer = event.pointer;
      this.trail = event.trail.subtrailTo( event.currentTarget, true );
      this.transform = this.trail.getTransform();
      this.node = event.currentTarget;
      this.lastDragPoint = event.pointer.point;
      this.startTransformMatrix = event.currentTarget.getMatrix();
      // event.domEvent may not exist if this is touch-to-snag
      this.mouseButton = event.pointer.isMouse ? event.domEvent.button : undefined;
      
      if ( this.options.start ) {
        this.options.start( event, this.trail );
      }
    },
    
    endDrag: function( event ) {
      this.pointer.active = false;
      this.pointer.cursor = null;
      this.pointer.removeInputListener( this.dragListener );
      // this.trail.rootNode().removeEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution
      this.dragging = false;
      
      if ( this.options.end ) {
        this.options.end( event, this.trail );
      }
    },
    
    tryToSnag: function( event ) {
      // don't allow drag attempts that use the wrong mouse button (-1 indicates any mouse button works)
      if ( event.pointer.isMouse && event.domEvent && this.options.mouseButton !== event.domEvent.button && this.options.mouseButton !== -1 ) {
        return;
      }
      
      // only start dragging if the pointer isn't dragging anything, we aren't being dragged, and if it's a mouse it's button is down
      if ( !this.dragging && !event.pointer.active ) {
        this.startDrag( event );
      }
    },
    
    tryTouchToSnag: function( event ) {
      // allow touches to start a drag by moving "over" this node, and allows clients to specify custom logic for when touchSnag is allowable
      if ( this.options.allowTouchSnag && ( this.options.allowTouchSnag === true || this.options.allowTouchSnag( event ) ) ) {
        this.tryToSnag( event );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * events called from the node input listener
    *----------------------------------------------------------------------------*/
    
    // mouse/touch down on this node
    down: function( event ) {
      this.tryToSnag( event );
    },
    
    // touch enters this node
    touchenter: function( event ) {
      this.tryTouchToSnag( event );
    },
    
    // touch moves over this node
    touchmove: function( event ) {
      this.tryTouchToSnag( event );
    }
  };
  
  return SimpleDragHandler;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A conceptual boundary between layers, where it is optional to have information about a previous or next layer.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/LayerBoundary',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  scenery.LayerBoundary = function LayerBoundary() {
    // layer types before and after the boundary. null indicates the lack of information (first or last layer)
    this.previousLayerType = null;
    this.nextLayerType = null;
    
    // trails to the closest nodes with isPainted() === true before and after the boundary
    this.previousPaintedTrail = null;
    this.nextPaintedTrail = null;
  };
  var LayerBoundary = scenery.LayerBoundary;
  
  LayerBoundary.prototype = {
    constructor: LayerBoundary,
    
    hasPrevious: function() {
      return !!this.previousPaintedTrail;
    },
    
    hasNext: function() {
      return !!this.nextPaintedTrail;
    },
    
    // reindexes the trails
    reindex: function() {
      this.previousPaintedTrail && this.previousPaintedTrail.reindex();
      this.nextPaintedTrail && this.nextPaintedTrail.reindex();
    },
    
    // assumes that trail is reindexed
    equivalentPreviousTrail: function( trail ) {
      if ( this.previousPaintedTrail && trail ) {
        this.previousPaintedTrail.reindex();
        return this.previousPaintedTrail.equals( trail );
      } else {
        // check that handles null versions properly
        return this.previousPaintedTrail === trail;
      }
    },
    
    equivalentNextTrail: function( trail ) {
      if ( this.nextPaintedTrail && trail ) {
        this.nextPaintedTrail.reindex();
        return this.nextPaintedTrail.equals( trail );
      } else {
        // check that handles null versions properly
        return this.nextPaintedTrail === trail;
      }
    },
    
    toString: function() {
      return 'boundary:' +
             '\n    types:    ' +
                  ( this.previousLayerType ? this.previousLayerType.name : '' ) +
                  ' => ' +
                  ( this.nextLayerType ? this.nextLayerType.name : '' ) +
             '\n    trails:   ' +
                  ( this.previousPaintedTrail ? this.previousPaintedTrail.getUniqueId() : '' ) +
                  ' => ' +
                  ( this.nextPaintedTrail ? this.nextPaintedTrail.getUniqueId() : '' );
    }
  };
  
  return LayerBoundary;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Controls the underlying layer behavior around a node. The node's LayerStrategy's enter() and exit() will be
 * called in a depth-first order during the layer building process, and will modify a LayerBuilder to signal any
 * layer-specific signals.
 *
 * This generally ensures that a layer containing the proper renderer and settings to support its associated node
 * will be created.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/LayerStrategy',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  /*
   * If the node specifies a renderer, we will always push a preferred type. That type will be fresh (if rendererOptions are specified), otherwise
   * the top matching preferred type for that renderer will be used. This allows us to always pop in the exit().
   *
   * Specified as such, since there is no needed shared state (we can have node.layerStrategy = scenery.LayerStrategy for many nodes)
   */
  scenery.LayerStrategy = {
    // true iff enter/exit will push/pop a layer type to the preferred stack. currently limited to only one layer type per level.
    hasPreferredLayerType: function( pointer, layerBuilder ) {
      return pointer.trail.lastNode().hasRenderer();
    },
    
    getPreferredLayerType: function( pointer, layerBuilder ) {
      assert && assert( this.hasPreferredLayerType( pointer, layerBuilder ) ); // sanity check
      
      var node = pointer.trail.lastNode();
      var preferredLayerType;
      
      if ( node.hasRendererLayerType() ) {
        preferredLayerType = node.getRendererLayerType();
      } else {
        preferredLayerType = layerBuilder.bestPreferredLayerTypeFor( node.getRenderer().bitmask );
        if ( !preferredLayerType ) {
          // there was no preferred layer type matching, just use the default
          preferredLayerType = node.getRenderer().defaultLayerType;
        }
      }
      
      return preferredLayerType;
    },
    
    enter: function( pointer, layerBuilder ) {
      var trail = pointer.trail;
      var node = trail.lastNode();
      var preferredLayerType;
      
      // if the node has a renderer, always push a layer type, so that we can pop on the exit() and ensure consistent behavior
      if ( node.hasRenderer() ) {
        preferredLayerType = this.getPreferredLayerType( pointer, layerBuilder );
        
        // push the preferred layer type
        layerBuilder.pushPreferredLayerType( preferredLayerType );
        if ( layerBuilder.getCurrentLayerType() !== preferredLayerType ) {
          layerBuilder.switchToType( pointer, preferredLayerType );
        }
      } else if ( node.isPainted() ) {
        // node doesn't specify a renderer, but isPainted.
        
        var currentType = layerBuilder.getCurrentLayerType();
        preferredLayerType = layerBuilder.bestPreferredLayerTypeFor( node._rendererBitmask );
        
        // If any of the preferred types are compatible, use the top one. This allows us to support caching and hierarchical layer types
        if ( preferredLayerType ) {
          if ( currentType !== preferredLayerType ) {
            layerBuilder.switchToType( pointer, preferredLayerType );
          }
        } else {
          // if no preferred types are compatible, only switch if the current type is also incompatible
          if ( !currentType || !currentType.supportsNode( node ) ) {
            layerBuilder.switchToType( pointer, node.pickARenderer().defaultLayerType );
          }
        }
      }
      
      if ( node.isLayerSplit() || this.hasSplitFlags( node ) ) {
        layerBuilder.switchToType( pointer, layerBuilder.getCurrentLayerType() );
      }
      
      if ( node.isPainted() ) {
        // trigger actual layer creation if necessary (allow collapsing of layers otherwise)
        layerBuilder.markPainted( pointer );
      }
    },
    
    // afterSelf: function( trail, layerBuilder ) {
    //   // no-op, and possibly not used
    // },
    
    // betweenChildren: function( trail, layerBuilder ) {
    //   // no-op, and possibly not used
    // },
    
    exit: function( pointer, layerBuilder ) {
      var trail = pointer.trail;
      var node = trail.lastNode();
      
      if ( node.hasRenderer() ) {
        layerBuilder.popPreferredLayerType();
        
        // switch down to the next lowest preferred layer type, if any. if null, pass the null to switchToType
        // this allows us to not 'leak' the renderer information, and the temporary layer type is most likely collapsed and ignored
        // NOTE: disabled for now, since this prevents us from having adjacent children sharing the same layer type
        // if ( layerBuilder.getCurrentLayerType() !== layerBuilder.getPreferredLayerType() ) {
        //   layerBuilder.switchToType( pointer, layerBuilder.getPreferredLayerType() );
        // }
      }
      
      if ( node.isLayerSplit() || this.hasSplitFlags( node ) ) {
        layerBuilder.switchToType( pointer, layerBuilder.getCurrentLayerType() );
      }
    },
    
    // whether splitting before and after the node is required
    hasSplitFlags: function( node ) {
      // currently, only enforce splitting if we are using CSS transforms
      var rendererOptions = node.getRendererOptions();
      return node.hasRenderer() && rendererOptions && (
        rendererOptions.cssTranslation ||
        rendererOptions.cssRotation ||
        rendererOptions.cssScale ||
        rendererOptions.cssTransform
      );
    }
  };
  var LayerStrategy = scenery.LayerStrategy;
  
  return LayerStrategy;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A layer state is used to construct layer information (and later, layers), and is a state machine
 * that layer strategies from each node modify. Iterating through all of the nodes in a depth-first
 * manner will modify the LayerBuilder so that layer information can be retrieved.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/layers/LayerBuilder',['require','SCENERY/scenery','SCENERY/layers/LayerBoundary','SCENERY/util/Trail','SCENERY/util/TrailPointer','SCENERY/layers/LayerStrategy'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/layers/LayerBoundary' );
  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/util/TrailPointer' );
  var LayerStrategy = require( 'SCENERY/layers/LayerStrategy' ); // used to set the default layer strategy on the prototype
  
  /*
   * Builds layer information between trails
   *
   * previousLayerType should be null if there is no previous layer.
   */
  scenery.LayerBuilder = function LayerBuilder( scene, previousLayerType, previousPaintedTrail, nextPaintedTrail ) {
    
    /*---------------------------------------------------------------------------*
    * Initial state
    *----------------------------------------------------------------------------*/
    
    this.layerTypeStack = [];
    this.boundaries = [];
    this.pendingBoundary = new scenery.LayerBoundary();
    this.pendingBoundary.previousLayerType = previousLayerType;
    this.pendingBoundary.previousPaintedTrail = previousPaintedTrail;
    
    /*
     * The current layer type active, and whether it has been 'used' yet. A node with isPainted() will trigger a 'used' action,
     * and if the layer hasn't been used, it will actually trigger a boundary creation. We want to collapse 'unused' layers
     * and boundaries together, so that every created layer has a node that displays something.
     */
    this.currentLayerType = previousLayerType;
    this.layerChangePending = previousPaintedTrail === null;
    
    /*---------------------------------------------------------------------------*
    * Start / End pointers
    *----------------------------------------------------------------------------*/
    
    if ( previousPaintedTrail ) {
      // Move our start pointer just past the previousPaintedTrail, since our previousLayerType is presumably for that trail's node's self.
      // Anything after that self could have been collapsed, so we need to start there.
      this.startPointer = new scenery.TrailPointer( previousPaintedTrail.copy(), true );
      this.startPointer.nestedForwards();
    } else {
      this.startPointer = new scenery.TrailPointer( new scenery.Trail( scene ), true );
    }
    
    if ( nextPaintedTrail ) {
      // include the nextPaintedTrail's 'before' in our iteration, so we can stitch properly with the next layer
      this.endPointer = new scenery.TrailPointer( nextPaintedTrail.copy(), true );
    } else {
      this.endPointer = new scenery.TrailPointer( new scenery.Trail( scene ), false );
    }
    
    this.includesEndTrail = nextPaintedTrail !== null;
    
    /*
     * LayerBoundary properties and assurances:
     *
     * previousLayerType  - initialized in constructor (in case there are no layer changes)
     *                      set in layerChange for "fresh" pending boundary
     * nextLayerType      - set and overwrites in switchToType, for collapsing layers
     *                      not set anywhere else, so we can leave it null
     * previousPaintedTrail  - initialized in constructor
     *                      updated in markPainted if there is no pending change (don't set if there is a pending change)
     * nextPaintedTrail      - set on layerChange for "stale" boundary
     *                      stays null if nextPaintedTrail === null
     */
  };
  var LayerBuilder = scenery.LayerBuilder;
  
  LayerBuilder.prototype = {
    constructor: LayerBuilder,
    
    // walks part of the state up to just before the startPointer. we want the preferred layer stack to be in place, but the rest is not important
    prepareLayerStack: function() {
      var pointer = new scenery.TrailPointer( new scenery.Trail( this.startPointer.trail.rootNode() ), true );
      
      // if the start pointer is going to execute an exit() instead of an enter() on its trail node, we need to bump up the layer stack an additional step
      var targetLength = this.startPointer.trail.length - ( this.startPointer.isBefore ? 1 : 0 );
      
      while ( pointer.trail.length <= targetLength ) {
        if ( LayerStrategy.hasPreferredLayerType( pointer, this ) ) {
          this.pushPreferredLayerType( LayerStrategy.getPreferredLayerType( pointer, this ) );
        }
        if ( pointer.trail.length < this.startPointer.trail.nodes.length ) {
          pointer.trail.addDescendant( this.startPointer.trail.nodes[pointer.trail.length] );
        } else {
          // TODO: a cleaner way of doing this, since we were adding undefined into a trail to cause the loop to exit
          break;
        }
      }
    },
    
    run: function() {
      var builder = this;
      
      // push preferred layers for ancestors of our start pointer
      this.prepareLayerStack();
      
      // console.log( '         stack: ' + _.map( builder.layerTypeStack, function( type ) { return type.name; } ).join( ', ' ) );
      
      builder.startPointer.depthFirstUntil( builder.endPointer, function( pointer ) {
        if ( pointer.isBefore ) {
          // console.log( 'builder: enter ' + pointer.toString() );
          LayerStrategy.enter( pointer, builder );
        } else {
          // console.log( 'builder: exit ' + pointer.toString() );
          LayerStrategy.exit( pointer, builder );
        }
        // console.log( '         stack: ' + _.map( builder.layerTypeStack, function( type ) { return type.name; } ).join( ', ' ) );
      }, false ); // include the endpoints
      
      // special case handling if we are at the 'end' of the scene, so that we create another 'wrapping' boundary
      if ( !this.includesEndTrail ) {
        // console.log( 'builder: not including end trail' );
        this.layerChange( null );
      }
    },
    
    // allows paintedPointer === null at the end if the main iteration's nextPaintedTrail === null (i.e. we are at the end of the scene)
    layerChange: function( paintedPointer ) {
      this.layerChangePending = false;
      
      var confirmedBoundary = this.pendingBoundary;
      
      confirmedBoundary.nextPaintedTrail = paintedPointer ? paintedPointer.trail.copy() : null;
      
      this.boundaries.push( confirmedBoundary );
      
      this.pendingBoundary = new scenery.LayerBoundary();
      this.pendingBoundary.previousLayerType = confirmedBoundary.nextLayerType;
      this.pendingBoundary.previousPaintedTrail = confirmedBoundary.nextPaintedTrail;
      // console.log( 'builder:   added boundary' );
    },
    
    /*---------------------------------------------------------------------------*
    * API for layer strategy or other interaction
    *----------------------------------------------------------------------------*/
    
    switchToType: function( pointer, layerType ) {
      this.currentLayerType = layerType;
      
      this.pendingBoundary.nextLayerType = layerType;
      
      this.layerChangePending = true; // we wait until the first markPainted() call to create a boundary
    },
    
    // called so that we can finalize a layer switch (instead of collapsing unneeded layers)
    markPainted: function( pointer ) {
      if ( this.layerChangePending ) {
        this.layerChange( pointer );
      } else {
        // TODO: performance-wise, don't lookup indices on this copy? make a way to create a lightweight copy?
        this.pendingBoundary.previousPaintedTrail = pointer.trail.copy();
      }
    },
    
    // can be null to indicate that there is no current layer type
    getCurrentLayerType: function() {
      return this.currentLayerType;
    },
    
    pushPreferredLayerType: function( layerType ) {
      this.layerTypeStack.push( layerType );
    },
    
    popPreferredLayerType: function() {
      this.layerTypeStack.pop();
    },
    
    getPreferredLayerType: function() {
      if ( this.layerTypeStack.length !== 0 ) {
        return this.layerTypeStack[this.layerTypeStack.length - 1];
      } else {
        return null;
      }
    },
    
    bestPreferredLayerTypeFor: function( bitmask ) {
      for ( var i = this.layerTypeStack.length - 1; i >= 0; i-- ) {
        var preferredType = this.layerTypeStack[i];
        
        if ( preferredType.supportsBitmask( bitmask ) ) {
          return preferredType;
        }
      }
      
      // none of our stored preferred layer types are able to support any of the default type options
      return null;
    }
  };
  
  return LayerBuilder;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A node that can be custom-drawn with Canvas calls. Manual handling of dirty region repainting.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/CanvasNode',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var Node = require( 'SCENERY/nodes/Node' );
  require( 'SCENERY/layers/Renderer' );
  
  // pass a canvasBounds option if you want to specify the self bounds
  scenery.CanvasNode = function CanvasNode( options ) {
    Node.call( this, options );
    this.setRendererBitmask( scenery.bitmaskSupportsCanvas );
    
    if ( options && options.canvasBounds ) {
      this.setCanvasBounds( options.canvasBounds );
    }
  };
  var CanvasNode = scenery.CanvasNode;
  
  inherit( Node, CanvasNode, {
    
    // how to set the bounds of the CanvasNode
    setCanvasBounds: function( selfBounds ) {
      this.invalidateSelf( selfBounds );
    },
    
    isPainted: function() {
      return true;
    },
    
    // override paintCanvas with a faster version, since fillRect and drawRect don't affect the current default path
    paintCanvas: function( wrapper ) {
      throw new Error( 'CanvasNode needs paintCanvas implemented' );
    },
    
    // override for computation of whether a point is inside the self content
    // point is considered to be in the local coordinate frame
    containsPointSelf: function( point ) {
      return false;
      // throw new Error( 'CanvasNode needs containsPointSelf implemented' );
    },
    
    // whether this node's self intersects the specified bounds, in the local coordinate frame
    // intersectsBoundsSelf: function( bounds ) {
    //   // TODO: implement?
    // },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.CanvasNode( {' + propLines + '} )'; // TODO: no real way to do this nicely?
    }
    
  } );
  
  return CanvasNode;
} );



// Copyright 2002-2014, University of Colorado Boulder

/**
 * Code for testing which platform is running.  Use sparingly, if at all!
 *
 * Sample usage:
 * if (platform.firefox) {node.renderer = 'canvas';}
 *
 * @author Sam Reid
 */
define( 'PHET_CORE/platform',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  var ua = navigator.userAgent;
  
  // taken from HomeScreen
  function isIE( version ) {
    var r = new RegExp( 'msie' + (!isNaN( version ) ? ('\\s' + version) : ''), 'i' );
    return r.test( ua );
  }
  
  var platform = core.platform = {
    get firefox() { return ua.toLowerCase().indexOf( 'firefox' ) > -1; },

    //see http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari
    get mobileSafari() { return ua.match( /(iPod|iPhone|iPad)/ ) && ua.match( /AppleWebKit/ ); },
    get safari5() { return ua.match( /Version\/5\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ); },
    get safari6() { return ua.match( /Version\/6\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ); },
    get safari7() { return ua.match( /Version\/7\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ); },
    
    get ie9() { return isIE( 9 ); },
    get ie10() { return isIE( 10 ); },
    get ie11() { return isIE( 11 ); },
    get ie() { return ua.indexOf( 'MSIE' ) !== -1; },
    
    // from HomeScreen
    get android() { return ua.indexOf( 'Android' ) > 0; }
  };
  return platform;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Mix-in for nodes that support a standard fill.
 *
 * TODO: pattern and gradient handling
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Fillable',['require','SCENERY/scenery','PHET_CORE/platform'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  var platform = require( 'PHET_CORE/platform' );
  
  var isSafari5 = platform.safari5;
  
  scenery.Fillable = function Fillable( type ) {
    var proto = type.prototype;
    
    // this should be called in the constructor to initialize
    proto.initializeFillable = function() {
      this._fill = null;
      this._fillPickable = true;
      
      var that = this;
      this._fillListener = function() {
        that.invalidatePaint(); // TODO: move this to invalidateFill?
        that.invalidateFill();
      };
    };
    
    proto.hasFill = function() {
      return this._fill !== null;
    };
    
    proto.getFill = function() {
      return this._fill;
    };
    
    proto.setFill = function( fill ) {
      if ( this.getFill() !== fill ) {
        var hasInstances = this._instances.length > 0;
        
        if ( hasInstances && this._fill && this._fill.removeChangeListener ) {
          this._fill.removeChangeListener( this._fillListener );
        }
        
        this._fill = fill;
        
        if ( hasInstances && this._fill && this._fill.addChangeListener ) {
          this._fill.addChangeListener( this._fillListener );
        }
        
        this.invalidatePaint();
        
        this.invalidateFill();
      }
      return this;
    };
    
    proto.isFillPickable = function() {
      return this._fillPickable;
    };
    
    proto.setFillPickable = function( pickable ) {
      assert && assert( typeof pickable === 'boolean' );
      if ( this._fillPickable !== pickable ) {
        this._fillPickable = pickable;
        
        // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
        this.invalidateFill();
      }
      return this;
    };
    
    var superFirstInstanceAdded = proto.firstInstanceAdded;
    proto.firstInstanceAdded = function() {
      if ( this._fill && this._fill.addChangeListener ) {
        this._fill.addChangeListener( this._fillListener );
      }
      
      if ( superFirstInstanceAdded ) {
        superFirstInstanceAdded.call( this );
      }
    };
    
    var superLastInstanceRemoved = proto.lastInstanceRemoved;
    proto.lastInstanceRemoved = function() {
      if ( this._fill && this._fill.removeChangeListener ) {
        this._fill.removeChangeListener( this._fillListener );
      }
      
      if ( superLastInstanceRemoved ) {
        superLastInstanceRemoved.call( this );
      }
    };
    
    proto.beforeCanvasFill = function( wrapper ) {
      wrapper.setFillStyle( this._fill );
      if ( this._fill.transformMatrix ) {
        wrapper.context.save();
        this._fill.transformMatrix.canvasAppendTransform( wrapper.context );
      }
    };
    
    proto.afterCanvasFill = function( wrapper ) {
      if ( this._fill.transformMatrix ) {
        wrapper.context.restore();
      }
    };
    
    proto.getSVGFillStyle = function() {
      var style = 'fill: ';
      if ( !this._fill ) {
        // no fill
        style += 'none;';
      } else if ( this._fill.toCSS ) {
        // Color object fill
        style += this._fill.toCSS() + ';';
      } else if ( this._fill.getSVGDefinition ) {
        // reference the SVG definition with a URL
        style += 'url(#fill' + this.getId() + ');';
      } else {
        // plain CSS color
        style += this._fill + ';';
      }
      return style;
    };
    
    proto.getCSSFill = function() {
      // if it's a Color object, get the corresponding CSS
      // 'transparent' will make us invisible if the fill is null
      return this._fill ? ( this._fill.toCSS ? this._fill.toCSS() : this._fill ) : 'transparent';
    };
    
    proto.addSVGFillDef = function( svg, defs ) {
      var fill = this.getFill();
      var fillId = 'fill' + this.getId();
      
      // add new definitions if necessary
      if ( fill && fill.getSVGDefinition ) {
        defs.appendChild( fill.getSVGDefinition( fillId ) );
      }
    };
    
    proto.removeSVGFillDef = function( svg, defs ) {
      var fillId = 'fill' + this.getId();
      
      // wipe away any old definition
      var oldFillDef = svg.getElementById( fillId );
      if ( oldFillDef ) {
        defs.removeChild( oldFillDef );
      }
    };
    
    proto.appendFillablePropString = function( spaces, result ) {
      if ( this._fill ) {
        if ( result ) {
          result += ',\n';
        }
        if ( typeof this._fill === 'string' ) {
          result += spaces + 'fill: \'' + this._fill + '\'';
        } else {
          result += spaces + 'fill: ' + this._fill.toString();
        }
      }
      
      return result;
    };
    
    proto.getFillRendererBitmask = function() {
      var bitmask = 0;
      
      // Safari 5 has buggy issues with SVG gradients
      if ( !( isSafari5 && this._fill && this._fill.isGradient ) ) {
        bitmask |= scenery.bitmaskSupportsSVG;
      }
      
      // we always have Canvas support?
      bitmask |= scenery.bitmaskSupportsCanvas;
      
      if ( !this._fill ) {
        // if there is no fill, it is supported by DOM
        bitmask |= scenery.bitmaskSupportsDOM;
      } else if ( this._fill.isPattern ) {
        // no pattern support for DOM (for now!)
      } else if ( this._fill.isGradient ) {
        // no gradient support for DOM (for now!)
      } else {
        // solid fills always supported for DOM
        bitmask |= scenery.bitmaskSupportsDOM;
      }
      
      return bitmask;
    };
    
    // on mutation, set the fill parameter first
    proto._mutatorKeys = [ 'fill', 'fillPickable' ].concat( proto._mutatorKeys );
    
    Object.defineProperty( proto, 'fill', { set: proto.setFill, get: proto.getFill } );
    Object.defineProperty( proto, 'fillPickable', { set: proto.setFillPickable, get: proto.isFillPickable } );
    
    if ( proto.invalidateFill ) {
      var oldInvalidateFill = proto.invalidateFill;
      proto.invalidateFill = function() {
        this.invalidateSupportedRenderers();
        oldInvalidateFill.call( this );
      };
    } else {
      proto.invalidateFill = function() {
        this.invalidateSupportedRenderers();
      };
    }
  };
  var Fillable = scenery.Fillable;
  
  return Fillable;
} );



// Copyright 2002-2013, University of Colorado

/**
 * Mix-in for nodes that support a standard stroke.
 *
 * TODO: miterLimit handling
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Strokable',['require','SCENERY/scenery','KITE/util/LineStyles','PHET_CORE/platform'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  var LineStyles = require( 'KITE/util/LineStyles' );
  
  var platform = require( 'PHET_CORE/platform' );
  
  var isIE9 = platform.ie9;
  
  scenery.Strokable = function Strokable( type ) {
    var proto = type.prototype;
    
    // this should be called in the constructor to initialize
    proto.initializeStrokable = function() {
      this._stroke = null;
      this._strokePickable = false;
      this._lineDrawingStyles = new LineStyles();
      
      var that = this;
      this._strokeListener = function() {
        that.invalidatePaint(); // TODO: move this to invalidateStroke?
        that.invalidateStroke();
      };
    };
    
    proto.hasStroke = function() {
      return this._stroke !== null;
    };
    
    // TODO: setting these properties looks like a good candidate for refactoring to lessen file size
    proto.getLineWidth = function() {
      return this._lineDrawingStyles.lineWidth;
    };
    
    proto.setLineWidth = function( lineWidth ) {
      if ( this.getLineWidth() !== lineWidth ) {
        this.markOldSelfPaint(); // since the previous line width may have been wider
        
        this._lineDrawingStyles.lineWidth = lineWidth;
        
        this.invalidateStroke();
      }
      return this;
    };
    
    proto.getLineCap = function() {
      return this._lineDrawingStyles.lineCap;
    };
    
    proto.setLineCap = function( lineCap ) {
      if ( this._lineDrawingStyles.lineCap !== lineCap ) {
        this.markOldSelfPaint();
        
        this._lineDrawingStyles.lineCap = lineCap;
        
        this.invalidateStroke();
      }
      return this;
    };
    
    proto.getLineJoin = function() {
      return this._lineDrawingStyles.lineJoin;
    };
    
    proto.setLineJoin = function( lineJoin ) {
      if ( this._lineDrawingStyles.lineJoin !== lineJoin ) {
        this.markOldSelfPaint();
        
        this._lineDrawingStyles.lineJoin = lineJoin;
        
        this.invalidateStroke();
      }
      return this;
    };
    
    proto.getLineDash = function() {
      return this._lineDrawingStyles.lineDash;
    };
    
    proto.hasLineDash = function() {
      return !!this._lineDrawingStyles.lineDash.length;
    };
    
    proto.setLineDash = function( lineDash ) {
      if ( this._lineDrawingStyles.lineDash !== lineDash ) {
        this.markOldSelfPaint();
        
        this._lineDrawingStyles.lineDash = lineDash || [];
        
        this.invalidateStroke();
      }
      return this;
    };
    
    proto.getLineDashOffset = function() {
      return this._lineDrawingStyles.lineDashOffset;
    };
    
    proto.setLineDashOffset = function( lineDashOffset ) {
      if ( this._lineDrawingStyles.lineDashOffset !== lineDashOffset ) {
        this.markOldSelfPaint();
        
        this._lineDrawingStyles.lineDashOffset = lineDashOffset;
        
        this.invalidateStroke();
      }
      return this;
    };
    
    proto.isStrokePickable = function() {
      return this._strokePickable;
    };
    
    proto.setStrokePickable = function( pickable ) {
      assert && assert( typeof pickable === 'boolean' );
      if ( this._strokePickable !== pickable ) {
        this._strokePickable = pickable;
        
        // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
        this.invalidateStroke();
      }
      return this;
    };
    
    proto.setLineStyles = function( lineStyles ) {
      // TODO: since we have been using lineStyles as mutable for now, lack of change check is good here?
      this.markOldSelfPaint();
      
      this._lineDrawingStyles = lineStyles;
      this.invalidateStroke();
      return this;
    };
    
    proto.getLineStyles = function() {
      return this._lineDrawingStyles;
    };
    
    proto.getStroke = function() {
      return this._stroke;
    };
    
    proto.setStroke = function( stroke ) {
      if ( this.getStroke() !== stroke ) {
        // since this can actually change the bounds, we need to handle a few things differently than the fill
        this.markOldSelfPaint();
        
        var hasInstances = this._instances.length > 0;
        
        if ( hasInstances && this._stroke && this._stroke.removeChangeListener ) {
          this._stroke.removeChangeListener( this._strokeListener );
        }
        
        this._stroke = stroke;
        
        if ( hasInstances && this._stroke && this._stroke.addChangeListener ) {
          this._stroke.addChangeListener( this._strokeListener );
        }
        
        this.invalidateStroke();
      }
      return this;
    };
    
    var superFirstInstanceAdded = proto.firstInstanceAdded;
    proto.firstInstanceAdded = function() {
      if ( this._stroke && this._stroke.addChangeListener ) {
        this._stroke.addChangeListener( this._strokeListener );
      }
      
      if ( superFirstInstanceAdded ) {
        superFirstInstanceAdded.call( this );
      }
    };
    
    var superLastInstanceRemoved = proto.lastInstanceRemoved;
    proto.lastInstanceRemoved = function() {
      if ( this._stroke && this._stroke.removeChangeListener ) {
        this._stroke.removeChangeListener( this._strokeListener );
      }
      
      if ( superLastInstanceRemoved ) {
        superLastInstanceRemoved.call( this );
      }
    };
    
    proto.beforeCanvasStroke = function( wrapper ) {
      // TODO: is there a better way of not calling so many things on each stroke?
      wrapper.setStrokeStyle( this._stroke );
      wrapper.setLineWidth( this.getLineWidth() );
      wrapper.setLineCap( this.getLineCap() );
      wrapper.setLineJoin( this.getLineJoin() );
      wrapper.setLineDash( this.getLineDash() );
      wrapper.setLineDashOffset( this.getLineDashOffset() );
      if ( this._stroke.transformMatrix ) {
        wrapper.context.save();
        this._stroke.transformMatrix.canvasAppendTransform( wrapper.context );
      }
    };
    
    proto.afterCanvasStroke = function( wrapper ) {
      if ( this._stroke.transformMatrix ) {
        wrapper.context.restore();
      }
    };
    
    proto.getSVGStrokeStyle = function() {
      if ( !this._stroke ) {
        // no stroke
        return 'stroke: none;';
      }
      
      var style = 'stroke: ';
      if ( this._stroke.toCSS ) {
        // Color object stroke
        style += this._stroke.toCSS() + ';';
      } else if ( this._stroke.getSVGDefinition ) {
        // reference the SVG definition with a URL
        style += 'url(#stroke' + this.getId() + ');';
      } else {
        // plain CSS color
        style += this._stroke + ';';
      }
      
      // TODO: don't include unnecessary directives? - is it worth any branching cost?
      style += 'stroke-width: ' + this.getLineWidth() + ';';
      style += 'stroke-linecap: ' + this.getLineCap() + ';';
      style += 'stroke-linejoin: ' + this.getLineJoin() + ';';
      if ( this.hasLineDash() ) {
        style += 'stroke-dasharray: ' + this.getLineDash().join( ',' ) + ';';
        style += 'stroke-dashoffset: ' + this.getLineDashOffset() + ';';
      }
      
      return style;
    };
    
    // if we have to apply a transform workaround for https://github.com/phetsims/scenery/issues/196 (only when we have a pattern or gradient)
    proto.requiresSVGBoundsWorkaround = function() {
      if ( !this._stroke || !this._stroke.getSVGDefinition ) {
        return false;
      }
      
      var bounds = this.computeShapeBounds( false ); // without stroke
      return bounds.x * bounds.y === 0; // at least one of them was zero, so the bounding box has no area
    };
    
    proto.getSimpleCSSFill = function() {
      // if it's a Color object, get the corresponding CSS
      // 'transparent' will make us invisible if the fill is null
      return this._stroke ? ( this._stroke.toCSS ? this._stroke.toCSS() : this._stroke ) : 'transparent';
    };
    
    proto.addSVGStrokeDef = function( svg, defs ) {
      var stroke = this.getStroke();
      var strokeId = 'stroke' + this.getId();
      
      // add new definitions if necessary
      if ( stroke && stroke.getSVGDefinition ) {
        defs.appendChild( stroke.getSVGDefinition( strokeId ) );
      }
    };
    
    proto.removeSVGStrokeDef = function( svg, defs ) {
      var strokeId = 'stroke' + this.getId();
      
      // wipe away any old definition
      var oldStrokeDef = svg.getElementById( strokeId );
      if ( oldStrokeDef ) {
        defs.removeChild( oldStrokeDef );
      }
    };
    
    proto.appendStrokablePropString = function( spaces, result ) {
      var self = this;
      
      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        } else {
          result += spaces + key + ': ' + value;
        }
      }
      
      if ( this._stroke ) {
        var defaultStyles = new LineStyles();
        if ( typeof this._stroke === 'string' ) {
          addProp( 'stroke', this._stroke );
        } else {
          addProp( 'stroke', this._stroke.toString(), true );
        }
        
        _.each( [ 'lineWidth', 'lineCap', 'lineJoin', 'lineDashOffset' ], function( prop ) {
          if ( self[prop] !== defaultStyles[prop] ) {
            addProp( prop, self[prop] );
          }
        } );
        
        if ( this.lineDash.length ) {
          addProp( 'lineDash', JSON.stringify( this.lineDash ), true );
        }
      }
      
      return result;
    };
    
    proto.getStrokeRendererBitmask = function() {
      var bitmask = 0;
      
      if ( !( isIE9 && this.hasStroke() && this.hasLineDash() ) ) {
        bitmask |= scenery.bitmaskSupportsCanvas;
      }
      
      // always have SVG support (for now?)
      bitmask |= scenery.bitmaskSupportsSVG;
      
      if ( !this.hasStroke() ) {
        // allow DOM support if there is no stroke
        bitmask |= scenery.bitmaskSupportsDOM;
      }
      
      return bitmask;
    };
    
    // on mutation, set the stroke parameters first since they may affect the bounds (and thus later operations)
    proto._mutatorKeys = [ 'stroke', 'lineWidth', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset', 'strokePickable' ].concat( proto._mutatorKeys );
    
    // TODO: miterLimit support?
    Object.defineProperty( proto, 'stroke', { set: proto.setStroke, get: proto.getStroke } );
    Object.defineProperty( proto, 'lineWidth', { set: proto.setLineWidth, get: proto.getLineWidth } );
    Object.defineProperty( proto, 'lineCap', { set: proto.setLineCap, get: proto.getLineCap } );
    Object.defineProperty( proto, 'lineJoin', { set: proto.setLineJoin, get: proto.getLineJoin } );
    Object.defineProperty( proto, 'lineDash', { set: proto.setLineDash, get: proto.getLineDash } );
    Object.defineProperty( proto, 'lineDashOffset', { set: proto.setLineDashOffset, get: proto.getLineDashOffset } );
    Object.defineProperty( proto, 'strokePickable', { set: proto.setStrokePickable, get: proto.isStrokePickable } );
    
    if ( proto.invalidateStroke ) {
      var oldInvalidateStroke = proto.invalidateStroke;
      proto.invalidateStroke = function() {
        this.invalidateSupportedRenderers();
        oldInvalidateStroke.call( this );
      };
    } else {
      proto.invalidateStroke = function() {
        this.invalidateSupportedRenderers();
      };
    }
  };
  var Strokable = scenery.Strokable;
  
  return Strokable;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A Path draws a Shape with a specific type of fill and stroke.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Path',['require','PHET_CORE/inherit','KITE/Shape','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/nodes/Fillable','SCENERY/nodes/Strokable'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  require( 'SCENERY/layers/Renderer' );
  var Fillable = require( 'SCENERY/nodes/Fillable' );
  var Strokable = require( 'SCENERY/nodes/Strokable' );

  scenery.Path = function Path( shape, options ) {
    // TODO: consider directly passing in a shape object (or at least handling that case)
    // NOTE: _shape can be lazily constructed, in the case of types like Rectangle where they have their own drawing code
    this._shape = null;
    this._strokedShape = null; // a stroked copy of the shape, lazily computed

    // ensure we have a parameter object
    options = options || {};
    
    this.initializeFillable();
    this.initializeStrokable();

    Node.call( this );
    this.invalidateSupportedRenderers();
    this.setShape( shape );
    this.mutate( options );
  };
  var Path = scenery.Path;
  
  inherit( Node, Path, {
    // allow more specific path types (Rectangle, Line) to override what restrictions we have
    getPathRendererBitmask: function() {
      return scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG;
    },
    
    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getPathRendererBitmask() );
    },
    
    // sets the shape drawn, or null to remove the shape
    setShape: function( shape ) {
      if ( this._shape !== shape ) {
        if ( typeof shape === 'string' ) {
          // be content with setShape always invalidating the shape?
          shape = new Shape( shape );
        }
        this._shape = shape;
        this.invalidateShape();
      }
      return this;
    },
    
    getShape: function() {
      return this._shape;
    },
    
    getStrokedShape: function() {
      if ( !this._strokedShape ) {
        this._strokedShape = this.getShape().getStrokedShape( this._lineDrawingStyles );
      }
      return this._strokedShape;
    },
    
    invalidateShape: function() {
      this.markOldSelfPaint();
      
      this._strokedShape = null;
      
      if ( this.hasShape() ) {
        this.invalidateSelf( this.computeShapeBounds() );
        this.invalidatePaint();
      }
    },
    
    // separated out, so that we can override this with a faster version in subtypes. includes the Stroke, if any
    computeShapeBounds: function() {
      return this._stroke ? this.getStrokedShape().bounds : this.getShape().bounds;
    },
    
    // hook stroke mixin changes to invalidation
    invalidateStroke: function() {
      this.invalidateShape();
    },
    
    hasShape: function() {
      return this._shape;
    },
    
    paintCanvas: function( wrapper ) {
      var context = wrapper.context;
      
      if ( this.hasShape() ) {
        // TODO: fill/stroke delay optimizations?
        context.beginPath();
        this._shape.writeToContext( context );

        if ( this._fill ) {
          this.beforeCanvasFill( wrapper ); // defined in Fillable
          context.fill();
          this.afterCanvasFill( wrapper ); // defined in Fillable
        }
        if ( this._stroke ) {
          this.beforeCanvasStroke( wrapper ); // defined in Strokable
          context.stroke();
          this.afterCanvasStroke( wrapper ); // defined in Strokable
        }
      }
    },
    
    paintWebGL: function( state ) {
      throw new Error( 'Path.prototype.paintWebGL unimplemented' );
    },
    
    // svg element, the <defs> block, and the associated group for this node's transform
    createSVGFragment: function( svg, defs, group ) {
      return document.createElementNS( scenery.svgns, 'path' );
    },
    
    updateSVGFragment: function( path ) {
      var svgPath = this.hasShape() ? this._shape.getSVGPath() : "";
      
      // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
      // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
      // the attribute can cause this bug
      if ( !svgPath ) { svgPath = 'M0 0'; }
      
      if ( svgPath ) {
        // only set the SVG path if it's not the empty string
        path.setAttribute( 'd', svgPath );
      } else if ( path.hasAttribute( 'd' ) ) {
        path.removeAttribute( 'd' );
      }
      
      path.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
    },
    
    // support patterns, gradients, and anything else we need to put in the <defs> block
    updateSVGDefs: function( svg, defs ) {
      // remove old definitions if they exist
      this.removeSVGDefs( svg, defs );
      
      // add new ones if applicable
      this.addSVGFillDef( svg, defs );
      this.addSVGStrokeDef( svg, defs );
      
      assert && assert( !this.requiresSVGBoundsWorkaround(), 'No workaround for https://github.com/phetsims/scenery/issues/196 is provided at this time, please add an epsilon' );
    },
    
    // cleans up references created with udpateSVGDefs()
    removeSVGDefs: function( svg, defs ) {
      this.removeSVGFillDef( svg, defs );
      this.removeSVGStrokeDef( svg, defs );
    },
    
    isPainted: function() {
      return true;
    },
    
    // override for computation of whether a point is inside the self content
    // point is considered to be in the local coordinate frame
    containsPointSelf: function( point ) {
      var result = false;
      if ( !this.hasShape() ) {
        return result;
      }
      
      // if this node is fillPickable, we will return true if the point is inside our fill area
      if ( this._fillPickable ) {
        result = this.getShape().containsPoint( point );
      }
      
      // also include the stroked region in the hit area if strokePickable
      if ( !result && this._strokePickable ) {
        result = this.getStrokedShape().containsPoint( point );
      }
      return result;
    },
    
    // whether this node's self intersects the specified bounds, in the local coordinate frame
    intersectsBoundsSelf: function( bounds ) {
      // TODO: should a shape's stroke be included?
      return this.hasShape() ? this._shape.intersectsBounds( bounds ) : false;
    },
    
    set shape( value ) { this.setShape( value ); },
    get shape() { return this.getShape(); },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Path( ' + ( this._shape ? this._shape.toString() : this._shape ) + ', {' + propLines + '} )';
    },
    
    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      result = this.appendFillablePropString( spaces, result );
      result = this.appendStrokablePropString( spaces, result );
      return result;
    }
  } );
  
  Path.prototype._mutatorKeys = [ 'shape' ].concat( Node.prototype._mutatorKeys );
  
  // mix in fill/stroke handling code. for now, this is done after 'shape' is added to the mutatorKeys so that stroke parameters
  // get set first
  /* jshint -W064 */
  Fillable( Path );
  Strokable( Path );
  
  return Path;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A circular node that inherits Path, and allows for optimized drawing,
 * and improved parameter handling.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Circle',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','DOT/Matrix3','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/Features'],function( require ) {
  

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Features = require( 'SCENERY/util/Features' );

  scenery.Circle = function Circle( radius, options ) {
    if ( typeof radius === 'object' ) {
      // allow new Circle( { radius: ... } )
      // the mutators will call invalidateCircle() and properly set the shape
      options = radius;
      this._radius = options.radius;
    } else {
      this._radius = radius;

      // ensure we have a parameter object
      options = options || {};

    }
    // fallback for non-canvas or non-svg rendering, and for proper bounds computation

    Path.call( this, null, options );
  };
  var Circle = scenery.Circle;

  inherit( Path, Circle, {
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && this.getLineWidth() <= this.getRadius() ) {
        bitmask |= scenery.bitmaskSupportsDOM;
      }
      return bitmask;
    },
    
    getPathRendererBitmask: function() {
      return scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG | ( Features.borderRadius ? scenery.bitmaskSupportsDOM : 0 );
    },
    
    invalidateCircle: function() {
      assert && assert( this._radius >= 0, 'A circle needs a non-negative radius' );
      
      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;
      
      // should invalidate the path and ensure a redraw
      this.invalidateShape();
    },
    
    createCircleShape: function() {
      return Shape.circle( 0, 0, this._radius );
    },
    
    intersectsBoundsSelf: function( bounds ) {
      // TODO: handle intersection with somewhat-infinite bounds!
      var x = Math.abs( bounds.centerX );
      var y = Math.abs( bounds.centerY );
      var halfWidth = bounds.maxX - x;
      var halfHeight = bounds.maxY - y;
      
      // too far to have a possible intersection
      if ( x > halfWidth + this._radius || y > halfHeight + this._radius ) {
        return false;
      }
      
      // guaranteed intersection
      if ( x <= halfWidth || y <= halfHeight ) {
        return true;
      }
      
      // corner case
      x -= halfWidth;
      y -= halfHeight;
      return x * x + y * y <= this._radius * this._radius;
    },
    
    paintCanvas: function( wrapper ) {
      var context = wrapper.context;
      
      context.beginPath();
      context.arc( 0, 0, this._radius, 0, Math.PI * 2, false );
      context.closePath();
      
      if ( this._fill ) {
        this.beforeCanvasFill( wrapper ); // defined in Fillable
        context.fill();
        this.afterCanvasFill( wrapper ); // defined in Fillable
      }
      if ( this._stroke ) {
        this.beforeCanvasStroke( wrapper ); // defined in Strokable
        context.stroke();
        this.afterCanvasStroke( wrapper ); // defined in Strokable
      }
    },
    
    // create a circle instead of a path, hopefully it is faster in implementations
    createSVGFragment: function( svg, defs, group ) {
      return document.createElementNS( scenery.svgns, 'circle' );
    },

    // optimized for the circle element instead of path
    updateSVGFragment: function( circle ) {
      circle.setAttribute( 'r', this._radius );

      circle.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
    },
    
    /*---------------------------------------------------------------------------*
     * DOM support
     *----------------------------------------------------------------------------*/
    
    domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer
    
    getDOMElement: function() {
      var fill = document.createElement( 'div' );
      var stroke = document.createElement( 'div' );
      fill.appendChild( stroke );
      fill.style.display = 'block';
      fill.style.position = 'absolute';
      fill.style.left = '0';
      fill.style.top = '0';
      stroke.style.display = 'block';
      stroke.style.position = 'absolute';
      stroke.style.left = '0';
      stroke.style.top = '0';
      return fill;
    },

    updateDOMElement: function( fill ) {
      fill.style.width = ( 2 * this._radius ) + 'px';
      fill.style.height = ( 2 * this._radius ) + 'px';
      fill.style[Features.borderRadius] = this._radius + 'px';
      fill.style.backgroundColor = this.getCSSFill();
      
      var stroke = fill.childNodes[0];
      if ( this.hasStroke() ) {
        stroke.style.width = ( 2 * this._radius - this.getLineWidth() ) + 'px';
        stroke.style.height = ( 2 * this._radius - this.getLineWidth() ) + 'px';
        stroke.style.left = ( -this.getLineWidth() / 2 ) + 'px';
        stroke.style.top = ( -this.getLineWidth() / 2 ) + 'px';
        stroke.style.borderStyle = 'solid';
        stroke.style.borderColor = this.getSimpleCSSFill();
        stroke.style.borderWidth = this.getLineWidth() + 'px';
        stroke.style[Features.borderRadius] = ( this._radius + this.getLineWidth() / 2 ) + 'px';
      } else {
        stroke.style.borderStyle = 'none';
      }
    },
    
    // override the transform since we need to customize it with a DOM offset
    updateCSSTransform: function( transform, element ) {
      // shift the text vertically, postmultiplied with the entire transform.
      var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( -this._radius, -this._radius ) );
      scenery.Util.applyCSSTransform( matrix, element );
    },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Circle( ' + this._radius + ', {' + propLines + '} )';
    },

    getRadius: function() {
      return this._radius;
    },

    setRadius: function( radius ) {
      if ( this._radius !== radius ) {
        this._radius = radius;
        this.invalidateCircle();
      }
      return this;
    },

    computeShapeBounds: function() {
      var bounds = new Bounds2( -this._radius, -this._radius, this._radius, this._radius );
      if ( this._stroke ) {
        // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },

    // accelerated hit detection
    containsPointSelf: function( point ) {
      var magSq = point.x * point.x + point.y * point.y;
      var result = true;
      var iRadius;
      if ( this._strokePickable ) {
        iRadius = this.getLineWidth() / 2;
        var outerRadius = this._radius + iRadius;
        result = result && magSq <= outerRadius * outerRadius;
      }
      
      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          // we were either within the outer radius, or not
          return result;
        } else {
          // just testing in the fill range
          return magSq <= this._radius * this._radius;
        }
      } else if ( this._strokePickable ) {
        var innerRadius = this._radius - iRadius;
        return result && magSq >= innerRadius * innerRadius;
      } else {
        return false; // neither stroke nor fill is pickable
      }
    },

    get radius() { return this.getRadius(); },
    set radius( value ) { return this.setRadius( value ); },
    
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Circle to something non-null' );
      } else {
        // probably called from the Path constructor
        this.invalidateShape();
      }
    },
    
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createCircleShape();
      }
      return this._shape;
    },
    
    hasShape: function() {
      return true;
    }
  } );

  // not adding mutators for now
  Circle.prototype._mutatorKeys = [ 'radius' ].concat( Path.prototype._mutatorKeys );

  return Circle;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Escaping of HTML content that will be placed in the body, inside an element as a node.
 *
 * This is NOT for escaping something in other HTML contexts, for example as an attribute value
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/escapeHTML',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  var escapeHTML = core.escapeHTML = function escapeHTML( str ) {
    // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
    // HTML Entity Encoding
    return str.replace( /&/g, '&amp;' )
              .replace( /</g, '&lt;' )
              .replace( />/g, '&gt;' )
              .replace( /\"/g, '&quot;' )
              .replace( /\'/g, '&#x27;' )
              .replace( /\//g, '&#x2F;' );
  };
  return escapeHTML;
} );

// Copyright 2002-2013, University of Colorado

/**
 * DOM nodes. Currently lightweight handling
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/DOM',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/util/Util'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var escapeHTML = require( 'PHET_CORE/escapeHTML' );
  var Bounds2 = require( 'DOT/Bounds2' );
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Node = require( 'SCENERY/nodes/Node' ); // DOM inherits from Node
  require( 'SCENERY/layers/Renderer' );
  require( 'SCENERY/util/Util' );
  
  scenery.DOM = function DOM( element, options ) {
    options = options || {};
    
    this._interactive = false;
    
    // unwrap from jQuery if that is passed in, for consistency
    if ( element && element.jquery ) {
      element = element[0];
    }
    
    this._container = document.createElement( 'div' );
    this._$container = $( this._container );
    this._$container.css( 'position', 'absolute' );
    this._$container.css( 'left', 0 );
    this._$container.css( 'top', 0 );
    
    this.invalidateDOMLock = false;
    
    // so that the mutator will call setElement()
    options.element = element;
    
    // will set the element after initializing
    Node.call( this, options );
    this.setRendererBitmask( scenery.bitmaskSupportsDOM );
  };
  var DOM = scenery.DOM;
  
  inherit( Node, DOM, {
    // we use a single DOM instance, so this flag should indicate that we don't support duplicating it
    allowsMultipleDOMInstances: false,
    
    // needs to be attached to the DOM tree for this to work
    calculateDOMBounds: function() {
      // var boundingRect = this._element.getBoundingClientRect();
      // return new Bounds2( 0, 0, boundingRect.width, boundingRect.height );
      var $element = $( this._element );
      return new Bounds2( 0, 0, $element.width(), $element.height() );
    },
    
    createTemporaryContainer: function() {
      var temporaryContainer = document.createElement( 'div' );
      $( temporaryContainer ).css( {
        display: 'hidden',
        padding: '0 !important',
        margin: '0 !important',
        position: 'absolute',
        left: 0,
        top: 0,
        width: 65535,
        height: 65535
      } );
      return temporaryContainer;
    },
    
    invalidateDOM: function() {
      // prevent this from being executed as a side-effect from inside one of its own calls
      if ( this.invalidateDOMLock ) {
        return;
      }
      this.invalidateDOMLock = true;
      
      // we will place ourselves in a temporary container to get our real desired bounds
      var temporaryContainer = this.createTemporaryContainer();
      
      // move to the temporary container
      this._container.removeChild( this._element );
      temporaryContainer.appendChild( this._element );
      document.body.appendChild( temporaryContainer );
      
      // bounds computation and resize our container to fit precisely
      var selfBounds = this.calculateDOMBounds();
      this.invalidateSelf( selfBounds );
      this._$container.width( selfBounds.getWidth() );
      this._$container.height( selfBounds.getHeight() );
      
      // move back to the main container
      document.body.removeChild( temporaryContainer );
      temporaryContainer.removeChild( this._element );
      this._container.appendChild( this._element );
      
      this.invalidateDOMLock = false;
    },
    
    getDOMElement: function() {
      return this._container;
    },
    
    updateDOMElement: function( container ) {
      // nothing needed, since we are just displaying a single DOM element
    },
    
    updateCSSTransform: function( transform, element ) {
      // faster to use our jQuery reference instead of wrapping element
      scenery.Util.applyCSSTransform( transform.getMatrix(), this._container );
    },
    
    isPainted: function() {
      return true;
    },
    
    setElement: function( element ) {
      if ( this._element !== element ) {
        if ( this._element ) {
          this._container.removeChild( this._element );
        }
        
        this._element = element;
        this._$element = $( element );
        
        this._container.appendChild( this._element );
        
        // TODO: bounds issue, since this will probably set to empty bounds and thus a repaint may not draw over it
        this.invalidateDOM();  
      }

      return this; // allow chaining
    },
    
    getElement: function() {
      return this._element;
    },
    
    setInteractive: function( interactive ) {
      if ( this._interactive !== interactive ) {
        this._interactive = interactive;
        
        // TODO: anything needed here?
      }
    },
    
    isInteractive: function() {
      return this._interactive;
    },
    
    set element( value ) { this.setElement( value ); },
    get element() { return this.getElement(); },
    
    set interactive( value ) { this.setInteractive( value ); },
    get interactive() { return this.isInteractive(); },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.DOM( $( \'' + escapeHTML( this._container.innerHTML.replace( /'/g, '\\\'' ) ) + '\' ), {' + propLines + '} )';
    },
    
    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      if ( this.interactive ) {
        if ( result ) {
          result += ',\n';
        }
        result += spaces + 'interactive: true';
      }
      return result;
    }
  } );
  
  DOM.prototype._mutatorKeys = [ 'element', 'interactive' ].concat( Node.prototype._mutatorKeys );
  
  return DOM;
} );



//  Copyright 2002-2014, University of Colorado Boulder

/**
 * AbstractBox is the parent for VBox and HBox, which arrange child nodes.
 * See https://github.com/phetsims/scenery/issues/116
 *
 * @author Sam Reid
 */

define( 'SCENERY/nodes/AbstractBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
  

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );

  /**
   * Main constructor for AbstractBox.
   *
   * @param {object} options Same as Node.constructor.options with the following additions:
   *
   * spacing: can be a number or a function.  If a number, then it will be the spacing between each object.
   *              If a function, then the function will have the signature function(a,b){} which returns the spacing between adjacent pairs of items.
   * align:   How to line up the items, defaults to 'center'.
   *
   * @param {string} type 'vertical' or 'horizontal'
   * @param {function} layoutFunction the function to layout out the nodes (different for HBox and VBox)
   *
   * @constructor
   */
  scenery.AbstractBox = function AbstractBox( type, layoutFunction, options ) {
    assert && assert( type === 'vertical' || type === 'horizontal' );

    this.type = type;
    this.layoutFunction = layoutFunction;
    this.boundsListener = this.updateLayout.bind( this );

    // ensure we have a parameter object
    this.options = _.extend( {
      // defaults
      spacing: function() { return 0; },
      align: 'center',

      //By default, update the layout when children are added/removed/resized, see #116
      resize: true
    }, options );

    if ( typeof this.options.spacing === 'number' ) {
      var spacingConstant = this.options.spacing;
      this.options.spacing = function() { return spacingConstant; };
    }

    Node.call( this );

    //See HBox.js
    this.inited = false;
    this.mutate( this.options );
    this.inited = true;
  };
  var AbstractBox = scenery.AbstractBox;

  inherit( Node, AbstractBox, {
    updateLayout: function() {
      if ( !this.updatingLayout ) {
        //Bounds of children are changed in updateLayout, we don't want to stackoverflow so bail if already updating layout
        this.updatingLayout = true;
        this.layoutFunction.call( this );
        this.updatingLayout = false;
      }
    }
  } );

  //Override the child mutators to updateLayout
  //Have to listen to the child bounds individually because there are a number of possible ways to change the child
  //bounds without changing the overall bounds.
  var overrides = ['insertChild', 'removeChildWithIndex'];
  overrides.forEach( function( override ) {

    //Support up to two args for overrides
    AbstractBox.prototype[override] = function( arg1, arg2 ) {

      //Remove event listeners from any nodes (will be added back later if the node was not removed)
      var abstractBox = this;
      if ( this.options.resize ) {
        this.children.forEach( function( child ) {
          if ( child.containsEventListener( 'bounds', abstractBox.boundsListener ) ) {
            child.removeEventListener( 'bounds', abstractBox.boundsListener );
          }
        } );
      }

      //Super call
      Node.prototype[override].call( this, arg1, arg2 );

      //Update the layout if it should be dynamic
      if ( this.options.resize || !this.inited ) {
        this.updateLayout();
      }

      //Add event listeners for any current children (if it should be dynamic)
      if ( this.options.resize ) {
        this.children.forEach( function( child ) {
          if ( !child.containsEventListener( 'bounds', abstractBox.boundsListener ) ) {
            child.addEventListener( 'bounds', abstractBox.boundsListener );
          }
        } );
      }
    };
  } );

  return AbstractBox;
} );
// Copyright 2002-2013, University of Colorado Boulder

/**
 * VBox arranges the child nodes vertically, and they can be centered, left or right justified.
 * Vertical spacing can be set as a constant or a function which depends on the adjacent nodes.
 *
 * See a dynamic test in scenery\tests\test-vbox.html
 *
 * @author Sam Reid
 */

define( 'SCENERY/nodes/HBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/AbstractBox'],function( require ) {
  

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var AbstractBox = require( 'SCENERY/nodes/AbstractBox' );

  /**
   *
   * @param options Same as Node.constructor.options with the following additions:
   *
   * spacing: can be a number or a function.  If a number, then it will be the vertical spacing between each object.
   *              If a function, then the function will have the signature function(top,bottom){} which returns the spacing between adjacent pairs of items.
   * align:   How to line up the items horizontally.  One of 'center', 'top' or 'bottom'.  Defaults to 'center'.
   *
   * @constructor
   */
  scenery.HBox = function VBox( options ) {
    AbstractBox.call( this, 'horizontal', function() {
      var minY = _.min( _.map( this.children, function( child ) {return child.top;} ) );
      var maxY = _.max( _.map( this.children, function( child ) {return child.top + child.height;} ) );
      var centerY = (maxY + minY) / 2;

      //Start at x=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {x:number} option.
      var x = 0;
      for ( var i = 0; i < this.children.length; i++ ) {
        var child = this.children[i];
        child.left = x;

        //Set the position horizontally
        if ( this.options.align === 'top' ) {
          child.top = minY;
        }
        else if ( this.options.align === 'bottom' ) {
          child.bottom = maxY;
        }
        else {//default to center
          child.centerY = centerY;
        }

        //Move to the next vertical position.
        x += child.width + this.options.spacing( child, this.children[i + 1] );
      }
    }, options );
  };

  return inherit( AbstractBox, scenery.HBox );
} );
// Copyright 2002-2013, University of Colorado

/**
 * Font handling for text drawing
 *
 * Examples:
 * new scenery.Font().font                      // "10px sans-serif" (the default)
 * new scenery.Font( { family: 'serif' } ).font // "10px serif"
 * new scenery.Font( { weight: 'bold' } ).font  // "bold 10px sans-serif"
 * new scenery.Font( { size: 16 } ).font        // "16px sans-serif"
 * var font = new scenery.Font( {
 *   family: '"Times New Roman", serif',
 *   style: 'italic',
 *   lineHeight: 10
 * } );
 * font.font;                                   // "italic 10px/10 'Times New Roman', serif"
 * font.family;                                 // "'Times New Roman', serif"
 * font.weight;                                 // 400 (the default)
 *
 * Useful specs:
 * http://www.w3.org/TR/css3-fonts/
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Font',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  // constants used for detection (since styles/variants/weights/stretches can be mixed in the preamble of the shorthand string)
  var styles = [ 'normal', 'italic', 'oblique' ];
  var variants = [ 'normal', 'small-caps' ];
  var weights = [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900' ];
  var stretches = [ 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded' ];
  
  function castSize( size ) {
    if ( typeof size === 'number' ) {
      return size + 'px'; // add the pixels suffix by default for numbers
    } else {
      return size; // assume that it's a valid to-spec string
    }
  }
  
  scenery.Font = function Font( options ) {
    // options from http://www.w3.org/TR/css3-fonts/
    this._style = 'normal';      // normal | italic | oblique
    this._variant = 'normal';    // normal | small-caps
    this._weight = 'normal';     // normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
    this._stretch = 'normal';    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded
    this._size = '10px';         // <absolute-size> | <relative-size> | <length> | <percentage> -- unitless number interpreted as px. absolute suffixes: cm, mm, in, pt, pc, px. relative suffixes: em, ex, ch, rem, vw, vh, vmin, vmax.
    this._lineHeight = 'normal'; // normal | <number> | <length> | <percentage> -- NOTE: Canvas spec forces line-height to normal
    this._family = 'sans-serif'; // comma-separated list of families, including generic families (serif, sans-serif, cursive, fantasy, monospace). ideally escape with double-quotes
    
    // font  [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]? <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ] | caption | icon | menu | message-box | small-caption | status-bar
    // <font-variant-css21> = [normal | small-caps]
    
    var type = typeof options;
    if ( type === 'string' ) {
      // parse a somewhat proper CSS3 form (not guaranteed to handle it precisely the same as browsers yet)
      
      // split based on whitespace allowed by CSS spec (more restrictive than regular regexp whitespace)
      var tokens = _.filter( options.split( /[\x09\x0A\x0C\x0D\x20]/ ), function( token ) { return token.length > 0; } );
      
      // pull tokens out until we reach something that doesn't match. that must be the font size (according to spec)
      for ( var i = 0; i < tokens.length; i++ ) {
        var token = tokens[i];
        if ( token === 'normal' ) {
          // nothing has to be done, everything already normal as default
        } else if ( _.contains( styles, token ) ) {
          assert && assert( this._style === 'normal', 'Style cannot be applied twice. Already set to "' + this._style + '", attempt to replace with "' + token + '"' );
          this._style = token;
        } else if ( _.contains( variants, token ) ) {
          assert && assert( this._variant === 'normal', 'Variant cannot be applied twice. Already set to "' + this._variant + '", attempt to replace with "' + token + '"' );
          this._variant = token;
        } else if ( _.contains( weights, token ) ) {
          assert && assert( this._weight === 'normal', 'Weight cannot be applied twice. Already set to "' + this._weight + '", attempt to replace with "' + token + '"' );
          this._weight = token;
        } else if ( _.contains( stretches, token ) ) {
          assert && assert( this._stretch === 'normal', 'Stretch cannot be applied twice. Already set to "' + this._stretch + '", attempt to replace with "' + token + '"' );
          this._stretch = token;
        } else {
          // not a style/variant/weight/stretch, must be a font size, possibly with an included line-height
          var subtokens = token.split( /\// ); // extract font size from any line-height
          this._size = subtokens[0];
          if ( subtokens[1] ) {
            this._lineHeight = subtokens[1];
          }
          // all future tokens are guaranteed to be part of the font-family if it is given according to spec
          this._family = tokens.slice( i + 1 ).join( ' ' );
          break;
        }
      }
    } else if ( type === 'object' ) {
      if ( options.style !== undefined ) {
        this._style = options.style;
      }
      if ( options.variant !== undefined ) {
        this._variant = options.variant;
      }
      if ( options.weight !== undefined ) {
        this._weight = '' + options.weight; // cast it to a string explicitly
      }
      if ( options.stretch !== undefined ) {
        this._stretch = options.stretch;
      }
      if ( options.size !== undefined ) {
        this._size = castSize( options.size );
      }
      if ( options.lineHeight !== undefined ) {
        this._lineHeight = options.lineHeight;
      }
      if ( options.family !== undefined ) {
        this._family = options.family;
      }
    }
    
    // sanity checks to prevent errors in interpretation or in the font shorthand usage
    assert && assert( typeof this._style === 'string' &&
                                    _.contains( styles, this._style ),
                                    'Font style must be one of "normal", "italic", or "oblique"' );
    assert && assert( typeof this._variant === 'string' &&
                                    _.contains( variants, this._variant ),
                                    'Font variant must be "normal" or "small-caps"' );
    assert && assert( typeof this._weight === 'string' &&
                                    _.contains( weights, this._weight ),
                                    'Font weight must be one of "normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", or "900"' );
    assert && assert( typeof this._stretch === 'string' &&
                                    _.contains( stretches, this._stretch ),
                                    'Font stretch must be one of "normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", or "ultra-expanded"' );
    assert && assert( typeof this._size === 'string' &&
                                    !_.contains( [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], this._size[this._size.length - 1] ),
                                    'Font size must be either passed as a number (not a string, interpreted as px), or must contain a suffix for percentage, absolute or relative units, or an explicit size constant' );
    assert && assert( typeof this._lineHeight === 'string' );
    assert && assert( typeof this._family === 'string' );
    
    // initialize the shorthand font property (stored as _font)
    this._font = this.computeShorthand();
    
    phetAllocation && phetAllocation( 'Font' );
  };
  var Font = scenery.Font;
  
  Font.prototype = {
    constructor: Font,
    
    getFont:       function() { return this._font; },
    getStyle:      function() { return this._style; },
    getVariant:    function() { return this._variant; },
    getWeight:     function() { return this._weight; },
    getStretch:    function() { return this._stretch; },
    getSize:       function() { return this._size; },
    getLineHeight: function() { return this._lineHeight; },
    getFamily:     function() { return this._family; },
    
    get font()       { return this.getFont(); },
    get style()      { return this.getStyle(); },
    get variant()    { return this.getVariant(); },
    get weight()     { return this.getWeight(); },
    get stretch()    { return this.getStretch(); },
    get size()       { return this.getSize(); },
    get lineHeight() { return this.getLineHeight(); },
    get family()     { return this.getFamily(); },
    
    copy: function( options ) {
      return new Font( _.extend( {
        style: this._style,
        variant: this._variant,
        weight: this._weight,
        stretch: this._stretch,
        size: this._size,
        lineHeight: this._lineHeight,
        family: this._family
      }, options ) );
    },
    
    computeShorthand: function() {
      var ret = '';
      if ( this._style !== 'normal' ) { ret += this._style + ' '; }
      if ( this._variant !== 'normal' ) { ret += this._variant + ' '; }
      if ( this._weight !== 'normal' ) { ret += this._weight + ' '; }
      if ( this._stretch !== 'normal' ) { ret += this._stretch + ' '; }
      ret += this._size;
      if ( this._lineHeight !== 'normal' ) { ret += '/' + this._lineHeight; }
      ret += ' ' + this._family;
      return ret;
    },
    
    toCSS: function() {
      return this.getFont();
    }
  };
  
  Font.DEFAULT = new Font();
  
  return Font;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Text
 *
 * TODO: newlines (multiline)
 * TODO: htmlText support (and DOM renderer)
 * TODO: don't get bounds until the Text node is fully mutated?
 * TODO: remove some support for centering, since Scenery's Node already handles that better?
 *
 * Useful specs:
 * http://www.w3.org/TR/css3-text/
 * http://www.w3.org/TR/css3-fonts/
 * http://www.w3.org/TR/SVG/text.html
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Text',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','DOT/Bounds2','DOT/Matrix3','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/nodes/Fillable','SCENERY/nodes/Strokable','SCENERY/util/Font','SCENERY/util/Util'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var escapeHTML = require( 'PHET_CORE/escapeHTML' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node
  require( 'SCENERY/layers/Renderer' );
  var Fillable = require( 'SCENERY/nodes/Fillable' );
  var Strokable = require( 'SCENERY/nodes/Strokable' );
  require( 'SCENERY/util/Font' );
  require( 'SCENERY/util/Util' ); // for canvasAccurateBounds and CSS transforms
  
  var textSizeContainerId = 'sceneryTextSizeContainer';
  var textSizeElementId = 'sceneryTextSizeElement';
  var svgTextSizeContainer = document.getElementById( textSizeContainerId );
  var svgTextSizeElement = document.getElementById( textSizeElementId );
  
  if ( !svgTextSizeContainer ) {
    // set up the container and text for testing text bounds quickly (using approximateSVGBounds)
    svgTextSizeContainer = document.createElementNS( scenery.svgns, 'svg' );
    svgTextSizeContainer.setAttribute( 'width', '2' );
    svgTextSizeContainer.setAttribute( 'height', '2' );
    svgTextSizeContainer.setAttribute( 'id', textSizeContainerId );
    svgTextSizeContainer.setAttribute( 'style', 'visibility: hidden; pointer-events: none; position: absolute; left: -65535; right: -65535;' ); // so we don't flash it in a visible way to the user
  }
  // NOTE! copies createSVGElement
  if ( !svgTextSizeElement ) {
    svgTextSizeElement = document.createElementNS( scenery.svgns, 'text' );
    svgTextSizeElement.appendChild( document.createTextNode( '' ) );
    svgTextSizeElement.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
    svgTextSizeElement.setAttribute( 'text-rendering', 'geometricPrecision' );
    svgTextSizeElement.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
    svgTextSizeElement.setAttribute( 'id', textSizeElementId );
    svgTextSizeContainer.appendChild( svgTextSizeElement );
  }
  
  // SVG bounds seems to be malfunctioning for Safari 5. Since we don't have a reproducible test machine for
  // fast iteration, we'll guess the user agent and use DOM bounds instead of SVG.
  // Hopefully the two contraints rule out any future Safari versions (fairly safe, but not impossible!)
  var useDOMAsFastBounds = window.navigator.userAgent.indexOf( 'like Gecko) Version/5' ) !== -1 &&
                           window.navigator.userAgent.indexOf( 'Safari/' ) !== -1;
  
  var hybridTextNode; // a node that is used to measure SVG text top/height for hybrid caching purposes
  var initializingHybridTextNode = false;
  
  scenery.Text = function Text( text, options ) {
    this._text         = '';                   // filled in with mutator
    this._font         = scenery.Font.DEFAULT; // default font, usually 10px sans-serif
    this._direction    = 'ltr';                // ltr, rtl, inherit -- consider inherit deprecated, due to how we compute text bounds in an off-screen canvas
    this._boundsMethod = 'hybrid';             // fast (SVG/DOM, no canvas rendering allowed), fastCanvas (SVG/DOM, canvas rendering allowed without dirty regions),
                                               // accurate (Canvas accurate recursive), or hybrid (cache SVG height, use canvas measureText for width)
    
    // whether the text is rendered as HTML or not. if defined (in a subtype constructor), use that value instead
    this._isHTML = this._isHTML === undefined ? false : this._isHTML;
    
    // ensure we have a parameter object
    options = options || {};
    
    // default to black filled text
    if ( options.fill === undefined ) {
      options.fill = '#000000';
    }
    
    if ( text !== undefined ) {
      // set the text parameter so that setText( text ) is effectively called in the mutator from the super call
      options.text = text;
    }
    
    this.initializeFillable();
    this.initializeStrokable();
    
    Node.call( this, options );
    this.updateTextFlags(); // takes care of setting up supported renderers
  };
  var Text = scenery.Text;
  
  inherit( Node, Text, {
    domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer
    
    setText: function( text ) {
      assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );
      
      // cast it to a string (for numbers, etc.)
      text = '' + text;
      
      if ( text !== this._text ) {
        this._text = text;
        this.invalidateText();
      }
      return this;
    },
    
    getText: function() {
      return this._text;
    },
    
    // Using the non-breaking space (&nbsp;) encoded as 0x00A0 in UTF-8
    getNonBreakingText: function() {
      return this._text.replace( ' ', '\xA0' );
    },
    
    setBoundsMethod: function( method ) {
      assert && assert( method === 'fast' || method === 'fastCanvas' || method === 'accurate' || method === 'hybrid', 'Unknown Text boundsMethod' );
      if ( method !== this._boundsMethod ) {
        this._boundsMethod = method;
        this.updateTextFlags();
        this.dispatchEvent( 'boundsAccuracy', { node: this } ); // TODO: consider standardizing this, or attaching listeners in a different manner?
        this.invalidateText();
      }
      return this;
    },
    
    getBoundsMethod: function() {
      return this._boundsMethod;
    },
    
    // allow more specific path types (Rectangle, Line) to override what restrictions we have
    getTextRendererBitmask: function() {
      var bitmask = 0;
      
      // canvas support (fast bounds may leak out of dirty rectangles)
      if ( this._boundsMethod !== 'fast' && !this._isHTML ) {
        bitmask |= scenery.bitmaskSupportsCanvas;
      }
      if( !this._isHTML ) {
        bitmask |= scenery.bitmaskSupportsSVG;
      }
      
      // fill and stroke will determine whether we have DOM text support
      bitmask |= scenery.bitmaskSupportsDOM;
      
      return bitmask;
    },
    
    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getTextRendererBitmask() );
    },
    
    updateTextFlags: function() {
      this.boundsInaccurate = this._boundsMethod !== 'accurate';
      this.invalidateSupportedRenderers();
    },
    
    invalidateText: function() {
      // investigate http://mudcu.be/journal/2011/01/html5-typographic-metrics/
      if ( this._isHTML || ( useDOMAsFastBounds && this._boundsMethod !== 'accurate' ) ) {
        this.invalidateSelf( this.approximateDOMBounds() );
      } else if ( this._boundsMethod === 'hybrid' ) {
        this.invalidateSelf( this.approximateHybridBounds() );
      } else if ( this._boundsMethod === 'fast' || this._boundsMethod === 'fastCanvas' ) {
        this.invalidateSelf( this.approximateSVGBounds() );
      } else {
        this.invalidateSelf( this.accurateCanvasBounds() );
      }
      
      // we may have changed renderers if parameters were changed!
      this.updateTextFlags();
    },
    
    // overrides from Strokable
    invalidateStroke: function() {
      // stroke can change both the bounds and renderer
      this.invalidateText();
    },
    
    // overrides from Fillable
    invalidateFill: function() {
      // fill type can change the renderer (gradient/fill not supported by DOM)
      this.invalidateText();
    },
    
    /*---------------------------------------------------------------------------*
    * Canvas support
    *----------------------------------------------------------------------------*/
    
    paintCanvas: function( wrapper ) {
      var context = wrapper.context;
      
      // extra parameters we need to set, but should avoid setting if we aren't drawing anything
      if ( this.hasFill() || this.hasStroke() ) {
        wrapper.setFont( this._font.getFont() );
        wrapper.setDirection( this._direction );
      }
      
      if ( this.hasFill() ) {
        this.beforeCanvasFill( wrapper ); // defined in Fillable
        context.fillText( this._text, 0, 0 );
        this.afterCanvasFill( wrapper ); // defined in Fillable
      }
      if ( this.hasStroke() ) {
        this.beforeCanvasStroke( wrapper ); // defined in Strokable
        context.strokeText( this._text, 0, 0 );
        this.afterCanvasStroke( wrapper ); // defined in Strokable
      }
    },
    
    /*---------------------------------------------------------------------------*
    * WebGL support
    *----------------------------------------------------------------------------*/
    
    paintWebGL: function( state ) {
      throw new Error( 'Text.prototype.paintWebGL unimplemented' );
    },
    
    /*---------------------------------------------------------------------------*
    * SVG support
    *----------------------------------------------------------------------------*/
    
    createSVGFragment: function( svg, defs, group ) {
      // NOTE! reference SVG element at top of file copies createSVGElement!
      var element = document.createElementNS( scenery.svgns, 'text' );
      element.appendChild( document.createTextNode( '' ) );
      element.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
      element.setAttribute( 'text-rendering', 'geometricPrecision' );
      element.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
      element.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
      return element;
    },
    
    updateSVGFragment: function( element ) {
      // update the text-node's value
      element.lastChild.nodeValue = this.getNonBreakingText();
      
      element.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
      element.setAttribute( 'direction', this._direction );
      
      // text length correction, tested with scenery/tests/text-quality-test.html to determine how to match Canvas/SVG rendering (and overall length)
      if ( isFinite( this._selfBounds.width ) ) {
        element.setAttribute( 'textLength', this._selfBounds.width );
      }
      
      // set all of the font attributes, since we can't use the combined one
      // TODO: optimize so we only set what is changed!!!
      element.setAttribute( 'font-family', this._font.getFamily() );
      element.setAttribute( 'font-size', this._font.getSize() );
      element.setAttribute( 'font-style', this._font.getStyle() );
      element.setAttribute( 'font-weight', this._font.getWeight() );
      element.setAttribute( 'font-stretch', this._font.getStretch() );
    },
    
    // support patterns, gradients, and anything else we need to put in the <defs> block
    updateSVGDefs: function( svg, defs ) {
      // remove old definitions if they exist
      this.removeSVGDefs( svg, defs );
      
      // add new ones if applicable
      this.addSVGFillDef( svg, defs );
      this.addSVGStrokeDef( svg, defs );
    },
    
    // cleans up references created with udpateSVGDefs()
    removeSVGDefs: function( svg, defs ) {
      this.removeSVGFillDef( svg, defs );
      this.removeSVGStrokeDef( svg, defs );
    },
    
    /*---------------------------------------------------------------------------*
    * DOM support
    *----------------------------------------------------------------------------*/
    
    allowsMultipleDOMInstances: true,
    
    getDOMElement: function() {
      var div = document.createElement( 'div' );
      
      // so they are absolutely positioned compared to the containing DOM layer (that is positioned).
      // otherwise, two adjacent HTMLText elements will 'flow' and be positioned incorrectly
      div.style.position = 'absolute';
      return div;
    },
    
    updateDOMElement: function( div ) {
      var $div = $( div );
      div.style.font = this.getFont();
      div.style.color = this.getCSSFill();
      $div.width( this.getSelfBounds().width );
      $div.height( this.getSelfBounds().height );
      $div.empty(); // remove all children, including previously-created text nodes
      div.appendChild( this.getDOMTextNode() );
      div.setAttribute( 'dir', this._direction );
    },
    
    updateCSSTransform: function( transform, element ) {
      // since the DOM origin of the text is at the upper-left, and our Scenery origin is at the lower-left, we need to
      // shift the text vertically, postmultiplied with the entire transform.
      var yOffset = this.getSelfBounds().minY;
      var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( 0, yOffset ) );
      scenery.Util.applyCSSTransform( matrix, element );
    },
    
    // a DOM node (not a Scenery DOM node, but an actual DOM node) with the text
    getDOMTextNode: function() {
      if ( this._isHTML ) {
        var span = document.createElement( 'span' );
        span.innerHTML = this._text;
        return span;
      } else {
        return document.createTextNode( this.getNonBreakingText() );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * Bounds
    *----------------------------------------------------------------------------*/
    
    accurateCanvasBounds: function() {
      var node = this;
      var svgBounds = this.approximateSVGBounds(); // this seems to be slower than expected, mostly due to Font getters

      //If svgBounds are zero, then return the zero bounds
      if ( !this._text || svgBounds.width === 0 ) {
        return svgBounds;
      }
      return scenery.Util.canvasAccurateBounds( function( context ) {
        context.font = node.font;
        context.direction = node.direction;
        context.fillText( node.text, 0, 0 );
      }, {
        precision: 0.5,
        resolution: 128,
        initialScale: 32 / Math.max( Math.abs( svgBounds.minX ), Math.abs( svgBounds.minY ), Math.abs( svgBounds.maxX ), Math.abs( svgBounds.maxY ) )
      } );
    },
    
    approximateCanvasWidth: function() {
      var context = scenery.scratchContext;
      context.font = this.font;
      context.direction = this.direction;
      return context.measureText( this.text ).width;
    },
    
    approximateSVGBounds: function() {
      if ( !svgTextSizeContainer.parentNode ) {
        if ( document.body ) {
          document.body.appendChild( svgTextSizeContainer );
        } else {
          // TODO: better way to handle the hybridTextNode being added inside the HEAD? Requiring a body for proper operation might be a problem.
          if ( initializingHybridTextNode ) {
            // if this is almost assuredly the hybridTextNode, return nothing for now. TODO: better way of handling this! it's a hack!
            return Bounds2.NOTHING;
          } else {
            throw new Error( 'No document.body and trying to get approximate SVG bounds of a Text node' );
          }
        }
      }
      this.updateSVGFragment( svgTextSizeElement );
      svgTextSizeElement.removeAttribute( 'textLength' ); // since we may set textLength, remove that so we can get accurate widths
      var rect = svgTextSizeElement.getBBox();
      return new Bounds2( rect.x, rect.y, rect.x + rect.width, rect.y + rect.height );
    },
    
    approximateHybridBounds: function() {
      if ( !hybridTextNode ) {
        return Bounds2.NOTHING; // we are the hybridTextNode, ignore us
      }
      
      if ( this._font._cachedSVGBounds === undefined ) {
        hybridTextNode.setFont( this._font );
        this._font._cachedSVGBounds = hybridTextNode.getBounds();
      }
      
      var canvasWidth = this.approximateCanvasWidth();
      var verticalBounds = this._font._cachedSVGBounds;
      
      // it seems that SVG bounds generally have x=0, so we hard code that here
      return new Bounds2( 0, verticalBounds.minY, canvasWidth, verticalBounds.maxY );
    },
    
    approximateDOMBounds: function() {
      var maxHeight = 1024; // technically this will fail if the font is taller than this!
      var isRTL = this.direction === 'rtl';
      
      // <div style="position: absolute; left: 0; top: 0; padding: 0 !important; margin: 0 !important;"><span id="baselineSpan" style="font-family: Verdana; font-size: 25px;">QuipTaQiy</span><div style="vertical-align: baseline; display: inline-block; width: 0; height: 500px; margin: 0 important!; padding: 0 important!;"></div></div>
      
      var div = document.createElement( 'div' );
      $( div ).css( {
        position: 'absolute',
        left: 0,
        top: 0,
        padding: '0 !important',
        margin: '0 !important',
        display: 'hidden'
      } );
      
      var span = document.createElement( 'span' );
      $( span ).css( 'font', this.getFont() );
      span.appendChild( this.getDOMTextNode() );
      span.setAttribute( 'direction', this._direction );
      
      var fakeImage = document.createElement( 'div' );
      $( fakeImage ).css( {
        'vertical-align': 'baseline',
        display: 'inline-block',
        width: 0,
        height: maxHeight + 'px',
        margin: '0 !important',
        padding: '0 !important'
      } );
      
      div.appendChild( span );
      div.appendChild( fakeImage );
      
      document.body.appendChild( div );
      var rect = span.getBoundingClientRect();
      var divRect = div.getBoundingClientRect();
      // add 1 pixel to rect.right to prevent HTML text wrapping
      var result = new Bounds2( rect.left, rect.top - maxHeight, rect.right + 1, rect.bottom - maxHeight ).shifted( -divRect.left, -divRect.top );
      // console.log( 'result: ' + result );
      document.body.removeChild( div );
      
      var width = rect.right - rect.left;
      return result.shiftedX( isRTL ? -width : 0 ); // should we even swap here?
    },
    
    // @override from Node
    getSafeSelfBounds: function() {
      var expansionFactor = 1; // we use a new bounding box with a new size of size * ( 1 + 2 * expansionFactor )
      
      var selfBounds = this.getSelfBounds();
      return selfBounds.dilatedXY( expansionFactor * selfBounds.width, expansionFactor * selfBounds.height );
    },
    
    /*---------------------------------------------------------------------------*
    * Self setters / getters
    *----------------------------------------------------------------------------*/
    
    setFont: function( font ) {
      if ( this.font !== font ) {
        this._font = font instanceof scenery.Font ? font : new scenery.Font( font );
        this.invalidateText();
      }
      return this;
    },
    
    // NOTE: returns mutable copy for now, consider either immutable version, defensive copy, or note about invalidateText()
    getFont: function() {
      return this._font.getFont();
    },
    
    setDirection: function( direction ) {
      this._direction = direction;
      this.invalidateText();
      return this;
    },
    
    getDirection: function() {
      return this._direction;
    },
    
    isPainted: function() {
      return true;
    },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Text( \'' + escapeHTML( this._text.replace( /'/g, '\\\'' ) ) + '\', {' + propLines + '} )';
    },
    
    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      result = this.appendFillablePropString( spaces, result );
      result = this.appendStrokablePropString( spaces, result );
      
      // TODO: if created again, deduplicate with Node's getPropString
      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        } else {
          result += spaces + key + ': ' + value;
        }
      }
      
      if ( this.font !== new scenery.Font().getFont() ) {
        addProp( 'font', this.font.replace( /'/g, '\\\'' ) );
      }
      
      if ( this._direction !== 'ltr' ) {
        addProp( 'direction', this._direction );
      }
      
      return result;
    }
  } );
  
  /*---------------------------------------------------------------------------*
  * Font setters / getters
  *----------------------------------------------------------------------------*/
  
  function addFontForwarding( propertyName, fullCapitalized, shortUncapitalized ) {
    var getterName = 'get' + fullCapitalized;
    var setterName = 'set' + fullCapitalized;
    
    Text.prototype[getterName] = function() {
      // use the ES5 getter to retrieve the property. probably somewhat slow.
      return this._font[ shortUncapitalized ];
    };
    
    Text.prototype[setterName] = function( value ) {
      // create a full copy of our font instance
      var ob = {};
      ob[shortUncapitalized] = value;
      var newFont = this._font.copy( ob );
      
      // apply the new Font. this should call invalidateText() as normal
      this.setFont( newFont );
      return this;
    };
    
    Object.defineProperty( Text.prototype, propertyName, { set: Text.prototype[setterName], get: Text.prototype[getterName] } );
  }
  
  addFontForwarding( 'fontWeight', 'FontWeight', 'weight' );
  addFontForwarding( 'fontFamily', 'FontFamily', 'family' );
  addFontForwarding( 'fontStretch', 'FontStretch', 'stretch' );
  addFontForwarding( 'fontStyle', 'FontStyle', 'style' );
  addFontForwarding( 'fontSize', 'FontSize', 'size' );
  addFontForwarding( 'lineHeight', 'LineHeight', 'lineHeight' );
  
  Text.prototype._mutatorKeys = [ 'boundsMethod', 'text', 'font', 'fontWeight', 'fontFamily', 'fontStretch', 'fontStyle', 'fontSize', 'lineHeight',
                                  'direction' ].concat( Node.prototype._mutatorKeys );
  
  // font-specific ES5 setters and getters are defined using addFontForwarding above
  Object.defineProperty( Text.prototype, 'font', { set: Text.prototype.setFont, get: Text.prototype.getFont } );
  Object.defineProperty( Text.prototype, 'text', { set: Text.prototype.setText, get: Text.prototype.getText } );
  Object.defineProperty( Text.prototype, 'direction', { set: Text.prototype.setDirection, get: Text.prototype.getDirection } );
  Object.defineProperty( Text.prototype, 'boundsMethod', { set: Text.prototype.setBoundsMethod, get: Text.prototype.getBoundsMethod } );
  
  // mix in support for fills and strokes
  /* jshint -W064 */
  Fillable( Text );
  Strokable( Text );
  
  initializingHybridTextNode = true;
  hybridTextNode = new Text( 'm', { boundsMethod: 'fast' } );
  initializingHybridTextNode = false;

  return Text;
} );



// Copyright 2002-2013, University of Colorado

/**
 * HTML Text, with the same interface as Text
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/HTMLText',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Text'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Text = require( 'SCENERY/nodes/Text' ); // inherits from Text
  
  scenery.HTMLText = function HTMLText( text, options ) {
    // internal flag for Text
    this._isHTML = true;
    
    Text.call( this, text, options );
  };
  var HTMLText = scenery.HTMLText;
  
  inherit( Text, HTMLText, {} );
  
  return HTMLText;
} );



// Copyright 2002-2013, University of Colorado

/**
 * Images
 *
 * TODO: allow multiple DOM instances (create new HTMLImageElement elements)
 * TODO: SVG support
 * TODO: support rendering a Canvas to DOM (single instance)
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Image',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/util/Util'],function( require ) {
  

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );

  var scenery = require( 'SCENERY/scenery' );

  var Node = require( 'SCENERY/nodes/Node' ); // Image inherits from Node
  require( 'SCENERY/layers/Renderer' ); // we need to specify the Renderer in the prototype
  require( 'SCENERY/util/Util' );

  /*
   * Canvas renderer supports the following as 'image':
   *     URL (string)             // works, but does NOT support bounds-based parameter object keys like 'left', 'centerX', etc.
   *                              // also necessary to force updateScene() after it has loaded
   *     HTMLImageElement         // works
   *     HTMLVideoElement         // not tested
   *     HTMLCanvasElement        // works, and forces the canvas renderer
   *     CanvasRenderingContext2D // not tested, but bad luck in past
   *     ImageBitmap              // good luck creating this. currently API for window.createImageBitmap not implemented
   * SVG renderer supports the following as 'image':
   *     URL (string)
   *     HTMLImageElement
   */
  scenery.Image = function Image( image, options ) {
    assert && assert( image, "image should be available" );

    // allow not passing an options object
    options = options || {};

    // rely on the setImage call from the super constructor to do the setup
    if ( image ) {
      options.image = image;
    }

    var self = this;
    // allows us to invalidate our bounds whenever an image is loaded
    this.loadListener = function( event ) {
      self.invalidateImage();

      // don't leak memory!
      self._image.removeEventListener( 'load', self.loadListener );
    };

    Node.call( this, options );
    this.invalidateSupportedRenderers();
  };
  var Image = scenery.Image;

  inherit( Node, Image, {
    allowsMultipleDOMInstances: false, // TODO: support multiple instances

    invalidateImage: function() {
      this.invalidateSelf( new Bounds2( 0, 0, this.getImageWidth(), this.getImageHeight() ) );
    },

    getImage: function() {
      return this._image;
    },
    
    invalidateSupportedRenderers: function() {
      if ( this._image instanceof HTMLCanvasElement ) {
        this.setRendererBitmask( scenery.bitmaskSupportsCanvas );
      } else {
        // assumes HTMLImageElement
        this.setRendererBitmask( scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG | scenery.bitmaskSupportsDOM );
      }
    },

    setImage: function( image ) {
      if ( this._image !== image && ( typeof image !== 'string' || !this._image || image !== this._image.src ) ) {
        // don't leak memory by referencing old images
        if ( this._image ) {
          this._image.removeEventListener( 'load', this.loadListener );
        }

        if ( typeof image === 'string' ) {
          // create an image with the assumed URL
          var src = image;
          image = document.createElement( 'img' );
          image.addEventListener( 'load', this.loadListener );
          image.src = src;
        } else if ( image instanceof HTMLImageElement ) {
          // only add a listener if we probably haven't loaded yet
          if ( !image.width || !image.height ) {
            image.addEventListener( 'load', this.loadListener );
          }
        }

        // swap supported renderers if necessary
        this.invalidateSupportedRenderers();

        this._image = image;
        this.invalidateImage(); // yes, if we aren't loaded yet this will give us 0x0 bounds
      }
      return this;
    },

    getImageWidth: function() {
      return this._image.naturalWidth || this._image.width;
    },

    getImageHeight: function() {
      return this._image.naturalHeight || this._image.height;
    },

    getImageURL: function() {
      return this._image.src;
    },

    // signal that we are actually rendering something
    isPainted: function() {
      return true;
    },

    /*---------------------------------------------------------------------------*
    * Canvas support
    *----------------------------------------------------------------------------*/

    // TODO: add SVG / DOM support
    paintCanvas: function( wrapper ) {
      wrapper.context.drawImage( this._image, 0, 0 );
    },

    /*---------------------------------------------------------------------------*
     * WebGL support
     *----------------------------------------------------------------------------*/

    paintWebGL: function( state ) {
      throw new Error( 'paintWebGL:nimplemented' );
    },

    /*---------------------------------------------------------------------------*
    * SVG support
    *----------------------------------------------------------------------------*/

    createSVGFragment: function( svg, defs, group ) {
      var element = document.createElementNS( scenery.svgns, 'image' );
      element.setAttribute( 'x', 0 );
      element.setAttribute( 'y', 0 );
      return element;
    },

    updateSVGFragment: function( element ) {
      // like <image xlink:href='http://phet.colorado.edu/images/phet-logo-yellow.png' x='0' y='0' height='127px' width='242px'/>
      element.setAttribute( 'width', this.getImageWidth() + 'px' );
      element.setAttribute( 'height', this.getImageHeight() + 'px' );
      element.setAttributeNS( scenery.xlinkns, 'xlink:href', this.getImageURL() );
    },

    /*---------------------------------------------------------------------------*
     * DOM support
     *----------------------------------------------------------------------------*/

    getDOMElement: function() {
      this._image.style.display = 'block';
      this._image.style.position = 'absolute';
      this._image.style.left = '0';
      this._image.style.top = '0';
      return this._image;
    },

    updateDOMElement: function( image ) {
      if ( image.src !== this._image.src ) {
        image.src = this._image.src;
      }
    },

    updateCSSTransform: function( transform, element ) {
      // TODO: extract this out, it's completely shared!
      scenery.Util.applyCSSTransform( transform.getMatrix(), element );
    },

    set image( value ) { this.setImage( value ); },
    get image() { return this.getImage(); },

    getBasicConstructor: function( propLines ) {
      return 'new scenery.Image( \'' + ( this._image.src ? this._image.src.replace( /'/g, '\\\'' ) : 'other' ) + '\', {' + propLines + '} )';
    }
  } );

  Image.prototype._mutatorKeys = [ 'image' ].concat( Node.prototype._mutatorKeys );

  // utility for others
  Image.createSVGImage = function( url, width, height ) {
    var element = document.createElementNS( scenery.svgns, 'image' );
    element.setAttribute( 'x', 0 );
    element.setAttribute( 'y', 0 );
    element.setAttribute( 'width', width + 'px' );
    element.setAttribute( 'height', height + 'px' );
    element.setAttributeNS( scenery.xlinkns, 'xlink:href', url );

    return element;
  };

  return Image;
} );



// Copyright 2002-2013, University of Colorado

/**
 * EXPERIMENTAL: USE AT YOUR OWN CAUTION
 *
 * A container that allows flexible layout generation based on layout methods that can be composed together.
 *
 * Experimental demo (for use in Scenery's playground):
 *   var n = new scenery.LayoutNode( scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignLeft ) );
 *   scene.addChild( n );
 *   n.addChild( new scenery.Text( 'Some Text' ) );
 *   n.addChild( new scenery.Text( 'Text pushed to the right' ), { padLeft: 10 } );
 *   n.addChild( new scenery.Text( 'Some padding on top and bottom' ), { padTop: 10, padBottom: 20 } );
 *   n.addChild( new scenery.Text( 'Just Regular Text' ) );
 *   n.addChild( new scenery.Text( 'Right-aligned' ), { layoutMethod: scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignRight ) } );
 *   n.addChild( new scenery.Text( 'Center-aligned' ), { layoutMethod: scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignHorizontalCenter ) } );
 *   n.addChild( new scenery.Text( 'Pad from right' ), { layoutMethod: scenery.LayoutNode.Vertical.and( scenery.LayoutNode.AlignRight ), padRight: 10 } );
 *   n.children[2].text += ' and it updates!';
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/LayoutNode',['require','PHET_CORE/inherit','PHET_CORE/extend','SCENERY/scenery','SCENERY/nodes/Node','DOT/Bounds2'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Bounds2 = require( 'DOT/Bounds2' );
  
  scenery.LayoutNode = function LayoutNode( defaultMethod, options ) {
    var layoutNode = this;
    
    assert && assert( defaultMethod instanceof LayoutMethod, 'defaultMethod is required' );
    
    options = extend( {
      updateOnBounds: true,
      defaultMethod: defaultMethod
    }, options );
    
    this._activelyLayingOut = false;
    this._updateOnBounds = true;
    this._defaultMethod = null;
    this._elements = [];
    this._elementMap = {}; // maps node ID => element
    // this._invisibleBackground = new Rectangle( 0, 0, 0x1f, 0x1f, { visible: false } ); // takes up space that represents the bounds of all of the layout elements (with their padding)
    this._boundsListener = function() {
      if ( layoutNode._updateOnBounds ) {
        layoutNode.updateLayout();
      }
    };
    
    Node.call( this, options );
    
    // this.addChild( this._invisibleBackground );
    
    this.updateLayout();
  };
  var LayoutNode = scenery.LayoutNode;
  
  inherit( Node, LayoutNode, {
    get layoutProperties() { return new LayoutProperties( this._elements ); },
    
    get layoutBounds() {
      var result = Bounds2.NOTHING.copy();
      _.each( this._elements, function( element ) {
        result.includeBounds( element.layoutBounds );
      } );
      return result;
    },
    
    set defaultMethod( value ) { this._defaultMethod = value; this.updateLayout(); return this; },
    get defaultMethod() { return this._defaultMethod; },
    
    set updateOnBounds( value ) { this._updateOnBounds = value; return this; },
    get updateOnBounds() { return this._updateOnBounds; },
    
    /*
     * Options can consist of:
     *   layoutMethod - layout method
     *   useVisibleBounds - (false) whether to use visible bounds instead of normal bounds - TODO how to auto-update when using these?
     *   padLeft / padRight / padTop / padBottom
     *   boundsMethod - custom overriding of entire boundsMethod
     */
    insertChild: function( index, node, options ) {
      var layoutNode = this;
      
      options = extend( {
        useVisibleBounds: false,
        padLeft: 0,
        padRight: 0,
        padTop: 0,
        padBottom: 0
      }, options );

      Node.prototype.insertChild.call( this, index, node );
      
      var methodGetter = options.layoutMethod ? function() { return options.layoutMethod; } : function() { return layoutNode._defaultMethod; };
      var element = new LayoutElement( node, methodGetter, options.boundsMethod ? options.boundsMethod : function( bounds ) {
        if ( options.useVisibleBounds ) {
          bounds = node.visibleBounds;
        }
        
        return new Bounds2( bounds.minX - options.padLeft, bounds.minY - options.padTop, bounds.maxX + options.padRight, bounds.maxY + options.padBottom );
      } );
      this.addElement( element );
      
      this.updateLayout();
    },
    
    addChild: function( node, options ) {
      this.insertChild( this._children.length, node, options );
    },
    
    // override
    removeChildWithIndex: function( node, indexOfChild ) {
      Node.prototype.removeChildWithIndex.call( this, node, indexOfChild );
      if ( this._elementMap[node.id] ) {
        delete this._elementMap[node.id];
      }
      
      this.updateLayout();
    },
    
    addElement: function( element ) {
      this._elements.push( element );
      element.node.addEventListener( 'bounds', this._boundsListener );
    },
    
    removeElement: function( element ) {
      this._elements.splice( this._elements.indexOf( element ), 1 ); // TODO: replace with some remove() instead of splice()
      element.node.removeEventListener( 'bounds', this._boundsListener );
    },
    
    // overrides the Node's bounds computation in a strictly increasing way (for Canvas support)
    overrideBounds: function( computedBounds ) {
      return this.layoutBounds;
    },
    
    updateLayout: function() {
      if ( this._activelyLayingOut ) {
        // don't start another layout while one is going on!
        return;
      }
      this._activelyLayingOut = true;
      var layoutProperties = this.layoutProperties;
      for ( var i = 0; i < this._elements.length; i++ ) {
        var element = this._elements[i];
        element.layoutMethod.layout( element, i, ( i > 0 ? this._elements[i-1] : null ), layoutProperties );
      }

      // use the invisible background to take up all of our layout areas
      // this._invisibleBackground.removeAllChildren();
      // var bounds = this.layoutBounds;
      // if ( !bounds.isEmpty() ) {
      //   this._invisibleBackground.addChild( new Rectangle( bounds, { visible: false } ) );
      // }

      // if ( debug ) {
      //   this._invisibleBackground.visible = true;
      //   this._invisibleBackground.fill = 'rgba(255,0,0,0.4)';
        
      //   _.each( this._elements, function( element ) {
      //     this._invisibleBackground.addChild( new Rectangle( element.node.bounds ), {
      //       fill: 'rgba(255,0,0,0.4)',
      //       stroke: 'blue'
      //     } );
      //   } );
      // }
      this._activelyLayingOut = false;
    }
  } );
  
  /*
   * LayoutMethod - function layout( element, index, previousElement, layoutProperties )
   */
  var LayoutMethod = LayoutNode.LayoutMethod = function LayoutMethod( layout ) {
    if ( layout ) {
      this.layout = layout;
    }
  };
  LayoutMethod.prototype = {
    constructor: LayoutMethod,
    
    and: function( otherLayoutMethod ) {
      var thisLayoutMethod = this;
      
      return new LayoutMethod( function compositeLayout( element, index, previousElement, layoutProperties ) {
        thisLayoutMethod.layout( element, index, previousElement, layoutProperties );
        otherLayoutMethod.layout( element, index, previousElement, layoutProperties );
      } );
    }
  };
  
  /*---------------------------------------------------------------------------*
  * Layout Methods
  *----------------------------------------------------------------------------*/

  LayoutNode.Vertical = new LayoutMethod( function verticalLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = previousElement ? previousElement.layoutBounds.bottom : 0;
  } );

  LayoutNode.Horizontal = new LayoutMethod( function horizontalLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = previousElement ? previousElement.layoutBounds.right : 0;
  } );

  LayoutNode.AlignLeft = new LayoutMethod( function alignLeftLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = 0;
  } );

  LayoutNode.AlignHorizontalCenter = new LayoutMethod( function alignHorizontalCenterLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = ( layoutProperties.maxWidth - element.layoutBounds.width ) / 2;
  } );

  LayoutNode.AlignRight = new LayoutMethod( function alignRightLayout( element, index, previousElement, layoutProperties ) {
    element.layoutLeft = layoutProperties.maxWidth - element.layoutBounds.width;
  } );

  LayoutNode.AlignTop = new LayoutMethod( function alignTopLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = 0;
  } );

  LayoutNode.AlignVerticalCenter = new LayoutMethod( function alignVerticalCenterLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = ( layoutProperties.maxHeight - element.layoutBounds.height ) / 2;
  } );

  LayoutNode.AlignBottom = new LayoutMethod( function alignBottomLayout( element, index, previousElement, layoutProperties ) {
    element.layoutTop = layoutProperties.maxHeight - element.layoutBounds.height;
  } );
  
  /*---------------------------------------------------------------------------*
  * Internals
  *----------------------------------------------------------------------------*/
  
  var LayoutProperties = LayoutNode.LayoutProperties = function LayoutProperties( elements ) {
    var largestWidth = 0;
    var largestHeight = 0;
    
    _.each( elements, function( element ) {
      largestWidth = Math.max( largestWidth, element.layoutBounds.width );
      largestHeight = Math.max( largestHeight, element.layoutBounds.height );
    } );

    this.maxWidth = largestWidth;
    this.maxHeight = largestHeight;
  };
  
  var LayoutElement = LayoutNode.LayoutElement = function LayoutElement( node, layoutMethodGetter, boundsMethod ) {
    this.node = node;
    this.layoutMethodGetter = layoutMethodGetter;
    this.boundsMethod = boundsMethod;
  };
  LayoutElement.prototype = {
    get bounds() { return this.node.bounds; },
    get layoutBounds() { return this.boundsMethod( this.bounds ); },
    get layoutMethod() { return this.layoutMethodGetter(); },
    
    get layoutTop() { throw new Error( 'JSHint wants this getter' ); },
    set layoutTop( y ) {
      var padding = this.bounds.top - this.layoutBounds.top;
      this.node.top = y + padding;
    },
    
    get layoutLeft() { throw new Error( 'JSHint wants this getter' ); },
    set layoutLeft( x ) {
      var padding = this.bounds.left - this.layoutBounds.left;
      this.node.left = x + padding;
    }
  };
  
  LayoutNode.prototype._mutatorKeys = [ 'defaultMethod', 'updateOnBounds' ].concat( Node.prototype._mutatorKeys );
  
  return LayoutNode;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A line that inherits Path, and allows for optimized drawing,
 * and improved line handling.
 *
 * TODO: add DOM support
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Line',['require','PHET_CORE/inherit','SCENERY/scenery','KITE/segments/Line','SCENERY/nodes/Path','KITE/Shape','DOT/Vector2'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var KiteLine = require( 'KITE/segments/Line' );
  
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Vector2 = require( 'DOT/Vector2' );
  
  /**
   * Currently, all numerical parameters should be finite.
   * x1:         x-position of the start
   * y1:         y-position of the start
   * x2:         x-position of the end
   * y2:         y-position of the end
   *
   * Available constructors:
   * new Line( x1, y1, x2, y2, { ... } )
   * new Line( new Vector2( x1, y1 ), new Vector2( x2, y2 ), { ... } )
   * new Line( { x1: x1, y1: y1, x2: x2, y2: y2,  ... } )
   */
  scenery.Line = function Line( x1, y1, x2, y2, options ) {
    if ( typeof x1 === 'object' ) {
      if ( x1 instanceof Vector2 ) {
        // assumes Line( Vector2, Vector2, options );
        this._x1 = x1.x;
        this._y1 = x1.y;
        this._x2 = y1.x;
        this._y2 = y1.y;
        options = x2 || {};
      } else {
        // assumes Line( { ... } ), init to zero for now
        this._x1 = 0;
        this._y1 = 0;
        this._x2 = 0;
        this._y2 = 0;
        options = x1 || {};
      }
    } else {
      // new Line(  x1, y1, x2, y2, [options] )
      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;
      
      // ensure we have a parameter object
      options = options || {};
    }
    // fallback for non-canvas or non-svg rendering, and for proper bounds computation
    
    Path.call( this, null, options );
  };
  var Line = scenery.Line;
  
  inherit( Path, Line, {
    setLine: function( x1, y1, x2, y2 ) {
      assert && assert( x1 !== undefined && y1 !== undefined && x2 !== undefined && y2 !== undefined, 'parameters need to be defined' );
      
      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;
      this.invalidateLine();
    },
    
    setPoint1: function( x1, y1 ) {
      if ( typeof x1 === 'number' ) {
        // setPoint1( x1, y1 );
        this.setLine( x1, y1, this._x2, this._y2 );
      } else {
        // setPoint1( Vector2 )
        this.setLine( x1.x, x1.y, this._x2, this._y2 );
      }
    },
    set p1( point ) { this.setPoint1( point ); },
    get p1() { return new Vector2( this._x1, this._y1 ); },
    
    setPoint2: function( x2, y2 ) {
      if ( typeof x2 === 'number' ) {
        // setPoint2( x2, y2 );
        this.setLine( this._x1, this._y1, x2, y2 );
      } else {
        // setPoint2( Vector2 )
        this.setLine( this._x1, this._y1, x2.x, x2.y );
      }
    },
    set p2( point ) { this.setPoint2( point ); },
    get p2() { return new Vector2( this._x2, this._y2 ); },
    
    createLineShape: function() {
      return Shape.lineSegment( this._x1, this._y1, this._x2, this._y2 );
    },
    
    invalidateLine: function() {
      assert && assert( isFinite( this._x1 ), 'A rectangle needs to have a finite x1 (' + this._x1 + ')' );
      assert && assert( isFinite( this._y1 ), 'A rectangle needs to have a finite y1 (' + this._y1 + ')' );
      assert && assert( isFinite( this._x2 ), 'A rectangle needs to have a finite x2 (' + this._x2 + ')' );
      assert && assert( isFinite( this._y2 ), 'A rectangle needs to have a finite y2 (' + this._y2 + ')' );
      
      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;
      
      // should invalidate the path and ensure a redraw
      this.invalidateShape();
    },
    
    containsPointSelf: function( point ) {
      if ( this._strokePickable ) {
        return Path.prototype.containsPointSelf.call( this, point );
      } else {
        return false; // nothing is in a line! (although maybe we should handle edge points properly?)
      }
    },
    
    intersectsBoundsSelf: function( bounds ) {
      // TODO: optimization
      return new KiteLine( this.p1, this.p2 ).intersectsBounds( bounds );
    },
    
    paintCanvas: function( wrapper ) {
      var context = wrapper.context;
      
      context.beginPath();
      context.moveTo( this._x1, this._y1 );
      context.lineTo( this._x2, this._y2 );
      context.closePath();
      
      if ( this._stroke ) {
        this.beforeCanvasStroke( wrapper ); // defined in Strokable
        context.stroke();
        this.afterCanvasStroke( wrapper ); // defined in Strokable
      }
    },
    
    computeShapeBounds: function() {
      return Path.prototype.computeShapeBounds.call( this );
    },
    
    // create a rect instead of a path, hopefully it is faster in implementations
    createSVGFragment: function( svg, defs, group ) {
      return document.createElementNS( scenery.svgns, 'line' );
    },
    
    // optimized for the rect element instead of path
    updateSVGFragment: function( rect ) {
      // see http://www.w3.org/TR/SVG/shapes.html#LineElement
      rect.setAttribute( 'x1', this._x1 );
      rect.setAttribute( 'y1', this._y1 );
      rect.setAttribute( 'x2', this._x2 );
      rect.setAttribute( 'y2', this._y2 );
      
      rect.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
    },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Line( ' + this._x1 + ', ' + this._y1 + ', ' + this._x1 + ', ' + this._y1 + ', {' + propLines + '} )';
    },
    
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Line to something non-null' );
      } else {
        // probably called from the Path constructor
        this.invalidateShape();
      }
    },
    
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createLineShape();
      }
      return this._shape;
    },
    
    hasShape: function() {
      return true;
    }
    
  } );
  
  function addLineProp( capitalizedShort ) {
    var lowerShort = capitalizedShort.toLowerCase();
    
    var getName = 'get' + capitalizedShort;
    var setName = 'set' + capitalizedShort;
    var privateName = '_' + lowerShort;
    
    Line.prototype[getName] = function() {
      return this[privateName];
    };
    
    Line.prototype[setName] = function( value ) {
      if ( this[privateName] !== value ) {
        this[privateName] = value;
        this.invalidateLine();
      }
      return this;
    };
    
    Object.defineProperty( Line.prototype, lowerShort, {
      set: Line.prototype[setName],
      get: Line.prototype[getName]
    } );
  }
  
  addLineProp( 'X1' );
  addLineProp( 'Y1' );
  addLineProp( 'X2' );
  addLineProp( 'Y2' );
  
  // not adding mutators for now
  Line.prototype._mutatorKeys = [ 'p1', 'p2', 'x1', 'y1', 'x2', 'y2' ].concat( Path.prototype._mutatorKeys );
  
  return Line;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A rectangular node that inherits Path, and allows for optimized drawing,
 * and improved rectangle handling.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/nodes/Rectangle',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Matrix3','SCENERY/util/Features'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Features = require( 'SCENERY/util/Features' );
  
  /**
   * Currently, all numerical parameters should be finite.
   * x:         x-position of the upper-left corner (left bound)
   * y:         y-position of the upper-left corner (top bound)
   * width:     width of the rectangle to the right of the upper-left corner, required to be >= 0
   * height:    height of the rectangle below the upper-left corner, required to be >= 0
   * arcWidth:  positive width of the rounded corner, or 0 to indicate the corner should be sharp
   * arcHeight: positive height of the rounded corner, or 0 to indicate the corner should be sharp
   */
  scenery.Rectangle = function Rectangle( x, y, width, height, arcWidth, arcHeight, options ) {
    if ( typeof x === 'object' ) {
      if ( x instanceof Bounds2 ) {
        // allow new Rectangle( bounds2, { ... } ) or new Rectangle( bounds2, arcWidth, arcHeight, options )
        this._rectX = x.minX;
        this._rectY = x.minY;
        this._rectWidth = x.width;
        this._rectHeight = x.height;
        if ( arguments.length < 3 ) {
          // Rectangle( bounds2, { ... } )
          options = y;
          this._rectArcWidth = 0;
          this._rectArcHeight = 0;
        } else {
          // Rectangle( bounds2, arcWidth, arcHeight, { ... } )
          options = height;
          this._rectArcWidth = y;
          this._rectArcHeight = width;
        }
      } else {
        // allow new Rectangle( { rectX: x, rectY: y, rectWidth: width, rectHeight: height, ... } )
        // the mutators will call invalidateRectangle() and properly set the shape
        options = x;
        this._rectX = options.rectX || 0;
        this._rectY = options.rectY || 0;
        this._rectWidth = options.rectWidth;
        this._rectHeight = options.rectHeight;
        this._rectArcWidth = options.rectArcWidth || 0;
        this._rectArcHeight = options.rectArcHeight || 0;
      }
    } else if ( arguments.length < 6 ) {
      // new Rectangle( x, y, width, height, [options] )
      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._rectArcWidth = 0;
      this._rectArcHeight = 0;
      
      // ensure we have a parameter object
      options = arcWidth || {};
      
    } else {
      // normal case with args (including arcWidth / arcHeight)
      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._rectArcWidth = arcWidth;
      this._rectArcHeight = arcHeight;
      
      // ensure we have a parameter object
      options = options || {};
      
    }
    // fallback for non-canvas or non-svg rendering, and for proper bounds computation

    Path.call( this, null, options );
  };
  var Rectangle = scenery.Rectangle;
  
  inherit( Path, Rectangle, {
    
    getMaximumArcSize: function() {
      return Math.min( this._rectWidth / 2, this._rectHeight / 2 );
    },
    
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern ) {
        if ( this.getLineJoin() === 'miter' || ( this.getLineJoin() === 'round' && Features.borderRadius ) ) {
          bitmask |= scenery.bitmaskSupportsDOM;
        }
      }
      return bitmask;
    },
    
    getPathRendererBitmask: function() {
      var bitmask = scenery.bitmaskSupportsCanvas | scenery.bitmaskSupportsSVG;
      
      var maximumArcSize = this.getMaximumArcSize();
      
      // If the top/bottom or left/right strokes touch and overlap in the middle (small rectangle, big stroke), our DOM method won't work.
      // Additionally, if we're handling rounded rectangles or a stroke with lineJoin 'round', we'll need borderRadius
      // We also require for DOM that if it's a rounded rectangle, it's rounded with circular arcs (for now, could potentially do a transform trick!)
      if ( ( !this.hasStroke() || ( this.getLineWidth() <= this._rectHeight && this.getLineWidth() <= this._rectWidth ) ) &&
           ( !this.isRounded() || ( Features.borderRadius && this._rectArcWidth === this._rectArcHeight ) ) &&
           this._rectArcHeight <= maximumArcSize && this._rectArcWidth <= maximumArcSize ) {
        bitmask |= scenery.bitmaskSupportsDOM;
      }
      
      return bitmask;
    },
    
    setRect: function( x, y, width, height, arcWidth, arcHeight ) {
      assert && assert( x !== undefined && y !== undefined && width !== undefined && height !== undefined, 'x/y/width/height need to be defined' );
      
      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._rectArcWidth = arcWidth || 0;
      this._rectArcHeight = arcHeight || 0;
      this.invalidateRectangle();
    },
    
    setRectBounds: function( bounds ) {
      this.setRect( bounds.x, bounds.y, bounds.width, bounds.height );
    },
    
    isRounded: function() {
      return this._rectArcWidth !== 0 && this._rectArcHeight !== 0;
    },
    
    computeShapeBounds: function() {
      var bounds = new Bounds2( this._rectX, this._rectY, this._rectX + this._rectWidth, this._rectY + this._rectHeight );
      if ( this._stroke ) {
        // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },
    
    createRectangleShape: function() {
      if ( this.isRounded() ) {
        // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
        var maximumArcSize = Math.min( this._rectWidth / 2, this._rectHeight / 2 );
        return Shape.roundRectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight,
                                     Math.min( maximumArcSize, this._rectArcWidth ), Math.min( maximumArcSize, this._rectArcHeight ) );
      } else {
        return Shape.rectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
      }
    },
    
    invalidateRectangle: function() {
      assert && assert( isFinite( this._rectX ), 'A rectangle needs to have a finite x (' + this._rectX + ')' );
      assert && assert( isFinite( this._rectY ), 'A rectangle needs to have a finite x (' + this._rectY + ')' );
      assert && assert( this._rectWidth >= 0 && isFinite( this._rectWidth ),
                                      'A rectangle needs to have a non-negative finite width (' + this._rectWidth + ')' );
      assert && assert( this._rectHeight >= 0 && isFinite( this._rectHeight ),
                                      'A rectangle needs to have a non-negative finite height (' + this._rectHeight + ')' );
      assert && assert( this._rectArcWidth >= 0 && isFinite( this._rectArcWidth ),
                                      'A rectangle needs to have a non-negative finite arcWidth (' + this._rectArcWidth + ')' );
      assert && assert( this._rectArcHeight >= 0 && isFinite( this._rectArcHeight ),
                                      'A rectangle needs to have a non-negative finite arcHeight (' + this._rectArcHeight + ')' );
      // assert && assert( !this.isRounded() || ( this._rectWidth >= this._rectArcWidth * 2 && this._rectHeight >= this._rectArcHeight * 2 ),
      //                                 'The rounded sections of the rectangle should not intersect (the length of the straight sections shouldn\'t be negative' );
      
      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;
      
      // should invalidate the path and ensure a redraw
      this.invalidateShape();
      
      // since we changed the rectangle arc width/height, it could make DOM work or not
      this.invalidateSupportedRenderers();
    },
    
    // accelerated hit detection for axis-aligned optionally-rounded rectangle
    // fast computation if it isn't rounded. if rounded, we check if a corner computation is needed (usually isn't), and only check that one needed corner
    containsPointSelf: function( point ) {
      var x = this._rectX;
      var y = this._rectY;
      var width = this._rectWidth;
      var height = this._rectHeight;
      var arcWidth = this._rectArcWidth;
      var arcHeight = this._rectArcHeight;
      var halfLine = this.getLineWidth() / 2;
      
      var result = true;
      if ( this._strokePickable ) {
        // test the outer boundary if we are stroke-pickable (if also fill-pickable, this is the only test we need)
        var rounded = this.isRounded();
        if ( !rounded && this.getLineJoin() === 'bevel' ) {
          // fall-back for bevel
          return Path.prototype.containsPointSelf.call( this, point );
        }
        var miter = this.getLineJoin() === 'miter' && !rounded;
        result = result && Rectangle.intersects( x - halfLine, y - halfLine,
                                                 width + 2 * halfLine, height + 2 * halfLine,
                                                 miter ? 0 : ( arcWidth + halfLine ), miter ? 0 : ( arcHeight + halfLine ),
                                                 point );
      }
      
      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          return result;
        } else {
          return Rectangle.intersects( x, y, width, height, arcWidth, arcHeight, point );
        }
      } else if ( this._strokePickable ) {
        return result && !Rectangle.intersects( x + halfLine, y + halfLine,
                                               width - 2 * halfLine, height - 2 * halfLine,
                                               arcWidth - halfLine, arcHeight - halfLine,
                                               point );
      } else {
        return false; // either fill nor stroke is pickable
      }
    },
    
    intersectsBoundsSelf: function( bounds ) {
      return !this.computeShapeBounds().intersection( bounds ).isEmpty();
    },
    
    // override paintCanvas with a faster version, since fillRect and drawRect don't affect the current default path
    paintCanvas: function( wrapper ) {
      var context = wrapper.context;
      
      // use the standard version if it's a rounded rectangle, since there is no Canvas-optimized version for that
      if ( this.isRounded() ) {
        context.beginPath();
        var maximumArcSize = this.getMaximumArcSize();
        var arcw = Math.min( this._rectArcWidth, maximumArcSize );
        var arch = Math.min( this._rectArcHeight, maximumArcSize );
        var lowX = this._rectX + arcw;
        var highX = this._rectX + this._rectWidth - arcw;
        var lowY = this._rectY + arch;
        var highY = this._rectY + this._rectHeight - arch;
        if ( arcw === arch ) {
          // we can use circular arcs, which have well defined stroked offsets
          context.arc( highX, lowY, arcw, -Math.PI / 2, 0, false );
          context.arc( highX, highY, arcw, 0, Math.PI / 2, false );
          context.arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false );
          context.arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false );
        } else {
          // we have to resort to elliptical arcs
          context.ellipse( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false );
          context.ellipse( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false );
          context.ellipse( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false );
          context.ellipse( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false );
        }
        context.closePath();
        
        if ( this._fill ) {
          this.beforeCanvasFill( wrapper ); // defined in Fillable
          context.fill();
          this.afterCanvasFill( wrapper ); // defined in Fillable
        }
        if ( this._stroke ) {
          this.beforeCanvasStroke( wrapper ); // defined in Strokable
          context.stroke();
          this.afterCanvasStroke( wrapper ); // defined in Strokable
        }
      } else {
        // TODO: how to handle fill/stroke delay optimizations here?
        if ( this._fill ) {
          this.beforeCanvasFill( wrapper ); // defined in Fillable
          context.fillRect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
          this.afterCanvasFill( wrapper ); // defined in Fillable
        }
        if ( this._stroke ) {
          this.beforeCanvasStroke( wrapper ); // defined in Strokable
          context.strokeRect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
          this.afterCanvasStroke( wrapper ); // defined in Strokable
        }
      }
    },
    
    // create a rect instead of a path, hopefully it is faster in implementations
    createSVGFragment: function( svg, defs, group ) {
      return document.createElementNS( scenery.svgns, 'rect' );
    },
    
    // optimized for the rect element instead of path
    updateSVGFragment: function( rect ) {
      // see http://www.w3.org/TR/SVG/shapes.html#RectElement
      rect.setAttribute( 'x', this._rectX );
      rect.setAttribute( 'y', this._rectY );
      rect.setAttribute( 'width', this._rectWidth );
      rect.setAttribute( 'height', this._rectHeight );
      
      // workaround for various browsers if rx=20, ry=0 (behavior is inconsistent, either identical to rx=20,ry=20, rx=0,ry=0. We'll treat it as rx=0,ry=0)
      // see https://github.com/phetsims/scenery/issues/183
      if ( this.isRounded() ) {
        var maximumArcSize = this.getMaximumArcSize();
        var arcw = Math.min( this._rectArcWidth, maximumArcSize );
        var arch = Math.min( this._rectArcHeight, maximumArcSize );
        rect.setAttribute( 'rx', arcw );
        rect.setAttribute( 'ry', arch );
      } else {
        rect.setAttribute( 'rx', 0 );
        rect.setAttribute( 'ry', 0 );
      }
      
      rect.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );
    },
    
    /*---------------------------------------------------------------------------*
     * DOM support
     *----------------------------------------------------------------------------*/
    
    domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer
    
    getDOMElement: function() {
      var fill = document.createElement( 'div' );
      var stroke = document.createElement( 'div' );
      fill.appendChild( stroke );
      fill.style.display = 'block';
      fill.style.position = 'absolute';
      fill.style.left = '0';
      fill.style.top = '0';
      stroke.style.display = 'block';
      stroke.style.position = 'absolute';
      stroke.style.left = '0';
      stroke.style.top = '0';
      return fill;
    },

    updateDOMElement: function( fill ) {
      var borderRadius = Math.min( this._rectArcWidth, this._rectArcHeight );
      
      fill.style.width = this._rectWidth + 'px';
      fill.style.height = this._rectHeight + 'px';
      fill.style[Features.borderRadius] = borderRadius + 'px'; // if one is zero, we are not rounded, so we do the min here
      fill.style.backgroundColor = this.getCSSFill();
      
      var stroke = fill.childNodes[0];
      if ( this.hasStroke() ) {
        stroke.style.width = ( this._rectWidth - this.getLineWidth() ) + 'px';
        stroke.style.height = ( this._rectHeight - this.getLineWidth() ) + 'px';
        stroke.style.left = ( -this.getLineWidth() / 2 ) + 'px';
        stroke.style.top = ( -this.getLineWidth() / 2 ) + 'px';
        stroke.style.borderStyle = 'solid';
        stroke.style.borderColor = this.getSimpleCSSFill();
        stroke.style.borderWidth = this.getLineWidth() + 'px';
        stroke.style[Features.borderRadius] = ( this.isRounded() || this.getLineJoin() === 'round' ) ? ( borderRadius + this.getLineWidth() / 2 ) + 'px' : '0';
      } else {
        stroke.style.borderStyle = 'none';
      }
    },
    
    // override the transform since we need to customize it with a DOM offset
    updateCSSTransform: function( transform, element ) {
      // shift the text vertically, postmultiplied with the entire transform.
      var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( this._rectX, this._rectY ) );
      scenery.Util.applyCSSTransform( matrix, element );
    },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Rectangle( ' + this._rectX + ', ' + this._rectY + ', ' + 
                                         this._rectWidth + ', ' + this._rectHeight + ', ' +
                                         this._rectArcWidth + ', ' + this._rectArcHeight + ', {' + propLines + '} )';
    },
    
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Rectangle to something non-null' );
      } else {
        // probably called from the Path constructor
        this.invalidateShape();
      }
    },
    
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createRectangleShape();
      }
      return this._shape;
    },
    
    hasShape: function() {
      return true;
    }
  } );
  
  function addRectProp( capitalizedShort ) {
    var getName = 'getRect' + capitalizedShort;
    var setName = 'setRect' + capitalizedShort;
    var privateName = '_rect' + capitalizedShort;
    
    Rectangle.prototype[getName] = function() {
      return this[privateName];
    };
    
    Rectangle.prototype[setName] = function( value ) {
      if ( this[privateName] !== value ) {
        this[privateName] = value;
        this.invalidateRectangle();
      }
      return this;
    };
    
    Object.defineProperty( Rectangle.prototype, 'rect' + capitalizedShort, {
      set: Rectangle.prototype[setName],
      get: Rectangle.prototype[getName]
    } );
  }
  
  addRectProp( 'X' );
  addRectProp( 'Y' );
  addRectProp( 'Width' );
  addRectProp( 'Height' );
  addRectProp( 'ArcWidth' );
  addRectProp( 'ArcHeight' );
  
  // not adding mutators for now
  Rectangle.prototype._mutatorKeys = [ 'rectX', 'rectY', 'rectWidth', 'rectHeight', 'rectArcWidth', 'rectArcHeight' ].concat( Path.prototype._mutatorKeys );
  
  Rectangle.intersects = function( x, y, width, height, arcWidth, arcHeight, point ) {
    var result = point.x >= x &&
                 point.x <= x + width &&
                 point.y >= y &&
                 point.y <= y + height;
    
    if ( !result || arcWidth <= 0 || arcHeight <= 0 ) {
      return result;
    }
    
    // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
    var maximumArcSize = Math.min( width / 2, height / 2 );
    arcWidth = Math.min( maximumArcSize, arcWidth );
    arcHeight = Math.min( maximumArcSize, arcHeight );
    
    // we are rounded and inside the logical rectangle (if it didn't have rounded corners)
    
    // closest corner arc's center (we assume the rounded rectangle's arcs are 90 degrees fully, and don't intersect)
    var closestCornerX, closestCornerY, guaranteedInside = false;
    
    // if we are to the inside of the closest corner arc's center, we are guaranteed to be in the rounded rectangle (guaranteedInside)
    if ( point.x < x + width / 2 ) {
      closestCornerX = x + arcWidth;
      guaranteedInside = guaranteedInside || point.x >= closestCornerX;
    } else {
      closestCornerX = x + width - arcWidth;
      guaranteedInside = guaranteedInside || point.x <= closestCornerX;
    }
    if ( guaranteedInside ) { return true; }
    
    if ( point.y < y + height / 2 ) {
      closestCornerY = y + arcHeight;
      guaranteedInside = guaranteedInside || point.y >= closestCornerY;
    } else {
      closestCornerY = y + height - arcHeight;
      guaranteedInside = guaranteedInside || point.y <= closestCornerY;
    }
    if ( guaranteedInside ) { return true; }
    
    // we are now in the rectangular region between the logical corner and the center of the closest corner's arc.
    
    // offset from the closest corner's arc center
    var offsetX = point.x - closestCornerX;
    var offsetY = point.y - closestCornerY;
    
    // normalize the coordinates so now we are dealing with a unit circle
    // (technically arc, but we are guaranteed to be in the area covered by the arc, so we just consider the circle)
    // NOTE: we are rounded, so both arcWidth and arcHeight are non-zero (this is well defined)
    offsetX /= arcWidth;
    offsetY /= arcHeight;
    
    offsetX *= offsetX;
    offsetY *= offsetY;
    return offsetX + offsetY <= 1; // return whether we are in the rounded corner. see the formula for an ellipse
  };
  
  Rectangle.rect = function( x, y, width, height, options ) {
    return new Rectangle( x, y, width, height, 0, 0, options );
  };
  
  Rectangle.roundedRect = function( x, y, width, height, arcWidth, arcHeight, options ) {
    return new Rectangle( x, y, width, height, arcWidth, arcHeight, options );
  };
  
  Rectangle.bounds = function( bounds, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, 0, 0, options );
  };
  
  Rectangle.roundedBounds = function( bounds, arcWidth, arcHeight, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, arcWidth, arcHeight, options );
  };
  
  return Rectangle;
} );



// Copyright 2002-2013, University of Colorado Boulder

/**
 * A node which always fills the entire screen, no matter what the transform is.
 * Used for showing an overlay on the screen e.g., when a popup dialog is shown.
 * This can fade the background to focus on the dialog/popup as well as intercept mouse events for dismissing the dialog/popup.
 * Note: This is currently implemented using large numbers, it should be rewritten to work in any coordinate frame, possibly using kite.Shape.plane()
 * TODO: Implement using infinite geometry
 *
 * @author Sam Reid
 */

define( 'SCENERY/nodes/Plane',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Rectangle'],function( require ) {
  

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Rectangle = require( 'SCENERY/nodes/Rectangle' );

  /**
   * @param options Any options for the plane, typically fill/opacity (many others such as scale, translation, rotation should have no effect)
   * @constructor
   */
  scenery.Plane = function Plane( options ) {
    Rectangle.call( this, -2000, -2000, 6000, 6000, options );
  };
  var Plane = scenery.Plane;

  return inherit( Rectangle, Plane );
} );
// Copyright 2002-2013, University of Colorado Boulder

/**
 * VBox arranges the child nodes vertically, and they can be centered, left or right justified.
 * Vertical spacing can be set as a constant or a function which depends on the adjacent nodes.
 *
 * See a dynamic test in scenery\tests\test-vbox.html
 *
 * @author Sam Reid
 */

define( 'SCENERY/nodes/VBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/AbstractBox'],function( require ) {
  

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var AbstractBox = require( 'SCENERY/nodes/AbstractBox' );

  /**
   *
   * @param options Same as Node.constructor.options with the following additions:
   *
   * spacing: can be a number or a function.  If a number, then it will be the vertical spacing between each object.
   *              If a function, then the function will have the signature function(top,bottom){} which returns the spacing between adjacent pairs of items.
   * align:   How to line up the items horizontally.  One of 'center', 'left' or 'right'.  Defaults to 'center'.
   *
   * @constructor
   */
  scenery.VBox = function VBox( options ) {
    AbstractBox.call( this, 'vertical', function() {
      var minX = _.min( _.map( this.children, function( child ) {return child.left;} ) );
      var maxX = _.max( _.map( this.children, function( child ) {return child.left + child.width;} ) );
      var centerX = (maxX + minX) / 2;

      //Start at y=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {y:number} option.
      var y = 0;
      for ( var i = 0; i < this.children.length; i++ ) {
        var child = this.children[i];
        child.top = y;

        //Set the position horizontally
        if ( this.options.align === 'left' ) {
          child.left = minX;
        }
        else if ( this.options.align === 'right' ) {
          child.right = maxX;
        }
        else {//default to center
          child.centerX = centerX;
        }

        //Move to the next vertical position.
        y += child.height + this.options.spacing( child, this.children[i + 1] );
      }
    }, options );
  };

  return inherit( AbstractBox, scenery.VBox );
} );
// Copyright 2002-2013, University of Colorado Boulder

/**
 * The PointerOverlay shows pointer locations in the scene.  This is useful when recording a session for interviews or when a teacher is broadcasting
 * a tablet session on an overhead projector.  See https://github.com/phetsims/scenery/issues/111
 *
 * Each pointer is rendered in a different <svg> so that CSS3 transforms can be used to make performance smooth on iPad.
 *
 * @author Sam Reid
 */

define( 'SCENERY/overlays/PointerOverlay',['require','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
  

  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  var Util = require( 'SCENERY/util/Util' );

  scenery.PointerOverlay = function PointerOverlay( scene ) {
    var pointerOverlay = this;
    this.scene = scene;

    // add element to show the pointers
    this.pointerSVGContainer = document.createElement( 'div' );
    this.pointerSVGContainer.style.position = 'absolute';
    this.pointerSVGContainer.style.top = 0;
    this.pointerSVGContainer.style.left = 0;
    this.pointerSVGContainer.style['pointer-events'] = 'none';

    var innerRadius = 10;
    var strokeWidth = 1;
    var diameter = (innerRadius + strokeWidth / 2) * 2;
    var radius = diameter / 2;

    //Resize the parent div when the scene is resized
    scene.addEventListener( 'resize', function( args ) {
      pointerOverlay.pointerSVGContainer.setAttribute( 'width', args.width );
      pointerOverlay.pointerSVGContainer.setAttribute( 'height', args.height );
      pointerOverlay.pointerSVGContainer.style.clip = 'rect(0px,' + args.width + 'px,' + args.height + 'px,0px)';
    }, false );

    //Display a pointer that was added.  Use a separate SVG layer for each pointer so it can be hardware accelerated, otherwise it is too slow just setting svg internal attributes
    var pointerAdded = this.pointerAdded = function( pointer ) {

      if ( pointer.isKey ) { return; }

      var svg = document.createElementNS( scenery.svgns, 'svg' );
      svg.style.position = 'absolute';
      svg.style.top = 0;
      svg.style.left = 0;
      svg.style['pointer-events'] = 'none';

      //Fit the size to the display
      svg.setAttribute( 'width', diameter );
      svg.setAttribute( 'height', diameter );

      var circle = document.createElementNS( scenery.svgns, 'circle' );

      //use css transform for performance?
      circle.setAttribute( 'cx', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'cy', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'r', innerRadius );
      circle.setAttribute( 'style', 'fill:black;' );
      circle.setAttribute( 'opacity', 0.4 );

      //Add a move listener to the pointer to update position when it has moved
      var pointerRemoved = function() {

        //For touches that get a touch up event, remove them.  But when the mouse button is released, don't stop showing the mouse location
        if ( pointer.isTouch ) {
          pointerOverlay.pointerSVGContainer.removeChild( svg );
          pointer.removeInputListener( moveListener );
        }
      };
      var moveListener = {
        move: function() {

          //TODO: Why is point sometimes null?
          if ( pointer.point ) {

            //TODO: this allocates memory when pointers are dragging, perhaps rewrite to remove allocations
            Util.applyCSSTransform( Matrix3.translation( pointer.point.x - radius, pointer.point.y - radius ), svg );
          }
        },

        up: pointerRemoved,
        cancel: pointerRemoved
      };
      pointer.addInputListener( moveListener );

      moveListener.move();
      svg.appendChild( circle );
      pointerOverlay.pointerSVGContainer.appendChild( svg );
    };
    scene.input.addPointerAddedListener( pointerAdded );

    //if there is already a mouse, add it here
    //TODO: if there already other non-mouse touches, could be added here
    if ( scene.input && scene.input.mouse ) {
      pointerAdded( scene.input.mouse );
    }

    scene.reindexLayers();
    scene.$main[0].appendChild( this.pointerSVGContainer );
  };
  var PointerOverlay = scenery.PointerOverlay;

  PointerOverlay.prototype = {
    dispose: function() {
      this.scene.$main[0].removeChild( this.pointerSVGContainer );
      this.scene.input.removePointerAddedListener( this.pointerAdded );
    },

    reindex: function( index ) {
      this.pointerSVGContainer.style.zIndex = index; //Make sure it is in front of enough other things!
    }
  };

  return PointerOverlay;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Accessibility peer, which is added to the dom for focus and keyboard navigation.
 *
 * @author Sam Reid
 */

define( 'SCENERY/util/AccessibilityPeer',['require','SCENERY/scenery'],function( require ) {
  

  var scenery = require( 'SCENERY/scenery' );
  
  var AccessibilityPeer = scenery.AccessibilityPeer = function AccessibilityPeer( instance, element, options ) {
    var peer = this;
    
    options = options || {};

    //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.
    //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40
    options.tabIndex = options.tabIndex || 1;
    
    // TODO: if element is a DOM element, verify that no other accessibility peer is using it! (add a flag, and remove on disposal)
    this.element = ( typeof element === 'string' ) ? $( element )[0] : element;

    if ( options.label ) {
      this.peerElement = document.createElement( 'div' );
      this.element.id = 'peer-' + instance.trail.getUniqueId();
      var label = document.createElement('label');
      label.appendChild(document.createTextNode(options.label));
      label.setAttribute('for',this.element.id);
      this.peerElement.appendChild(label);
      this.peerElement.appendChild(this.element);
    } else{
      this.peerElement = this.element;
    }

    this.instance = instance;
    this.trail = instance.trail;
    
    this.element.setAttribute( 'tabindex', options.tabIndex );
    this.element.style.position = 'absolute';
    
    // TODO: batch these also if the Scene is batching events
    var scene = instance.getScene();
    this.clickListener = function PeerClickListener( event ) {
      sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer click on ' + instance.toString() + ': ' + instance.getNode().constructor.name );
      if ( options.click ) { options.click( event ); }
    };
    this.focusListener = function PeerFocusListener( event ) {
      sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer focused: ' + instance.toString() + ': ' + instance.getNode().constructor.name );
      scene.focusPeer( peer );
    };
    this.blurListener = function PeerBlurListener( event ) {
      sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer blurred: ' + instance.toString() + ': ' + instance.getNode().constructor.name );
      scene.blurPeer( peer );
    };
    this.element.addEventListener( 'click', this.clickListener );
    this.element.addEventListener( 'focus', this.focusListener );
    this.element.addEventListener( 'blur', this.blurListener );

    this.keepPeerBoundsInSync = true;
    if ( this.keepPeerBoundsInSync ) {
      this.boundsSyncListener = this.syncBounds.bind( this );

      instance.getNode().addEventListener( 'bounds', this.boundsSyncListener );
      this.syncBounds();

      //When the scene resizes, update the peer bounds
      instance.getScene().addEventListener( 'resize', this.boundsSyncListener );

      //Initial layout
      window.setTimeout( this.syncBounds.bind( this ), 30 );
    }
  };

  AccessibilityPeer.prototype = {
    constructor: AccessibilityPeer,
    
    dispose: function() {
      this.element.removeEventListener( 'click', this.clickListener );
      this.element.removeEventListener( 'focus', this.focusListener );
      this.element.removeEventListener( 'blur', this.blurListener );
      
      // don't leak memory
      if ( this.keepPeerBoundsInSync ) {
        this.instance.getNode().removeEventListener( 'bounds', this.boundsSyncListener );
        this.instance.getScene().removeEventListener( 'resize', this.boundsSyncListener );
      }
    },
    
    getGlobalBounds: function() {
      return this.trail.parentToGlobalBounds( this.trail.lastNode().getBounds() ).roundedOut();
    },
    
    syncBounds: function() {
      var globalBounds = this.getGlobalBounds();
      this.element.style.left = globalBounds.x + 'px';
      this.element.style.top = globalBounds.y + 'px';
      this.element.style.width = globalBounds.width + 'px';
      this.element.style.height = globalBounds.height + 'px';
    }
  };
  
  return AccessibilityPeer;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Encapsulates common color information and transformations.
 *
 * See http://www.w3.org/TR/css3-color/
 *
 * TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Color',['require','SCENERY/scenery','DOT/Util','DOT/Util'],function( require ) {
  

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var clamp = require( 'DOT/Util' ).clamp;
  var linear = require( 'DOT/Util' ).linear;

  // r,g,b integers 0-255, 'a' float 0-1
  scenery.Color = function Color( r, g, b, a ) {
    
    // allow listeners to be notified on any changes. called with listener()
    this.listeners = [];

    if ( typeof r === 'string' ) {
      var str = r.replace( / /g, '' ).toLowerCase();
      var success = false;
      
      // replace colors based on keywords
      var keywordMatch = Color.colorKeywords[str];
      if ( keywordMatch ) {
        str = '#' + keywordMatch;
      }
      
      // run through the available text formats
      for ( var i = 0; i < Color.formatParsers.length; i++ ) {
        var parser = Color.formatParsers[i];
        
        var matches = parser.regexp.exec( str );
        if ( matches ) {
          parser.apply( this, matches );
          success = true;
          break;
        }
      }
      
      if ( !success ) {
        throw new Error( 'scenery.Color unable to parse color string: ' + r );
      }
    } else {
      // alpha
      var alpha = a === undefined ? 1 : a;

      // bitwise handling if 3 elements aren't defined
      if ( g === undefined || b === undefined ) {
        this.setRGBA( ( r >> 16 ) && 0xFF,
                      ( r >> 8 ) && 0xFF,
                      ( r >> 0 ) && 0xFF,
                      alpha );
      }
      else {
        // otherwise, copy them over
        this.setRGBA( r, g, b, alpha );
      }
    }
    
    phetAllocation && phetAllocation( 'Color' );
  };
  var Color = scenery.Color;
  
  // regex utilities
  var rgbNumber = '(-?\\d{1,3}%?)'; // syntax allows negative integers and percentages
  var aNumber = '(\\d+|\\d*\\.\\d+)'; // decimal point number. technically we allow for '255', even though this will be clamped to 1.
  var rawNumber = '(\\d{1,3})'; // a 1-3 digit number
  
  // handles negative and percentage values
  function parseRGBNumber( str ) {
    var multiplier = 1;
    
    // if it's a percentage, strip it off and handle it that way
    if ( str.charAt( str.length - 1 ) === '%' ) {
      multiplier = 2.55;
      str = str.slice( 0, str.length - 1 );
    }
    
    return Math.round( parseInt( str, 10 ) * multiplier );
  }
  
  Color.formatParsers = [
    {
      // 'transparent'
      regexp: /^transparent$/,
      apply: function( color, matches ) {
        color.setRGBA( 0, 0, 0, 0 );
      }
    },{
      // short hex form, a la '#fff'
      regexp: /^#(\w{1})(\w{1})(\w{1})$/,
      apply: function( color, matches ) {
        color.setRGBA( parseInt( matches[1] + matches[1], 16 ),
                       parseInt( matches[2] + matches[2], 16 ),
                       parseInt( matches[3] + matches[3], 16 ),
                       1 );
      }
    },{
      // long hex form, a la '#ffffff'
      regexp: /^#(\w{2})(\w{2})(\w{2})$/,
      apply: function( color, matches ) {
        color.setRGBA( parseInt( matches[1], 16 ),
                       parseInt( matches[2], 16 ),
                       parseInt( matches[3], 16 ),
                       1 );
      }
    },{
      // rgb(...)
      regexp: new RegExp( '^rgb\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA( parseRGBNumber( matches[1] ),
                       parseRGBNumber( matches[2] ),
                       parseRGBNumber( matches[3] ),
                       1 );
      }
    },{
      // rgba(...)
      regexp: new RegExp( '^rgba\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + ',' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA( parseRGBNumber( matches[1] ),
                       parseRGBNumber( matches[2] ),
                       parseRGBNumber( matches[3] ),
                       parseFloat( matches[4] ) );
      }
    },{
      // hsl(...)
      regexp: new RegExp( '^hsl\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA( parseInt( matches[1], 10 ),
                       parseInt( matches[2], 10 ),
                       parseInt( matches[3], 10 ),
                       1 );
      }
    },{
      // hsla(...)
      regexp: new RegExp( '^hsla\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%,' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA( parseInt( matches[1], 10 ),
                       parseInt( matches[2], 10 ),
                       parseInt( matches[3], 10 ),
                       parseFloat( matches[4] ) );
      }
    }
  ];
  
  // see http://www.w3.org/TR/css3-color/
  Color.hueToRGB = function( m1, m2, h ) {
    if ( h < 0 ) {
      h = h + 1;
    }
    if ( h > 1 ) {
      h = h - 1;
    }
    if ( h * 6 < 1 ) {
      return m1 + ( m2 - m1 ) * h * 6;
    }
    if ( h * 2 < 1 ) {
      return m2;
    }
    if ( h * 3 < 2 ) {
      return m1 + ( m2 - m1 ) * ( 2 / 3 - h ) * 6;
    }
    return m1;
  };

  /**
   * Convenience function that converts a color spec to a color object if
   * necessary, or simply returns the color object if not.
   * @param {String|Color} colorSpec
   */
  Color.toColor = function( colorSpec ) {
    return colorSpec instanceof Color ? colorSpec : new Color( colorSpec );
  };
  
  Color.prototype = {
    constructor: Color,
    
    copy: function() {
      return new Color( this.r, this.g, this.b, this.a );
    },
    
    // red, integral 0-255
    getRed: function() { return this.r; },
    setRed: function( value ) { return this.setRGBA( value, this.g, this.b, this.a ); },
    get red() { return this.getRed(); },
    set red( value ) { return this.setRed( value ); },
    
    // green, integral 0-255
    getGreen: function() { return this.g; },
    setGreen: function( value ) { return this.setRGBA( this.r, value, this.b, this.a ); },
    get green() { return this.getGreen(); },
    set green( value ) { return this.setGreen( value ); },
    
    // blue, integral 0-255
    getBlue: function() { return this.b; },
    setBlue: function( value ) { return this.setRGBA( this.r, this.g, value, this.a ); },
    get blue() { return this.getBlue(); },
    set blue( value ) { return this.setBlue( value ); },
    
    // alpha, floating 0-1
    getAlpha: function() { return this.a; },
    setAlpha: function( value ) { return this.setRGBA( this.r, this.g, this.b, value ); },
    get alpha() { return this.getAlpha(); },
    set alpha( value ) { return this.setAlpha( value ); },
    
    // RGB integral between 0-255, alpha (float) between 0-1
    setRGBA: function( red, green, blue, alpha ) {
      this.r = Math.round( clamp( red, 0, 255 ) );
      this.g = Math.round( clamp( green, 0, 255 ) );
      this.b = Math.round( clamp( blue, 0, 255 ) );
      this.a = clamp( alpha, 0, 1 );
      
      this.updateColor(); // update the cached value
      
      return this; // allow chaining
    },
    
    computeCSS: function() {
      if ( this.a === 1 ) {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      } else {
        var alphaString = this.a === 0 || this.a === 1 ? this.a : this.a.toFixed( 20 ); // toFixed prevents scientific notation
        return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alphaString + ')';
      }
    },
    
    toCSS: function() {
      // verify that the cached value is correct (in debugging builds only, defeats the point of caching otherwise)
      assert && assert( this._css === this.computeCSS(), 'CSS cached value is ' + this._css + ', but the computed value appears to be ' + this.computeCSS() );
      
      return this._css;
    },
    
    // called to update the interally cached CSS value
    updateColor: function() {
      assert && assert( !this.immutable, 'Cannot modify an immutable color' );
      
      var oldCSS = this._css;
      this._css = this.computeCSS();
      
      // notify listeners if it changed
      if ( oldCSS !== this._css && this.listeners.length ) {
        var listeners = this.listeners.slice( 0 ); // defensive copy. consider removing if it's a performance bottleneck?
        var length = listeners.length;
        
        for ( var i = 0; i < length; i++ ) {
          listeners[i]();
        }
      }
    },
    
    // allow setting this Color to be immutable when assertions are disabled. any change will throw an error
    setImmutable: function() {
      if ( assert ) {
        this.immutable = true;
      }
      
      return this; // allow chaining
    },
    
    // to what value a Canvas's context.fillStyle should be set
    getCanvasStyle: function() {
      return this.toCSS(); // should be inlined, leave like this for future maintainability
    },
    
    // TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
    setHSLA: function( hue, saturation, lightness, alpha ) {
      hue = ( hue % 360 ) / 360;                    // integer modulo 360
      saturation = clamp( saturation / 100, 0, 1 ); // percentage
      lightness = clamp( lightness / 100, 0, 1 );   // percentage
      
      // see http://www.w3.org/TR/css3-color/
      var m1, m2;
      if ( lightness < 0.5 ) {
        m2 = lightness * ( saturation + 1 );
      } else {
        m2 = lightness + saturation - lightness * saturation;
      }
      m1 = lightness * 2 - m2;
      
      this.r = Math.round( Color.hueToRGB( m1, m2, hue + 1/3 ) * 255 );
      this.g = Math.round( Color.hueToRGB( m1, m2, hue ) * 255 );
      this.b = Math.round( Color.hueToRGB( m1, m2, hue - 1/3 ) * 255 );
      this.a = clamp( alpha, 0, 1 );
      
      this.updateColor(); // update the cached value
      
      return this; // allow chaining
    },
    
    equals: function( color ) {
      return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
    },
    
    withAlpha: function( alpha ) {
      return new Color( this.r, this.g, this.b, alpha );
    },
    
    checkFactor: function( factor ) {
      if ( factor < 0 || factor > 1 ) {
        throw new Error( 'factor must be between 0 and 1: ' + factor );
      }
      return ( factor === undefined ) ? 0.7 : factor;
    },
    
    // matches Java's Color.brighter()
    brighterColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red   = Math.min( 255, Math.floor( this.r / factor ) );
      var green = Math.min( 255, Math.floor( this.g / factor ) );
      var blue  = Math.min( 255, Math.floor( this.b / factor ) );
      return new Color( red, green, blue, this.a );
    },
    
    /**
     * Brightens a color in RGB space. Useful when creating gradients from a
     * single base color.
     *
     * @param color
     * @param factor 0 (no change) to 1 (white)
     * @return lighter (closer to white) version of the original color.
     */
    colorUtilsBrighter: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, this.getRed() + Math.floor( factor * ( 255 - this.getRed() ) ) );
      var green = Math.min( 255, this.getGreen() + Math.floor( factor * ( 255 - this.getGreen() ) ) );
      var blue = Math.min( 255, this.getBlue() + Math.floor( factor * ( 255 - this.getBlue() ) ) );
      return new Color( red, green, blue, this.getAlpha() );
    },
    
    // matches Java's Color.darker()
    darkerColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red   = Math.max( 0, Math.floor( factor * this.r ) );
      var green = Math.max( 0, Math.floor( factor * this.g ) );
      var blue  = Math.max( 0, Math.floor( factor * this.b ) );
      return new Color( red, green, blue, this.a );
    },
    
    /**
     * Darken a color in RGB space. Useful when creating gradients from a single
     * base color.
     *
     * @param color  the original color
     * @param factor 0 (no change) to 1 (black)
     * @return darker (closer to black) version of the original color.
     */
    colorUtilsDarker: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, this.getRed() - Math.floor( factor * this.getRed() ) );
      var green = Math.max( 0, this.getGreen() - Math.floor( factor * this.getGreen() ) );
      var blue = Math.max( 0, this.getBlue() - Math.floor( factor * this.getBlue() ) );
      return new Color( red, green, blue, this.getAlpha() );
    },
    
    /*
     * Like colorUtilsBrighter/Darker, however factor should be in the range -1 to 1, and it will call:
     *   colorUtilsBrighter( factor )   for factor >  0
     *   this                           for factor == 0
     *   colorUtilsDarker( -factor )    for factor <  0
     * Thus:
     * @param factor from -1 (black), to 0 (no change), to 1 (white)
     */
    colorUtilsBrightness: function( factor ) {
      if ( factor === 0 ) {
        return this;
      } else if ( factor > 0 ) {
        return this.colorUtilsBrighter( factor );
      } else {
        return this.colorUtilsDarker( -factor );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * listeners TODO: consider mixing in this behavior, it's common
    *----------------------------------------------------------------------------*/
    
    // listener should be a callback expecting no arguments, listener() will be called when the color changes
    addChangeListener: function( listener ) {
      assert && assert( listener !== undefined && listener !== null, 'Verify that the listener exists' );
      assert && assert( !_.contains( this.listeners, listener ) );
      this.listeners.push( listener );
    },
    
    removeChangeListener: function( listener ) {
      assert && assert( _.contains( this.listeners, listener ) );
      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
    },

    toString: function() {
      return this.constructor.name + "[r:" + this.r + " g:" + this.g + " b:" + this.b + " a:" + this.a + "]";
    }
  };
  
  Color.basicColorKeywords = {
    aqua:    '00ffff',
    black:   '000000',
    blue:    '0000ff',
    fuchsia: 'ff00ff',
    gray:    '808080',
    green:   '008000',
    lime:    '00ff00',
    maroon:  '800000',
    navy:    '000080',
    olive:   '808000',
    purple:  '800080',
    red:     'ff0000',
    silver:  'c0c0c0',
    teal:    '008080',
    white:   'ffffff',
    yellow:  'ffff00'
  };
  
  Color.colorKeywords = {
    aliceblue:            'f0f8ff',
    antiquewhite:         'faebd7',
    aqua:                 '00ffff',
    aquamarine:           '7fffd4',
    azure:                'f0ffff',
    beige:                'f5f5dc',
    bisque:               'ffe4c4',
    black:                '000000',
    blanchedalmond:       'ffebcd',
    blue:                 '0000ff',
    blueviolet:           '8a2be2',
    brown:                'a52a2a',
    burlywood:            'deb887',
    cadetblue:            '5f9ea0',
    chartreuse:           '7fff00',
    chocolate:            'd2691e',
    coral:                'ff7f50',
    cornflowerblue:       '6495ed',
    cornsilk:             'fff8dc',
    crimson:              'dc143c',
    cyan:                 '00ffff',
    darkblue:             '00008b',
    darkcyan:             '008b8b',
    darkgoldenrod:        'b8860b',
    darkgray:             'a9a9a9',
    darkgreen:            '006400',
    darkkhaki:            'bdb76b',
    darkmagenta:          '8b008b',
    darkolivegreen:       '556b2f',
    darkorange:           'ff8c00',
    darkorchid:           '9932cc',
    darkred:              '8b0000',
    darksalmon:           'e9967a',
    darkseagreen:         '8fbc8f',
    darkslateblue:        '483d8b',
    darkslategray:        '2f4f4f',
    darkturquoise:        '00ced1',
    darkviolet:           '9400d3',
    deeppink:             'ff1493',
    deepskyblue:          '00bfff',
    dimgray:              '696969',
    dodgerblue:           '1e90ff',
    feldspar:             'd19275',
    firebrick:            'b22222',
    floralwhite:          'fffaf0',
    forestgreen:          '228b22',
    fuchsia:              'ff00ff',
    gainsboro:            'dcdcdc',
    ghostwhite:           'f8f8ff',
    gold:                 'ffd700',
    goldenrod:            'daa520',
    gray:                 '808080',
    green:                '008000',
    greenyellow:          'adff2f',
    honeydew:             'f0fff0',
    hotpink:              'ff69b4',
    indianred :           'cd5c5c',
    indigo :              '4b0082',
    ivory:                'fffff0',
    khaki:                'f0e68c',
    lavender:             'e6e6fa',
    lavenderblush:        'fff0f5',
    lawngreen:            '7cfc00',
    lemonchiffon:         'fffacd',
    lightblue:            'add8e6',
    lightcoral:           'f08080',
    lightcyan:            'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgrey:            'd3d3d3',
    lightgreen:           '90ee90',
    lightpink:            'ffb6c1',
    lightsalmon:          'ffa07a',
    lightseagreen:        '20b2aa',
    lightskyblue:         '87cefa',
    lightslateblue:       '8470ff',
    lightslategray:       '778899',
    lightsteelblue:       'b0c4de',
    lightyellow:          'ffffe0',
    lime:                 '00ff00',
    limegreen:            '32cd32',
    linen:                'faf0e6',
    magenta:              'ff00ff',
    maroon:               '800000',
    mediumaquamarine:     '66cdaa',
    mediumblue:           '0000cd',
    mediumorchid:         'ba55d3',
    mediumpurple:         '9370d8',
    mediumseagreen:       '3cb371',
    mediumslateblue:      '7b68ee',
    mediumspringgreen:    '00fa9a',
    mediumturquoise:      '48d1cc',
    mediumvioletred:      'c71585',
    midnightblue:         '191970',
    mintcream:            'f5fffa',
    mistyrose:            'ffe4e1',
    moccasin:             'ffe4b5',
    navajowhite:          'ffdead',
    navy:                 '000080',
    oldlace:              'fdf5e6',
    olive:                '808000',
    olivedrab:            '6b8e23',
    orange:               'ffa500',
    orangered:            'ff4500',
    orchid:               'da70d6',
    palegoldenrod:        'eee8aa',
    palegreen:            '98fb98',
    paleturquoise:        'afeeee',
    palevioletred:        'd87093',
    papayawhip:           'ffefd5',
    peachpuff:            'ffdab9',
    peru:                 'cd853f',
    pink:                 'ffc0cb',
    plum:                 'dda0dd',
    powderblue:           'b0e0e6',
    purple:               '800080',
    red:                  'ff0000',
    rosybrown:            'bc8f8f',
    royalblue:            '4169e1',
    saddlebrown:          '8b4513',
    salmon:               'fa8072',
    sandybrown:           'f4a460',
    seagreen:             '2e8b57',
    seashell:             'fff5ee',
    sienna:               'a0522d',
    silver:               'c0c0c0',
    skyblue:              '87ceeb',
    slateblue:            '6a5acd',
    slategray:            '708090',
    snow:                 'fffafa',
    springgreen:          '00ff7f',
    steelblue:            '4682b4',
    tan:                  'd2b48c',
    teal:                 '008080',
    thistle:              'd8bfd8',
    tomato:               'ff6347',
    turquoise:            '40e0d0',
    violet:               'ee82ee',
    violetred:            'd02090',
    wheat:                'f5deb3',
    white:                'ffffff',
    whitesmoke:           'f5f5f5',
    yellow:               'ffff00',
    yellowgreen:          '9acd32'
  };
  
  // Java compatibility
  Color.BLACK      = new Color( 0,   0,   0   ).setImmutable();
  Color.BLUE       = new Color( 0,   0,   255 ).setImmutable();
  Color.CYAN       = new Color( 0,   255, 255 ).setImmutable();
  Color.DARK_GRAY  = new Color( 64,  64,  64  ).setImmutable();
  Color.GRAY       = new Color( 128, 128, 128 ).setImmutable();
  Color.GREEN      = new Color( 0,   255, 0   ).setImmutable();
  Color.LIGHT_GRAY = new Color( 192, 192, 192 ).setImmutable();
  Color.MAGENTA    = new Color( 255, 0,   255 ).setImmutable();
  Color.ORANGE     = new Color( 255, 200, 0   ).setImmutable();
  Color.PINK       = new Color( 255, 175, 175 ).setImmutable();
  Color.RED        = new Color( 255, 0,   0   ).setImmutable();
  Color.WHITE      = new Color( 255, 255, 255 ).setImmutable();
  Color.YELLOW     = new Color( 255, 255, 0   ).setImmutable();

  /**
   * Interpolates between 2 colors in RGBA space. When distance is 0, color1
   * is returned. When distance is 1, color2 is returned. Other values of
   * distance return a color somewhere between color1 and color2. Each color
   * component is interpolated separately.
   *
   * @param {Color} color1
   * @param {Color} color2
   * @param {Number} distance distance between color1 and color2, 0 <= distance <= 1
   * @return {Color}
   */
  Color.interpolateRBGA = function( color1, color2, distance ) {
    if ( distance < 0 || distance > 1 ) {
      throw new Error( 'distance must be between 0 and 1: ' + distance );
    }
    var r = Math.floor( linear( 0, 1, color1.r, color2.r, distance ) );
    var g = Math.floor( linear( 0, 1, color1.g, color2.g, distance ) );
    var b = Math.floor( linear( 0, 1, color1.b, color2.b, distance ) );
    var a = linear( 0, 1, color1.a, color2.a, distance );
    return new Color( r, g, b, a );
  };

  return Color;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Gradient base type for LinearGradient and RadialGradient. Will not function on its own
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Gradient',['require','SCENERY/util/Color','SCENERY/scenery'],function( require ) {
  
  
  require( 'SCENERY/util/Color' );
  var scenery = require( 'SCENERY/scenery' );
  
  // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
  scenery.Gradient = function Gradient( canvasGradient ) {
    assert && assert( this.constructor.name !== 'Gradient', 'Please create a LinearGradient or RadialGradient. Do not directly use the supertype Gradient.' );
    
    this.stops = [];
    this.lastStopRatio = 0;
    
    this.canvasGradient = canvasGradient;
    
    this.transformMatrix = null;
  };
  var Gradient = scenery.Gradient;
  
  Gradient.prototype = {
    constructor: Gradient,
    
    isGradient: true,
    
    /**
     * @param {Number} ratio        Monotonically increasing value in the range of 0 to 1
     * @param {Color|String} color  Color for the stop, either a scenery.Color or CSS color string
     */
    addColorStop: function( ratio, color ) {
      // TODO: invalidate the gradient?
      if ( this.lastStopRatio > ratio ) {
        // fail out, since browser quirks go crazy for this case
        throw new Error( 'Color stops not specified in the order of increasing ratios' );
      } else {
        this.lastStopRatio = ratio;
      }
      
      // make sure we have a scenery.Color now
      if ( typeof color === 'string' ) {
        color = new scenery.Color( color );
      }
      
      this.stops.push( {
        ratio: ratio,
        color: color
      } );
      
      // construct the Canvas gradient as we go
      this.canvasGradient.addColorStop( ratio, color.toCSS() );
      return this;
    },
    
    setTransformMatrix: function( transformMatrix ) {
      // TODO: invalidate the gradient?
      if ( this.transformMatrix !== transformMatrix ) {
        this.transformMatrix = transformMatrix;
      }
      return this;
    },
    
    getCanvasStyle: function() {
      return this.canvasGradient;
    }
  };
  
  return Gradient;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A linear gradient that can be passed into the 'fill' or 'stroke' parameters.
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/LinearGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Gradient = require( 'SCENERY/util/Gradient' );

  // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
  scenery.LinearGradient = function LinearGradient( x0, y0, x1, y1 ) {
    assert && assert( isFinite( x0 ) && isFinite( y0 ) && isFinite( x1 ) && isFinite( y1 ) );
    var usesVectors = y1 === undefined;
    if ( usesVectors ) {
      assert && assert( ( x0 instanceof Vector2 ) && ( y0 instanceof Vector2 ), 'If less than 4 parameters are given, the first two parameters must be Vector2' );
    }
    this.start = usesVectors ? x0 : new Vector2( x0, y0 );
    this.end = usesVectors ? y0 : new Vector2( x1, y1 );
    
    // use the global scratch canvas instead of creating a new Canvas
    Gradient.call( this, scenery.scratchContext.createLinearGradient( x0, y0, x1, y1 ) );
  };
  var LinearGradient = scenery.LinearGradient;
  
  inherit( Gradient, LinearGradient, {
    
    isLinearGradient: true,
    
    // seems we need the defs: http://stackoverflow.com/questions/7614209/linear-gradients-in-svg-without-defs
    // SVG: spreadMethod 'pad' 'reflect' 'repeat' - find Canvas usage
    getSVGDefinition: function( id ) {
      /* Approximate example of what we are creating:
      <linearGradient id="grad2" x1="0" y1="0" x2="100" y2="0" gradientUnits="userSpaceOnUse">
        <stop offset="0" style="stop-color:rgb(255,255,0);stop-opacity:1" />
        <stop offset="0.5" style="stop-color:rgba(255,255,0,0);stop-opacity:0" />
        <stop offset="1" style="stop-color:rgb(255,0,0);stop-opacity:1" />
      </linearGradient>
      */
      var definition = document.createElementNS( scenery.svgns, 'linearGradient' );
      definition.setAttribute( 'id', id );
      definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
      definition.setAttribute( 'x1', this.start.x );
      definition.setAttribute( 'y1', this.start.y );
      definition.setAttribute( 'x2', this.end.x );
      definition.setAttribute( 'y2', this.end.y );
      if ( this.transformMatrix ) {
        definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );
      }
      
      _.each( this.stops, function( stop ) {
        var stopElement = document.createElementNS( scenery.svgns, 'stop' );
        stopElement.setAttribute( 'offset', stop.ratio );
        stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );
        definition.appendChild( stopElement );
      } );
      
      return definition;
    },
    
    toString: function() {
      var result = 'new scenery.LinearGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.end.x + ', ' + this.end.y + ' )';
      
      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
      } );
      
      return result;
    }
  } );
  
  return LinearGradient;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Live region is used with accessibility to read out changes in model state.
 * Should conform to the Axon property interface to make it easy to interchange.
 *
 * @author Sam Reid
 */

define( 'SCENERY/util/LiveRegion',['require','SCENERY/scenery'],function( require ) {
  

  var scenery = require( 'SCENERY/scenery' );

  var LiveRegion = scenery.LiveRegion = function LiveRegion( instance, property, options ) {
    var liveRegion = this;
    this.property = property;
    options = options || {};

    //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.
    //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40
    options.tabIndex = options.tabIndex || 1;

    // TODO: if element is a DOM element, verify that no other accessibility liveRegion is using it! (add a flag, and remove on disposal)
//    this.element = '<div role="region" id="bird-info" aria-live="polite">';
    this.element = document.createElement( 'div' );
    this.element.setAttribute( 'aria-live', 'polite' );
    this.element.setAttribute( 'role', 'region' );
    this.textNode = document.createTextNode( '' );
    this.element.appendChild( this.textNode );

    //Just setting the text causes NVDA to read deltas, you have to replace the node to have it read the text
    this.listener = function( newText ) {
      liveRegion.element.removeChild( liveRegion.textNode );
      liveRegion.textNode = document.createTextNode( newText );
      liveRegion.element.appendChild( liveRegion.textNode );
    };
    property.link( this.listener );
  };

  LiveRegion.prototype = {
    constructor: scenery.LiveRegion,
    dispose: function() { this.property.unlink( this.listener ); }
  };

  return LiveRegion;
} );
// Copyright 2002-2013, University of Colorado

/**
 * An Instance of a Node in the expanded tree form.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Instance',['require','SCENERY/scenery','SCENERY/util/AccessibilityPeer','SCENERY/util/LiveRegion'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/AccessibilityPeer' );
  require( 'SCENERY/util/LiveRegion' );
  
  var accessibility = window.has && window.has( 'scenery.accessibility' );
  
  // layer should be null if the trail isn't to a painted node
  scenery.Instance = function Instance( trail, layer, parent ) {
    this.trail = trail; // trail may be assumed to be stale, for performance reasons
    this.layer = layer;
    this.oldLayer = layer; // used during stitching
    
    // assertion not enabled, since at the start we don't specify a layer (it will be constructed later)
    // assert && assert( trail.lastNode().isPainted() === ( layer !== null ), 'Has a layer iff is painted' );
    
    // TODO: SVG layer might want to put data (group/fragment) references here (indexed by layer ID)
    this.data = {};
    
    // TODO: ensure that we can track this? otherwise remove it for memory and speed
    this.parent = parent;
    this.children = [];
    
    this.peers = []; // list of AccessibilityPeer instances attached to this trail
    this.liveRegions = []; // list of LiveRegion instances attached to this trail
    
    // TODO: track these? should significantly accelerate subtree-changing operations
    this.startAffectedLayer = null;
    this.endAffectedLayer = null;
    
    trail.setImmutable(); // make sure our Trail doesn't change from under us
    
    if ( accessibility ) {
      this.addPeers();
      this.addLiveRegions();
    }
    
    phetAllocation && phetAllocation( 'Instance' );
  };
  var Instance = scenery.Instance;
  
  Instance.prototype = {
    constructor: Instance,
    
    getScene: function() {
      return this.trail.rootNode();
    },
    get scene() { return this.getScene(); },
    
    getNode: function() {
      return this.trail.lastNode();
    },
    get node() { return this.getNode(); },
    
    changeLayer: function( newLayer ) {
      // NOTE: DO NOT change _layerTrails somehow in this function. we don't make a defensive copy of that array during stitching!
      if ( newLayer !== this.layer ) {
        sceneryLayerLog && sceneryLayerLog( 'changing instance ' + this.trail.toString() + ' to layer ' + ( newLayer ? '#' + newLayer.id : 'null' ) );
        this.layer && ( this.layer._instanceCount -= 1 );
        this.layer = newLayer;
        this.layer && ( this.layer._instanceCount += 1 );
      }
    },
    
    updateLayer: function() {
      if ( this.layer !== this.oldLayer ) {
        // we may have stale indices
        this.reindex();
        
        if ( sceneryLayerLog ) {
          if ( this.oldLayer && this.layer ) {
            sceneryLayerLog( 'moving instance ' + this.trail.toString() + ' from layer #' + this.oldLayer.id + ' to layer #' + this.layer.id );
          } else if ( this.layer ) {
            sceneryLayerLog( 'adding instance ' + this.trail.toString() + ' to layer #' + this.layer.id );
          } else {
            sceneryLayerLog( 'remove instance ' + this.trail.toString() + ' from layer #' + this.oldLayer.id );
          }
        }
        if ( this.oldLayer ) {
          this.oldLayer.removeInstance( this );
        }
        if ( this.layer ) {
          this.layer.addInstance( this );
        }
        this.oldLayer = this.layer;
      }
    },
    
    createChild: function( childNode, index ) {
      var childTrail = this.trail.copy().addDescendant( childNode );
      var childInstance = new scenery.Instance( childTrail, null, this );
      sceneryLayerLog && sceneryLayerLog( 'Instance.createChild: ' + childInstance.toString() );
      this.insertInstance( index, childInstance );
      childInstance.getNode().addInstance( childInstance );
      
      return childInstance;
    },
    
    addInstance: function( instance ) {
      assert && assert( instance, 'Instance.addInstance cannot have falsy parameter' );
      this.children.push( instance );
    },
    
    insertInstance: function( index, instance ) {
      assert && assert( instance, 'Instance.insert cannot have falsy instance parameter' );
      assert && assert( index >= 0 && index <= this.children.length, 'Instance.insert has bad index ' + index + ' for length ' + this.children.length );
      this.children.splice( index, 0, instance );
    },
    
    removeInstance: function( index ) {
      assert && assert( typeof index === 'number' );
      this.children.splice( index, 1 );
    },
    
    reindex: function() {
      this.trail.reindex();
    },
    
    // TODO: rename, so that it indicates that it removes the instance from the node
    dispose: function() {
      if ( this.layer ) {
        this.changeLayer( null );
        this.updateLayer();
      }
      this.parent = null;
      this.children.length = 0;
      this.getNode().removeInstance( this );
      
      if ( accessibility ) {
        this.removePeers();
        this.removeLiveRegions();
      }
    },
    
    equals: function( other ) {
      assert && assert( ( this === other ) === this.trail.equals( other.trail ), 'We assume a 1-1 mapping from trails to instances' );
      return this === other;
    },
    
    // standard -1,0,1 comparison with another instance, as a total ordering from the render order
    compare: function( other ) {
      return this.trail.compare( other.trail );
    },
    
    getLayerString: function() {
      return this.layer ? ( this.layer.getName() + '#' + this.layer.getId() ) : '-';
    },
    
    getTrailString: function() {
      return this.trail.toString();
    },
    
    toString: function() {
      return '{' + this.getTrailString() + ', ' + this.getLayerString() + '}';
    },
    
    getAffectedLayers: function() {
      // TODO: optimize this using pre-recorded versions?
      this.reindex();
      return this.getScene().affectedLayers( this.trail );
    },
    
    addPeers: function() {
      var node = this.getNode();
      var scene = this.getScene();
      
      var len = node._peers.length;
      if ( len ) {
        for ( var i = 0; i < len; i++ ) {
          var desc = node._peers[i];
          var peer = new scenery.AccessibilityPeer( this, desc.element, desc.options );
          scene.addPeer( peer );
          this.peers.push( peer );
        }
      }
    },
    
    removePeers: function() {
      var scene = this.getScene();
      
      var i = this.peers.length;
      while ( i-- ) {
        var peer = this.peers[i];
        scene.removePeer( peer );
        peer.dispose();
      }
      
      this.peers.length = 0; // clear this.peers
    },

    addLiveRegions: function() {
      var thisInstance = this;
      var node = this.getNode();
      var scene = this.getScene();

      if ( node._liveRegions.length ) {
        _.each( node._liveRegions, function( item ) {
          var liveRegion = new scenery.LiveRegion( thisInstance, item.property, item.options );
          scene.addLiveRegion( liveRegion );
          thisInstance.liveRegions.push( liveRegion );
        } );
      }
    },

    removeLiveRegions: function() {
      var scene = this.getScene();

      _.each( this.liveRegions, function( liveRegion ) {
        scene.removeLiveRegion( liveRegion );
        liveRegion.dispose();
      } );
      
      this.peers.length = 0; // clear this.peers
    },
    
    /*---------------------------------------------------------------------------*
    * Events from the Node
    *----------------------------------------------------------------------------*/
    
    notifyVisibilityChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyVisibilityChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyVisibilityChange( this );
      }
    },
    
    notifyOpacityChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyOpacityChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyOpacityChange( this );
      }
    },
    
    notifyClipChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyClipChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyClipChange( this );
      }
    },
    
    notifyBeforeSelfChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyBeforeSelfChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      // TODO: Canvas will only need to be notified of these once in-between scene updates
      // TODO: walk up the "tree" to see if any ancestors did this (in which case we don't need to)
      // e.g. this.oldPaint = true, etc.
      this.layer.notifyBeforeSelfChange( this );
    },
    
    notifyBeforeSubtreeChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyBeforeSubtreeChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyBeforeSubtreeChange( this );
      }
    },
    
    notifyDirtySelfPaint: function() {
      sceneryEventLog && sceneryEventLog( 'notifyDirtySelfPaint: ' + this.trail.toString() + ', ' + this.getLayerString() );
      assert && assert( this.getNode().isPainted(), 'Instance needs to be painted for notifyDirtySelfPaint' );
      this.layer.notifyDirtySelfPaint( this );
    },
    
    // TODO: consider special post-transform type?
    notifyDirtySubtreePaint: function() {
      sceneryEventLog && sceneryEventLog( 'notifyDirtySubtreePaint: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyDirtySubtreePaint( this );
      }
    },
    
    notifyDirtySubtreeBounds: function() {
      sceneryEventLog && sceneryEventLog( 'notifyDirtySubtreeBounds: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyDirtySubtreeBounds( this );
      }
    },
    
    notifyTransformChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyTransformChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      
      var affectedLayers = this.getAffectedLayers();
      var i = affectedLayers.length;
      while ( i-- ) {
        affectedLayers[i].notifyTransformChange( this );
      }
    },
    
    notifyBoundsAccuracyChange: function() {
      sceneryEventLog && sceneryEventLog( 'notifyBoundsAccuracyChange: ' + this.trail.toString() + ', ' + this.getLayerString() );
      this.layer.notifyBoundsAccuracyChange( this );
    },
    
    notifyStitch: function( match ) {
      sceneryEventLog && sceneryEventLog( 'notifyStitch: ' + this.trail.toString() + ' match:' + match + ', ' + this.getLayerString() );
      this.getScene().stitch( match );
    },
    
    markForLayerRefresh: function() {
      sceneryEventLog && sceneryEventLog( 'markForLayerRefresh: ' + this.trail.toString() + ', ' + this.getLayerString() );
      this.getScene().markSceneForLayerRefresh( this );
    },
    
    markForInsertion: function( child, index ) {
      sceneryEventLog && sceneryEventLog( 'markForInsertion: ' + this.trail.toString() + ' child:' + child.id + ', index: ' + index + ', ' + this.getLayerString() );
      
      this.reindex();
      this.getScene().markSceneForInsertion( this, child, index );
    },
    
    markForRemoval: function( child, index ) {
      sceneryEventLog && sceneryEventLog( 'markForRemoval: ' + this.trail.toString() + ' child:' + child.id + ', index: ' + index + ', ' + this.getLayerString() );
      
      this.reindex();
      this.getScene().markSceneForRemoval( this, child, index );
    }
  };
  
  return Instance;
} );



// Copyright 2002-2013, University of Colorado

/**
 * A pattern that will deliver a fill or stroke that will repeat an image in both directions (x and y).
 *
 * TODO: future support for repeat-x, repeat-y or no-repeat (needs SVG support)
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/Pattern',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  // TODO: support scene or other various content (SVG is flexible, can backport to canvas)
  // TODO: investigate options to support repeat-x, repeat-y or no-repeat in SVG (available repeat options from Canvas)
  scenery.Pattern = function Pattern( image ) {
    this.image = image;
    
    // use the global scratch canvas instead of creating a new Canvas
    this.canvasPattern = scenery.scratchContext.createPattern( image, 'repeat' );
    
    this.transformMatrix = null;
  };
  var Pattern = scenery.Pattern;
  
  Pattern.prototype = {
    constructor: Pattern,
    
    isPattern: true,
    
    setTransformMatrix: function( transformMatrix ) {
      this.transformMatrix = transformMatrix;
      return this;
    },
    
    getCanvasStyle: function() {
      return this.canvasPattern;
    },
    
    getSVGDefinition: function( id ) {
      var definition = document.createElementNS( scenery.svgns, 'pattern' );
      definition.setAttribute( 'id', id );
      definition.setAttribute( 'patternUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
      definition.setAttribute( 'patternContentUnits', 'userSpaceOnUse' ); // TODO: is this needed?
      definition.setAttribute( 'x', 0 );
      definition.setAttribute( 'y', 0 );
      definition.setAttribute( 'width', this.image.width );
      definition.setAttribute( 'height', this.image.height );
      if ( this.transformMatrix ) {
        definition.setAttribute( 'patternTransform', this.transformMatrix.getSVGTransform() );
      }
      
      definition.appendChild( scenery.Image.createSVGImage( this.image.src, this.image.width, this.image.height ) );
      
      return definition;
    },
    
    toString: function() {
      return 'new scenery.Pattern( $( \'<img src="' + this.image.src + '"/>\' )[0] )';
    }
  };
  
  return Pattern;
} );

// Copyright 2002-2013, University of Colorado

/**
 * A radial gradient that can be passed into the 'fill' or 'stroke' parameters.
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/RadialGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Gradient = require( 'SCENERY/util/Gradient' );
  
  // TODO: support Vector2s for p0 and p1
  scenery.RadialGradient = function RadialGradient( x0, y0, r0, x1, y1, r1 ) {
    this.start = new Vector2( x0, y0 );
    this.end = new Vector2( x1, y1 );
    this.startRadius = r0;
    this.endRadius = r1;
    
    // linear function from radius to point on the line from start to end
    this.focalPoint = this.start.plus( this.end.minus( this.start ).times( this.startRadius / ( this.startRadius - this.endRadius ) ) );
    
    // make sure that the focal point is in both circles. SVG doesn't support rendering outside of them
    if ( this.startRadius >= this.endRadius ) {
      assert && assert( this.focalPoint.minus( this.start ).magnitude() <= this.startRadius );
    } else {
      assert && assert( this.focalPoint.minus( this.end ).magnitude() <= this.endRadius );
    }
    
    // use the global scratch canvas instead of creating a new Canvas
    Gradient.call( this, scenery.scratchContext.createRadialGradient( x0, y0, r0, x1, y1, r1 ) );
  };
  var RadialGradient = scenery.RadialGradient;
  
  inherit( Gradient, RadialGradient, {
    
    isRadialGradient: true,
    
    getSVGDefinition: function( id ) {
      var startIsLarger = this.startRadius > this.endRadius;
      var largePoint = startIsLarger ? this.start : this.end;
      var maxRadius = Math.max( this.startRadius, this.endRadius );
      var minRadius = Math.min( this.startRadius, this.endRadius );
      
      var definition = document.createElementNS( scenery.svgns, 'radialGradient' );
      
      // TODO:
      definition.setAttribute( 'id', id );
      definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient
      definition.setAttribute( 'cx', largePoint.x );
      definition.setAttribute( 'cy', largePoint.y );
      definition.setAttribute( 'r', maxRadius );
      definition.setAttribute( 'fx', this.focalPoint.x );
      definition.setAttribute( 'fy', this.focalPoint.y );
      if ( this.transformMatrix ) {
        definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );
      }

      //TODO: replace with dot.Util.linear
      // maps x linearly from [a0,b0] => [a1,b1]
      function linearMap( a0, b0, a1, b1, x ) {
        return a1 + ( x - a0 ) * ( b1 - a1 ) / ( b0 - a0 );
      }
      
      function applyStop( stop ) {
        // flip the stops if the start has a larger radius
        var ratio = startIsLarger ? 1 - stop.ratio : stop.ratio;
        
        // scale the stops properly if the smaller radius isn't 0
        if ( minRadius > 0 ) {
          // scales our ratio from [0,1] => [minRadius/maxRadius,0]
          ratio = linearMap( 0, 1, minRadius / maxRadius, 1, ratio );
        }
        
        // TODO: store color in our stops array, so we don't have to create additional objects every time?
        var stopElement = document.createElementNS( scenery.svgns, 'stop' );
        stopElement.setAttribute( 'offset', ratio );
        stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );
        definition.appendChild( stopElement );
      }
      
      var i;
      // switch the direction we apply stops in, so that the ratios always are increasing.
      if ( startIsLarger ) {
        for ( i = this.stops.length - 1; i >= 0; i-- ) {
          applyStop( this.stops[i] );
        }
      } else {
        for ( i = 0; i < this.stops.length; i++ ) {
          applyStop( this.stops[i] );
        }
      }
      
      return definition;
    },
    
    toString: function() {
      var result = 'new scenery.RadialGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.startRadius + ', ' + this.end.x + ', ' + this.end.y + ', ' + this.endRadius + ' )';
      
      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
      } );
      
      return result;
    }
  } );
  
  return RadialGradient;
} );

// Copyright 2002-2013, University of Colorado

/**
 * An interval between two Trails. A trail being null means either 'from the start' or 'to the end', depending
 * on whether it is the first or second parameter to the constructor.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/RenderInterval',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  
  // start and end are of type {Trail} or null (indicates all the way to the start / end)
  scenery.RenderInterval = function RenderInterval( start, end ) {
    assert && assert( !start || !end || start.compare( end ) <= 0, 'RenderInterval parameters must not be out of order' );
    
    this.start = start;
    this.end = end;
  };
  var RenderInterval = scenery.RenderInterval;
  
  // assumes the intervals are disjoint, so we can just compare the start instance
  RenderInterval.compareDisjoint = function( x, y ) {
    // if they are both falsy, they should be the same
    if ( !x.start && !y.start ) { return 0; }
    
    // otherwise, since we are comparing the starts, null would signify 'before anything'
    if ( !x.start || !y.start ) { return x.start ? 1 : -1; }
    
    // otherwise our standard comparison
    return x.start.compare( y.start );
  };
  
  RenderInterval.prototype = {
    constructor: RenderInterval,
    
    reindex: function() {
      this.start && this.start.reindex();
      this.end && this.end.reindex();
    },
    
    isValidExclusive: function() {
      // like construction, but with strict inequality
      return !this.start || !this.end || this.start.compare( this.end ) < 0;
    },
    
    /*
     * Whether the union of this and the specified interval doesn't include any additional trails, when
     * both are treated as exclusive endpoints (exclusive between a and b). We also make the assumption
     * that a !== b || a === null for either interval, since otherwise it is not well defined.
     */
    exclusiveUnionable: function( interval ) {
      assert && assert ( this.isValidExclusive(), 'exclusiveUnionable requires exclusive intervals' );
      assert && assert ( interval.isValidExclusive(), 'exclusiveUnionable requires exclusive intervals' );
      return ( !this.start || !interval.end || this.start.compare( interval.end ) === -1 ) &&
             ( !this.end || !interval.start || this.end.compare( interval.start ) === 1 );
    },
    
    exclusiveContains: function( trail ) {
      assert && assert( trail );
      return ( !this.start || this.start.compare( trail ) < 0 ) && ( !this.end || this.end.compare( trail ) > 0 );
    },
    
    union: function( interval ) {
      // falsy checks since if a or b is null, we want that bound to be null
      var thisA = ( !this.start || ( interval.start && this.start.compare( interval.start ) === -1 ) );
      var thisB = ( !this.end || ( interval.end && this.end.compare( interval.end ) === 1 ) );
      
      return new RenderInterval(
        thisA ? this.start : interval.start,
        thisB ? this.end : interval.end
      );
    },
    
    toString: function() {
      return '[' + ( this.start ? this.start.toString() : this.start ) + ',' + ( this.end ? this.end.toString() : this.end ) + ']';
    }
  };
  
  return RenderInterval;
} );



// Copyright 2002-2013, University of Colorado

/*
 * An HTMLImageElement that is backed by a scene. Call update() on this SceneImage to update the image from the scene.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/SceneImage',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  // NOTE: ideally the scene shouldn't use SVG, since rendering that to a canvas takes a callback (and usually requires canvg)
  scenery.SceneImage = function SceneImage( scene ) {
    this.scene = scene;
    
    // we write the scene to a canvas, get its data URL, and pass that to the image.
    this.canvas = document.createElement( 'canvas' );
    this.context = this.canvas.getContext( '2d' );
    
    this.img = document.createElement( 'img' );
    this.update();
  };
  var SceneImage = scenery.SceneImage;
  
  SceneImage.prototype = {
    constructor: SceneImage,
    
    // NOTE: calling this before the previous update() completes may cause the previous onComplete to not be executed
    update: function( onComplete ) {
      var self = this;
      
      this.scene.updateScene();
      
      this.canvas.width = this.scene.getSceneWidth();
      this.canvas.height = this.scene.getSceneHeight();
      
      this.scene.renderToCanvas( this.canvas, this.context, function() {
        var url = self.toDataURL();
        
        self.img.onload = function() {
          onComplete();
          delete self.img.onload;
        };
        self.img.src = url;
      } );
    }
  };
  
  return SceneImage;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Creates and references a stylesheet that can be built up while Scenery is loading.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/SceneryStyle',['require','SCENERY/scenery'],function( require ) {
  
  
  require( 'SCENERY/scenery' );
  
  var styleElement = document.createElement( 'style' );
  styleElement.type = 'text/css';
  document.head.appendChild( styleElement );
  
  var stylesheet = document.styleSheets[document.styleSheets.length-1];
  assert && assert( stylesheet.disabled === false );
  assert && assert( stylesheet.cssRules.length === 0 );
  
  return {
    stylesheet: stylesheet,
    styleElement: styleElement,
    
    addRule: function( ruleString ) {
      // using a this reference so it doesn't need to be a closure
      this.stylesheet.insertRule( ruleString, 0 );
    }
  };
} );

// Copyright 2002-2013, University of Colorado

/**
 * General utility functions for WebGL
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/gl/GLUtil',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  var GLUtil = scenery.GLUtil = {
    getWebGLContext: function( canvas ) {
      var gl = null;
      var contextNames = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
      for ( var i = 0; i < contextNames.length; i++ ) {
        try {
          gl = canvas.getContext( contextNames[i] );
        } catch ( e ) {
          // consider storing this failure somewhere?
        }
        if ( gl ) {
          break;
        }
      }
      
      return gl;
    }
  };
  
  return GLUtil;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Shader wrapper, so we can seamlessly recreate them on context loss.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/gl/GLShader',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  var GLShader = scenery.GLShader = function GLShader( gl, src, type ) {
    this._src = src;
    this._type = type;
    this._shader = GLShader.compileShader( gl, src, type );
  };
  
  GLShader.fragmentShader = function( gl, src ) {
    return new GLShader( gl, src, gl.FRAGMENT_SHADER );
  };
  
  GLShader.vertexShader = function( gl, src ) {
    return new GLShader( gl, src, gl.VERTEX_SHADER );
  };
  
  GLShader.compileShader = function( gl, src, type ) {
    var shader = gl.createShader( type );
    gl.shaderSource( shader, src );
    gl.compileShader( shader );
    
    if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
      throw new Error( gl.getShaderInfoLog( shader ) );
    }
    return shader;
  };
  
  return GLShader;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Shader program wrapper, so we can seamlessly recreate them on context loss.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/util/gl/GLShaderProgram',['require','SCENERY/scenery'],function( require ) {
  
  
  var scenery = require( 'SCENERY/scenery' );
  
  /*
   * @param gl {WebGLRenderingContext}
   * @param shaders {Array[GLShader]}
   */
  var GLShaderProgram = scenery.GLShaderProgram = function GLShaderProgram( gl, shaders, attributes, uniforms ) {
    var that = this;
    
    this._shaders = shaders;
    this._shaderProgram = GLShaderProgram.createProgram( gl, shaders );
    this._attributes = attributes;
    this._uniforms = uniforms;
    
    gl.useProgram( this._shaderProgram );
    
    _.each( attributes, function( attribute ) {
      var location = gl.getAttribLocation( that._shaderProgram, attribute );
      that[attribute] = location;
      gl.enableVertexAttribArray( location ); // TODO: what about where we don't always want them defined?
    } );
    
    _.each( uniforms, function( uniform ) {
      that[uniform] = gl.getUniformLocation( that._shaderProgram, uniform );
    } );
  };
  
  GLShaderProgram.prototype = {
    constructor: GLShaderProgram,
    
    use: function( gl ) {
      gl.useProgram( this._shaderProgram );
    }
  };
  
  GLShaderProgram.createProgram = function( gl, shaders ) {
    var shaderProgram = gl.createProgram();
    _.each( shaders, function( shader ) {
      gl.attachShader( shaderProgram, shader._shader );
    } );
    gl.linkProgram( shaderProgram );

    if ( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
      throw new Error( 'Could not initialise shaders' );
    }
    
    return shaderProgram;
  };
  
  return GLShaderProgram;
} );

// Copyright 2002-2013, University of Colorado Boulder

/**
 * Displays mouse and touch areas when they are customized. Expensive to display!
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/overlays/PointerAreaOverlay',['require','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  

  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  scenery.PointerAreaOverlay = function PointerAreaOverlay( scene ) {
    this.scene = scene;
    
    var svg = this.svg = document.createElementNS( scenery.svgns, 'svg' );
    svg.style.position = 'absolute';
    svg.className = 'mouseTouchAreaOverlay';
    svg.style.top = 0;
    svg.style.left = 0;
    svg.style['pointer-events'] = 'none';
    
    function resize( width, height ) {
      svg.setAttribute( 'width', width );
      svg.setAttribute( 'height', height );
      svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
    }
    scene.addEventListener( 'resize', function( args ) {
      resize( args.width, args.height );
    } );
    resize( scene.getSceneWidth(), scene.getSceneHeight() );
    
    scene.$main[0].appendChild( svg );
    
    scene.reindexLayers();
  };
  var PointerAreaOverlay = scenery.PointerAreaOverlay;

  PointerAreaOverlay.prototype = {
    dispose: function() {
      this.scene.$main[0].removeChild( this.svg );
    },

    reindex: function( index ) {
      this.svg.style.zIndex = index;
    },
    
    addShape: function( shape, color, isOffset ) {
      var path = document.createElementNS( scenery.svgns, 'path' );
      var svgPath = shape.getSVGPath();
      
      // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
      // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
      // the attribute can cause this bug
      if ( !svgPath ) { svgPath = 'M0 0'; }
      
      if ( svgPath ) {
        // only set the SVG path if it's not the empty string
        path.setAttribute( 'd', svgPath );
      } else if ( path.hasAttribute( 'd' ) ) {
        path.removeAttribute( 'd' );
      }
      
      path.setAttribute( 'style', 'fill: none; stroke: ' + color + '; stroke-dasharray: 5, 3; stroke-dashoffset: ' + ( isOffset ? 5 : 0 ) + '; stroke-width: 3;' );
      this.svg.appendChild( path );
    },
    
    update: function() {
      var that = this;
      var svg = this.svg;
      var scene = this.scene;
      
      while ( svg.childNodes.length ) {
        svg.removeChild( svg.childNodes[svg.childNodes.length-1] );
      }
      
      new scenery.Trail( scene ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          // skip this subtree if the node is invisible
          return true;
        }
        if ( ( node._mouseArea || node._touchArea ) && trail.isVisible() ) {
          var transform = trail.getTransform();
          
          if ( node._mouseArea ) {
            that.addShape( transform.transformShape( node._mouseArea.isBounds ? Shape.bounds( node._mouseArea ) : node._mouseArea ), 'rgba(0,0,255,0.8)', true );
          }
          if ( node._touchArea ) {
            that.addShape( transform.transformShape( node._touchArea.isBounds ? Shape.bounds( node._touchArea ) : node._touchArea ), 'rgba(255,0,0,0.8)', false );
          }
        }
      } );
    }
  };

  return PointerAreaOverlay;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Main scene, that is also a Node.
 *
 * TODO: documentation!
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'SCENERY/Scene',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','KITE/Shape','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Instance','SCENERY/util/Trail','SCENERY/util/RenderInterval','SCENERY/util/TrailPointer','SCENERY/input/Input','SCENERY/layers/LayerBuilder','SCENERY/layers/Renderer','SCENERY/overlays/PointerAreaOverlay','SCENERY/overlays/PointerOverlay','SCENERY/util/Util'],function( require ) {
  
  
  var inherit = require( 'PHET_CORE/inherit' );
  
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  
  var Shape = require( 'KITE/Shape' );
  
  var scenery = require( 'SCENERY/scenery' );
  
  var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node
  require( 'SCENERY/util/Instance' );
  require( 'SCENERY/util/Trail' );
  require( 'SCENERY/util/RenderInterval' );
  require( 'SCENERY/util/TrailPointer' );
  require( 'SCENERY/input/Input' );
  require( 'SCENERY/layers/LayerBuilder' );
  require( 'SCENERY/layers/Renderer' );
  require( 'SCENERY/overlays/PointerAreaOverlay' );
  require( 'SCENERY/overlays/PointerOverlay' );

  var Util = require( 'SCENERY/util/Util' );

  var accessibility = window.has && window.has( 'scenery.accessibility' );
  
  // debug flag to disable matching of layers when in 'match' mode
  var forceNewLayers = true; // DEBUG
  
  // constructs all sub-trees for the specified instance. used from markSceneForInsertion
  function buildInstances( instance ) {
    var node = instance.getNode();
    var len = node._children.length;
    for ( var i = 0; i < len; i++ ) {
      buildInstances( instance.createChild( node._children[i], i ) );
    }
  }
  
  /*
   * $main should be a block-level element with a defined width and height. scene.resize() should be called whenever
   * it is resized.
   *
   * Valid parameters in the parameter object:
   * {
   *   allowSceneOverflow: false,           // usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow
   *   allowCSSHacks: true,                 // applies styling that prevents mobile browser graphical issues
   *   allowDevicePixelRatioScaling: false, // allows underlying canvases (Canvas, WebGL) to increase in size to maintain sharpness on high-density displays
   *   enablePointerEvents: true,           // allows pointer events / MSPointerEvent to be used on supported platforms.
   *   preferredSceneLayerType: ...,        // sets the preferred type of layer to be created if there are multiple options
   *   width: <current main width>,         // override the main container's width
   *   height: <current main height>,       // override the main container's height
   * }
   */
  scenery.Scene = function Scene( $main, options ) {
    assert && assert( $main[0], 'A main container is required for a scene' );
    this.$main = $main;
    this.main = $main[0];
    
    // add a self reference to aid in debugging. this generally shouldn't lead to a memory leak
    this.main.scene = this;
    
    // add a reference to the API for debugging
    this.scenery = scenery;
    
    // defaults
    options = _.extend( {
      allowSceneOverflow: false,
      allowCSSHacks: true,
      allowDevicePixelRatioScaling: false,
      enablePointerEvents: true,
      preferredSceneLayerType: scenery.CanvasDefaultLayerType,
      width: $main.width(),
      height: $main.height()
    }, options || {} );
    
    // TODO: consider using a pushed preferred layer to indicate this information, instead of as a specific option
    this.backingScale = options.allowDevicePixelRatioScaling ? Util.backingScale( document.createElement( 'canvas' ).getContext( '2d' ) ) : 1;
    this.enablePointerEvents = options.enablePointerEvents;
    
    Node.call( this, options );

    var scene = this;
    window.debugScene = scene;
    
    // layering data
    this.layers = [];               // main layers in a scene
    this.layerChangeIntervals = []; // array of {RenderInterval}s indicating what parts need to be stitched together. cleared after each stitching
    
    this.lastCursor = null;
    this.defaultCursor = $main.css( 'cursor' );
    
    // resize the main container as a sanity check
    this.setSize( options.width, options.height );
    
    this.sceneBounds = new Bounds2( 0, 0, options.width, options.height );
    
    // set up the root instance for this scene
    // only do this after Node.call has been invoked, since Trail.addDescendant uses a few things
    this.rootInstance = new scenery.Instance( new scenery.Trail( this ), null, null );
    this.addInstance( this.rootInstance );
    
    // default to a canvas layer type, but this can be changed
    this.preferredSceneLayerType = options.preferredSceneLayerType;
    
    applyCSSHacks( $main, options );

    // TODO: Does this need to move to where inputEvents are hooked up so that it doesn't get run each time Node.toImage is called?
    if ( accessibility ) {
      this.activePeer = null;
      
      this.accessibilityLayer = document.createElement( 'div' );
      this.accessibilityLayer.className = "accessibility-layer";
      
      //Put the accessibility layer behind the background so it cannot be seen.  Change this to some high number like 9999 to show it for debugging purposes.
      this.accessibilityLayer.style.zIndex = -1;
      this.accessibilityLayer.style.position = 'relative';
      $main[0].appendChild( this.accessibilityLayer );
      
      this.focusRingSVGContainer = document.createElementNS( scenery.svgns, 'svg' );
      this.focusRingSVGContainer.style.position = 'absolute';
      this.focusRingSVGContainer.style.top = 0;
      this.focusRingSVGContainer.style.left = 0;
      this.focusRingSVGContainer.style['pointer-events'] = 'none';
      this.resizeFocusRingSVGContainer( options.width, options.height );
      this.focusRingPath = document.createElementNS( scenery.svgns, 'path' );
      this.focusRingPath.setAttribute( 'style', 'fill: none; stroke: blue; stroke-width: 5;' );
      this.focusRingPath.setAttribute( 'id', 'p1' );
      this.focusRingSVGContainer.appendChild( this.focusRingPath );
      $main[0].appendChild( this.focusRingSVGContainer );
      
      this.updateFocusRing = function() {
        // TODO: move into prototype definitions, this doesn't need to be private, and isn't a closure over anything in the constructor
        assert && assert( scene.activePeer, 'scene should have an active peer when changing the focus ring bounds' );
        scene.focusRingPath.setAttribute( 'd', Shape.bounds( scene.activePeer.getGlobalBounds() ).getSVGPath() );
      };

      //Put the live region layer behind the accessibility peer layer to make debugging easier (if we need to see the accessibility layer)
      this.liveRegionLayer = document.createElement( 'div' );
      this.liveRegionLayer.className = 'live-region-layer';
      this.liveRegionLayer.style.zIndex = -2;
      this.liveRegionLayer.style.position = 'relative';
      $main[0].appendChild( this.liveRegionLayer );
    }
  };
  var Scene = scenery.Scene;
  
  inherit( Node, Scene, {
    
    updateScene: function( args ) {
      // sceneryLayerLog && sceneryLayerLog( 'Scene: updateScene' );
      
      var scene = this;
      
      // check to see whether contents under pointers changed (and if so, send the enter/exit events) to maintain consistent state
      if ( this.input ) {
        sceneryEventLog && sceneryEventLog( 'validatePointers from updateScene' );
        this.input.validatePointers();
      }
      
      // validating bounds, similar to Piccolo2d
      this.validateBounds();
      this.validatePaint();
      
      // bail if there are no layers. consider a warning?
      if ( !this.layers.length ) {
        return;
      }
      
      var i = this.layers.length;
      while ( i-- ) {
        this.layers[i].render( scene, args );
      }
      
      this.updateCursor();
      
      if ( this.mouseTouchAreaOverlay ) {
        this.mouseTouchAreaOverlay.update();
      }
      
      // if ( this.accessibilityLayer ) {
  //      for ( var i = 0; i < accessibleNodes.length; i++ ) {
  //        if ( accessibleNodes[i]._element === activeElement ) {
  //          if ( accessibleNodes[i].origin ) {
  //            var b = accessibleNodes[i].origin.globalBounds;
  //            var rect = Shape.bounds( b );
  //
  //            //Animation is a bit buggy, but I left this code in in case we want to pick it up later.
  //            var animateTheRect = false;
  //            if ( animateTheRect ) {
  //              if ( !this.focusRingPath.lastSVGPath ) {
  //                this.focusRingPath.setAttribute( 'd', rect.getSVGPath() );
  //                this.focusRingPath.lastSVGPath = rect.getSVGPath();
  //              } else {
  //                var animate = document.createElementNS( scenery.svgns, 'animate' );
  //                animate.setAttribute( 'attributeType', 'XML' );
  //                animate.setAttribute( 'xlink:href', '#p1' );
  //                animate.setAttribute( 'attributeName', 'd' );
  //                animate.setAttribute( 'from', this.focusRingPath.lastSVGPath );
  //                animate.setAttribute( 'to', rect.getSVGPath() );
  //                animate.setAttribute( 'dur', '4s' );
  //
  //                $( this.focusRingPath ).empty();
  //                this.focusRingPath.appendChild( animate );
  //                this.focusRingPath.lastSVGPath = rect.getSVGPath();
  //              }
  //            } else {
  //              this.focusRingPath.setAttribute( 'd', rect.getSVGPath() );
  //            }
  //
  //            found = true;
  //          }
  //        }
  //        if ( !found ) {
  //          this.focusRingPath.removeAttribute( 'd' );
  //        }
  //      }
      // }
    },
    
    renderScene: function() {
      // TODO: for now, go with the same path. possibly add options later
      this.updateScene();
    },
    
    addPeer: function( peer ) {
      this.accessibilityLayer.appendChild( peer.peerElement );
    },
    
    removePeer: function( peer ) {
      this.accessibilityLayer.removeChild( peer.peerElement );
    },

    addLiveRegion: function( liveRegion ) {
      this.liveRegionLayer.appendChild( liveRegion.element );
    },

    removeLiveRegion: function( liveRegion ) {
      this.liveRegionLayer.removeChild( liveRegion.element );
    },
    
    setActivePeer: function( peer ) {
      if ( this.activePeer !== peer ) {

        //Remove bounds listener from old active peer
        if ( this.activePeer ) {
          this.activePeer.instance.node.removeEventListener( 'bounds', this.updateFocusRing );
        }
        
        this.activePeer = peer;
        
        if ( peer ) {
          this.activePeer.instance.node.addEventListener( 'bounds', this.updateFocusRing );
          this.updateFocusRing();
        } else {
          this.focusRingPath.setAttribute( 'd', "M 0 0" );
        }
      }
    },
    
    getActivePeer: function( peer ) {
      return this.activePeer;
    },
    
    focusPeer: function( peer ) {
      this.setActivePeer( peer );
    },
    
    blurPeer: function( peer ) {
      assert && assert( this.getActivePeer() === peer, 'Can only blur an active peer' );
      this.setActivePeer( null );
    },
    
    markInterval: function( affectedTrail ) {
      // TODO: maybe reindexing sooner is better? are we covering up a bug here?
      affectedTrail.reindex();
      
      // since this is marked while the child is still connected, we can use our normal trail handling.
      
      // find the closest before and after self trails that are not affected
      var beforeTrail = affectedTrail.previousPainted(); // easy for the before trail
      
      var afterTrailPointer = new scenery.TrailPointer( affectedTrail.copy(), false );
      while ( afterTrailPointer.hasTrail() && ( !afterTrailPointer.isBefore || !afterTrailPointer.trail.isPainted() ) ) {
        afterTrailPointer.nestedForwards();
      }
      var afterTrail = afterTrailPointer.trail;
      
      // sanity checks
      assert && assert( !beforeTrail || beforeTrail.areIndicesValid(), 'beforeTrail needs to be valid' );
      assert && assert( !afterTrail || afterTrail.areIndicesValid(), 'afterTrail needs to be valid' );
      assert && assert( !beforeTrail || !afterTrail || beforeTrail.compare( afterTrail ) !== 0, 'Marked interval needs to be exclusive' );
      
      // store the layer of the before/after trails so that it is easy to access later
      this.addLayerChangeInterval( new scenery.RenderInterval( beforeTrail, afterTrail ) );
    },
    
    // convenience function for layer change intervals
    addLayerChangeInterval: function( interval ) {
      if ( sceneryLayerLog ) {
        sceneryLayerLog( 'adding interval: ' + interval.toString() + ' to intervals:' );
        _.each( this.layerChangeIntervals, function( interval ) {
          sceneryLayerLog( '  ' + interval.toString() );
        } );
      }
      
      // TODO: replace with a binary-search-like version that may be faster. this includes a full scan
      
      // attempt to merge this interval with another if possible.
      for ( var i = 0; i < this.layerChangeIntervals.length; i++ ) {
        var other = this.layerChangeIntervals[i];
        other.reindex(); // sanity check, although for most use-cases this should be unnecessary
        
        if ( interval.exclusiveUnionable( other ) ) {
          // the interval can be unioned without including other nodes. do this, and remove the other interval from consideration
          interval = interval.union( other );
          this.layerChangeIntervals.splice( i--, 1 ); // decrement to stay at the same index
          sceneryLayerLog && sceneryLayerLog( 'removing interval: ' + other.toString() );
        }
      }
      
      this.layerChangeIntervals.push( interval );
      
      if ( sceneryLayerLog ) {
        sceneryLayerLog( 'new intervals: ' );
        _.each( this.layerChangeIntervals, function( interval ) {
          sceneryLayerLog( '  ' + interval.toString() );
        } );
        sceneryLayerLog( '---' );
      }
    },
    
    createLayer: function( layerType, layerArgs, startBoundary, endBoundary ) {
      var layer = layerType.createLayer( _.extend( {
        startBoundary: startBoundary,
        endBoundary: endBoundary
      }, layerArgs ) );
      layer.type = layerType;
      sceneryLayerLog && sceneryLayerLog( 'created layer: ' + layer.getId() + ' of type ' + layer.type.name );
      return layer;
    },
    
    // insert a layer into the proper place (from its starting boundary)
    insertLayer: function( layer ) {
      for ( var i = 0; i < this.layers.length; i++ ) {
        if ( layer.endPaintedTrail.isBefore( this.layers[i].startPaintedTrail ) ) {
          this.layers.splice( i, 0, layer ); // insert the layer here
          return;
        }
      }
      
      // it is after all other layers
      this.layers.push( layer );
    },
    
    getBoundaries: function() {
      // TODO: store these more efficiently!
      return [ this.layers[0].startBoundary ].concat( _.pluck( this.layers, 'endBoundary' ) );
    },
    
    calculateBoundaries: function( beforeLayerType, beforeTrail, afterTrail ) {
      sceneryLayerLog && sceneryLayerLog( 'build between ' + ( beforeTrail ? beforeTrail.toString() : beforeTrail ) + ',' + ( afterTrail ? afterTrail.toString() : afterTrail ) + ' with beforeType: ' + ( beforeLayerType ? beforeLayerType.name : null ) );
      var builder = new scenery.LayerBuilder( this, beforeLayerType, beforeTrail, afterTrail );
      
      // push the preferred layer type before we push that for any nodes
      if ( this.preferredSceneLayerType ) {
        builder.pushPreferredLayerType( this.preferredSceneLayerType );
      }
      
      builder.run();
      
      return builder.boundaries;
    },
    
    stitch: function( match ) {
      var scene = this;
      
      var i;
      
      sceneryLayerLog && sceneryLayerLog( '-----------------------------------\nbeginning stitch' );
      
      // bail out if there are no changes to stitch (stitch is called multiple times)
      if ( !this.layerChangeIntervals.length ) {
        return;
      }
      
      // data to be shared across all of the individually stitched intervals
      var stitchData = {
        // all instances that are affected, in no particular order (and may contain duplicates)
        affectedInstances: [],
        
        // fresh layers that should be added into the scene
        newLayers: []
      };
      
      // default arguments for constructing layers
      var layerArgs = {
        $main: this.$main,
        scene: this,
        baseNode: this
      };
      
      // reindex intervals, since their endpoints indices may need to be updated
      i = this.layerChangeIntervals.length;
      while ( i-- ) {
        this.layerChangeIntervals[i].reindex();
      }
      
      /*
       * Sort our intervals, so that when we need to 'unglue' a layer into two separate layers, we will have passed
       * all of the parts where we would need to use the 'before' layer, so we can update our layer map with the 'after'
       * layer.
       */
      this.layerChangeIntervals.sort( scenery.RenderInterval.compareDisjoint );
      
      sceneryLayerLog && sceneryLayerLog( 'stitching on intervals: \n' + this.layerChangeIntervals.join( '\n' ) );
      
      for ( i = 0; i < this.layerChangeIntervals.length; i++ ) {
        var interval = this.layerChangeIntervals[i];
        
        sceneryLayerLog && sceneryLayerLog( 'stitch on interval ' + interval.toString() );
        var beforeTrail = interval.start;
        var afterTrail = interval.end;
        
        var beforeInstance = beforeTrail ? beforeTrail.getInstance() : null;
        var afterInstance = afterTrail ? afterTrail.getInstance() : null;
        
        var beforeLayer = beforeInstance ? beforeInstance.layer : null;
        var afterLayer = afterInstance ? afterInstance.layer : null;
        
        // TODO: calculate boundaries based on the instances?
        var boundaries = this.calculateBoundaries( beforeLayer ? beforeLayer.type : null, beforeTrail, afterTrail );
        
        this.stitchInterval( stitchData, layerArgs, beforeTrail, afterTrail, beforeLayer, afterLayer, boundaries, match );
      }
      
      // clean up state that was set leading up to the stitching, and do it early so
      // if we do things later that cause side-effects we won't clear intervals that haven't been stitched
      this.layerChangeIntervals.length = 0;
      
      sceneryLayerLog && sceneryLayerLog( '------ finished intervals in stitching' );
      
      // reindex all of the relevant layer trails, and dispose/add as necessary
      i = this.layers.length;
      while ( i-- ) {
        var layer = this.layers[i];
        layer.startBoundary.reindex();
        layer.endBoundary.reindex(); // TODO: performance: this repeats some work, verify in layer audit that we are sharing boundaries properly, then only reindex end boundary on last layer
        
        // remove necessary layers. do this before adding layers, since insertLayer currently does not gracefully handle weird overlapping cases
        // layers with zero trails should be removed
        if ( layer._instanceCount === 0 ) {
          sceneryLayerLog && sceneryLayerLog( 'disposing layer: ' + layer.getId() );
          this.disposeLayer( layer );
        }
      }
      i = stitchData.newLayers.length;
      while ( i-- ) {
        var newLayer = stitchData.newLayers[i];
        newLayer.startBoundary.reindex();
        newLayer.endBoundary.reindex(); // TODO: performance: this repeats some work, verify in layer audit that we are sharing boundaries properly, then only reindex end boundary on last layer
        
        // add new layers. we do this before the add/remove trails, since those can trigger layer side effects
        assert && assert( newLayer._instanceCount, 'ensure we are not adding empty layers' );
        
        sceneryLayerLog && sceneryLayerLog( 'inserting layer: ' + newLayer.getId() );
        scene.insertLayer( newLayer );
      }
      
      // set the layers' elements' z-indices, and reindex their trails so they are in a consistent state
      // TODO: performance: don't reindex layers if no layers were added or removed?
      this.reindexLayers();
      
      sceneryLayerLog && sceneryLayerLog( '------ updating layer references' );
      
      // add/remove trails from their necessary layers
      var affectedLen = stitchData.affectedInstances.length;
      for ( i = 0; i < affectedLen; i++ ) {
        stitchData.affectedInstances[i].updateLayer();
      }
      
      assertSlow && assertSlow( this.layerAudit() );
      
      sceneryLayerLog && sceneryLayerLog( 'finished stitch\n-----------------------------------' );
    },
    
    /*
     * Stitching intervals has essentially two specific modes:
     * non-matching: handles added or removed nodes (and this can span multiple, even adjacent trails)
     * matching: handles in-place layer refreshes (no nodes removed or added, but something like a renderer was changed)
     *
     * This separation occurs since for matching, we want to match old layers with possible new layers, so we can keep trails in their
     * current layer instead of creating an identical layer and moving the trails to that layer.
     *
     * The stitching basically re-does the layering between a start and end trail, attempting to minimize the amount of changes made.
     * It can include 'gluing' layers together (a node that caused layer splits was removed, and before/after layers are joined),
     * 'ungluing' layers (an inserted node causes a layer split in an existing layer, and it is separated into a before/after),
     * or normal updating of the interior.
     *
     * The beforeTrail and afterTrail should be outside the modifications, and if the modifications are to the start/end of the graph,
     * they should be passed as null to indicate 'before everything' and 'after everything' respectively.
     *
     * Here be dragons!
     */
    stitchInterval: function( stitchData, layerArgs, beforeTrail, afterTrail, beforeLayer, afterLayer, boundaries, match ) {
      var scene = this;
      
      // make sure our beforeTrail and afterTrail are immutable
      beforeTrail && beforeTrail.setImmutable();
      afterTrail && afterTrail.setImmutable();
      
      // need a reference to this, since it may change
      var afterLayerEndBoundary = afterLayer ? afterLayer.endBoundary : null;
      
      var beforePointer = beforeTrail ? new scenery.TrailPointer( beforeTrail, true ) : new scenery.TrailPointer( new scenery.Trail( this ), true );
      var afterPointer = afterTrail ? new scenery.TrailPointer( afterTrail, true ) : new scenery.TrailPointer( new scenery.Trail( this ), false );
      
      sceneryLayerLog && sceneryLayerLog( '\nstitching with boundaries:\n' + _.map( boundaries, function( boundary ) { return boundary.toString(); } ).join( '\n' ) );
      sceneryLayerLog && sceneryLayerLog( '               layers: ' + ( beforeLayer ? beforeLayer.getId() : '-' ) + ' to ' + ( afterLayer ? afterLayer.getId() : '-' ) );
      sceneryLayerLog && sceneryLayerLog( '               trails: ' + ( beforeTrail ? beforeTrail.toString() : '-' ) + ' to ' + ( afterTrail ? afterTrail.toString() : '-' ) );
      sceneryLayerLog && sceneryLayerLog( '               match: ' + match );
      
      /*---------------------------------------------------------------------------*
      * State
      *----------------------------------------------------------------------------*/
      
      var nextBoundaryIndex = 0;
      var nextBoundary = boundaries[nextBoundaryIndex];
      var instancesToAddToLayer = [];
      var currentTrail = beforeTrail;
      var currentLayer = beforeLayer;
      var currentLayerType = beforeLayer ? beforeLayer.type : null;
      var currentStartBoundary = null;
      var matchingLayer = null; // set whenever a trail has a matching layer, cleared after boundary
      
      function addPendingTrailsToLayer() {
        // add the necessary nodes to the layer
        var len = instancesToAddToLayer.length;
        for ( var i = 0; i < len; i++ ) {
          var instance = instancesToAddToLayer[i];
          instance.changeLayer( currentLayer );
          stitchData.affectedInstances.push( instance );
        }
        instancesToAddToLayer.length = 0;
      }
      
      function addAndCreateLayer( startBoundary, endBoundary ) {
        currentLayer = scene.createLayer( currentLayerType, layerArgs, startBoundary, endBoundary );
        stitchData.newLayers.push( currentLayer );
      }
      
      function step( trail, isEnd ) {
        sceneryLayerLog && sceneryLayerLog( 'step: ' + ( trail ? trail.toString() : trail ) );
        trail && trail.setImmutable(); // we don't want our trail to be modified, so we can store direct references to it
        // check for a boundary at this step between currentTrail and trail
        
        // if there is no next boundary, don't bother checking anyways
        if ( nextBoundary && nextBoundary.equivalentPreviousTrail( currentTrail ) ) { // at least one null check
          assert && assert( nextBoundary.equivalentNextTrail( trail ) );
          
          sceneryLayerLog && sceneryLayerLog( nextBoundary.toString() );
          
          // we are at a boundary change. verify that we are at the end of a layer
          if ( currentLayer || currentStartBoundary ) {
            if ( currentLayer ) {
              sceneryLayerLog && sceneryLayerLog( 'has currentLayer: ' + currentLayer.getId() );
              // existing layer, reposition its endpoint
              currentLayer.setEndBoundary( nextBoundary );
            } else {
              assert && assert( currentStartBoundary );
              
              if ( matchingLayer ) {
                sceneryLayerLog && sceneryLayerLog( 'matching layer used: ' + matchingLayer.getId() );
                matchingLayer.setStartBoundary( currentStartBoundary );
                matchingLayer.setEndBoundary( nextBoundary );
                currentLayer = matchingLayer;
              } else {
                sceneryLayerLog && sceneryLayerLog( 'creating layer' );
                addAndCreateLayer( currentStartBoundary, nextBoundary ); // sets currentLayer
              }
            }
            // sanity checks
            assert && assert( currentLayer.startPaintedTrail );
            assert && assert( currentLayer.endPaintedTrail );
            
            addPendingTrailsToLayer();
          } else {
            // if not at the end of a layer, sanity check that we should have no accumulated pending trails
            sceneryLayerLog && sceneryLayerLog( 'was first layer' );
            assert && assert( instancesToAddToLayer.length === 0 );
          }
          currentLayer = null;
          currentLayerType = nextBoundary.nextLayerType;
          currentStartBoundary = nextBoundary;
          matchingLayer = null;
          nextBoundaryIndex++;
          nextBoundary = boundaries[nextBoundaryIndex];
        }
        if ( trail && !isEnd ) {
          // TODO: performance: handle instances natively, don't just convert here
          instancesToAddToLayer.push( trail.getInstance() );
        }
        if ( match && !isEnd ) { // TODO: verify this condition with test cases
          // if the node's old layer is compatible
          // TODO: performance: don't use getInstance() here, use instances natively
          var layer = trail.getInstance().layer; // lookup should return the old layer from the system
          if ( layer.type === currentLayerType && !forceNewLayers ) {
            // TODO: we need to handle compatibility with layer splits. using forceNewLayers flag to temporarily disable
            matchingLayer = layer;
          }
        }
        currentTrail = trail;
      }
      
      function startStep( trail ) {
        sceneryLayerLog && sceneryLayerLog( 'startStep: ' + ( trail ? trail.toString() : trail ) );
      }
      
      function middleStep( trail ) {
        sceneryLayerLog && sceneryLayerLog( 'middleStep: ' + trail.toString() );
        step( trail, false );
      }
      
      function endStep( trail ) {
        sceneryLayerLog && sceneryLayerLog( 'endStep: ' + ( trail ? trail.toString() : trail ) );
        step( trail, true );
        
        if ( beforeLayer !== afterLayer && boundaries.length === 0 ) {
          // glue the layers together
          sceneryLayerLog && sceneryLayerLog( 'gluing layer' );
          sceneryLayerLog && sceneryLayerLog( 'endBoundary: ' + afterLayer.endBoundary.toString() );
          beforeLayer.setEndBoundary( afterLayer.endBoundary );
          currentLayer = beforeLayer;
          addPendingTrailsToLayer();
          
          // move over all of afterLayer's trails to beforeLayer
          var len = afterLayer._layerTrails.length;
          for ( var i = 0; i < len; i++ ) {
            var endTrail = afterLayer._layerTrails[i];
            
            endTrail.reindex();
            var instance = endTrail.getInstance();
            instance.changeLayer( beforeLayer ); // TODO: performance: handle instances natively
            stitchData.affectedInstances.push( instance );
          }
          
        } else if ( beforeLayer && beforeLayer === afterLayer && boundaries.length > 0 ) {
          // need to 'unglue' and split the layer
          sceneryLayerLog && sceneryLayerLog( 'ungluing layer' );
          assert && assert( currentStartBoundary );
          addAndCreateLayer( currentStartBoundary, afterLayerEndBoundary ); // sets currentLayer
          addPendingTrailsToLayer();
          
          currentLayer.endPaintedTrail.reindex(); // currentLayer's trails may be stale at this point
          scenery.Trail.eachPaintedTrailBetween( afterTrail, currentLayer.endPaintedTrail, function( subtrail ) {
            var instance = subtrail.getInstance();
            instance.changeLayer( currentLayer );
            stitchData.affectedInstances.push( instance );
          }, false, scene );
        } else if ( !beforeLayer && !afterLayer && boundaries.length === 1 && !boundaries[0].hasNext() && !boundaries[0].hasPrevious() ) {
          // TODO: why are we generating a boundary here?!?
        } else {
          currentLayer = afterLayer;
          // TODO: check concepts on this guard, since it seems sketchy
          if ( currentLayer && currentStartBoundary ) {
            currentLayer.setStartBoundary( currentStartBoundary );
          }
          
          addPendingTrailsToLayer();
        }
      }
      
      // iterate from beforeTrail up to BEFORE the afterTrail. does not include afterTrail
      startStep( beforeTrail );
      beforePointer.eachTrailBetween( afterPointer, function( trail ) {
        // ignore non-self trails
        if ( !trail.isPainted() || ( beforeTrail && trail.equals( beforeTrail ) ) ) {
          return;
        }
        
        middleStep( trail.copy() );
      } );
      endStep( afterTrail );
    },
    
    rebuildLayers: function() {
      sceneryLayerLog && sceneryLayerLog( 'Scene: rebuildLayers' );
      
      // mark the entire scene 
      this.markInterval( new scenery.Trail( this ) );
      
      // then stitch with match=true
      this.stitch( true );
    },
    
    // after layer changes, the layers should have their zIndex updated, and updates their trails
    reindexLayers: function() {
      sceneryLayerLog && sceneryLayerLog( 'Scene: reindexLayers' );
      
      var index = 1; // don't start below 1
      if ( accessibility && this.accessibiltyLayer ) {
        this.accessibilityLayer.style.zIndex = 9999; // TODO: a better way than 9999, SR says probably unnecessary
        index++;
      }
      
      var len = this.layers.length;
      for ( var i = 0; i < len; i++ ) {
        index = this.layers[i].reindex( index );
      }
      
      if ( accessibility ) {
        if ( this.focusRingSVGContainer ) {
          this.focusRingSVGContainer.style.zIndex = index++;
        }
      }
      
      if ( this.mouseTouchAreaOverlay ){
        this.mouseTouchAreaOverlay.reindex( index++ );
      }
      
      if ( this.pointerOverlay ){
        this.pointerOverlay.reindex( index++ );
      }
    },
    
    dispose: function() {
      this.disposeLayers();
      if ( this.input ) {
        this.input.disposeListeners();
      }
      
      // remove self reference from the container
      delete this.main.scene;
      
      // TODO: clear event handlers if added
      //throw new Error( 'unimplemented dispose: clear event handlers if added' );
    },
    
    disposeLayer: function( layer ) {
      // NOTE: stitching relies on this not changing this.layers except for removing the specific layer
      layer.dispose();
      this.layers.splice( _.indexOf( this.layers, layer ), 1 ); // TODO: better removal code!
    },
    
    disposeLayers: function() {
      var i = this.layers.length;
      while ( i-- ) {
        this.disposeLayer( this.layers[i] );
      }
    },
    
    // all layers whose start or end points lie inclusively in the range from the trail's before and after
    affectedLayers: function( trail ) {
      // midpoint search and result depends on the order of layers being in render order (bottom to top)
      
      assert && assert( !( trail.isEmpty() || trail.nodes[0] !== this ), 'layerLookup root matches' );
      
      var n = this.layers.length;
      if ( n === 0 ) {
        assert && assert( !trail.lastNode().isPainted(), 'There should be at least one layer for a painted trail' );
        return [];
      }
      
      assert && assert( trail.areIndicesValid() );
      
      var layers = this.layers;
      
      // from layers 0 to n-1, notAfter goes from false to true, notBefore goes from true to false
      var low = -1;
      var high = n;
      var mid;
      
      // midpoint search to see where our trail's start isn't after a layer's end
      while ( high - 1 > low ) {
        mid = ( high + low ) >> 1;
        var endTrail = layers[mid].endPaintedTrail;
        assert && assert( endTrail.areIndicesValid() );
        // NOTE TO SELF: don't change this flag to true again. think it through
        // trail,true points to the beginning of the node, right before it would be rendered
        var notAfter = scenery.TrailPointer.compareNested( trail, true, endTrail, true ) !== 1;
        if ( notAfter ) {
          high = mid;
        } else {
          low = mid;
        }
      }
      
      // store result and reset bound
      var firstIndex = high;
      low = -1;
      high = n;
      
      // midpoint search to see where our trail's end isn't before a layer's start
      while ( high - 1 > low ) {
        mid = ( high + low ) >> 1;
        var startTrail = layers[mid].startPaintedTrail;
        startTrail.reindex();
        assert && assert( startTrail.areIndicesValid() );
        var notBefore = scenery.TrailPointer.compareNested( trail, false, startTrail, true ) !== -1;
        if ( notBefore ) {
          low = mid;
        } else {
          high = mid;
        }
      }
      
      var lastIndex = low;
      
      return layers.slice( firstIndex, lastIndex + 1 );
    },
    
    // attempt to render everything currently visible in the scene to an external canvas. allows copying from canvas layers straight to the other canvas
    renderToCanvas: function( canvas, context, callback ) {
      var count = 0;
      var started = false; // flag guards against asynchronous tests that call back synchronously (immediate increment and decrement)
      var delayCounts = {
        increment: function() {
          count++;
        },
        
        decrement: function() {
          count--;
          if ( count === 0 && callback && started ) {
            callback();
          }
        }
      };
      
      context.clearRect( 0, 0, canvas.width, canvas.height );
      var len = this.layers.length;
      for ( var i = 0; i < len; i++ ) {
        this.layers[i].renderToCanvas( canvas, context, delayCounts );
      }
      
      if ( count === 0 ) {
        // no asynchronous layers, callback immediately
        if ( callback ) {
          callback();
        }
      } else {
        started = true;
      }
    },
    
    // TODO: consider SVG data URLs
    canvasDataURL: function( callback ) {
      this.canvasSnapshot( function( canvas ) {
        callback( canvas.toDataURL() );
      } );
    },
    
    // renders what it can into a Canvas (so far, Canvas and SVG layers work fine)
    canvasSnapshot: function( callback ) {
      var canvas = document.createElement( 'canvas' );
      canvas.width = this.sceneBounds.getWidth();
      canvas.height = this.sceneBounds.getHeight();
      
      var context = canvas.getContext( '2d' );
      this.renderToCanvas( canvas, context, function() {
        callback( canvas, context.getImageData( 0, 0, canvas.width, canvas.height ) );
      } );
    },
    
    // TODO: Note that this is private, better name?
    setSize: function( width, height ) {
      // resize our main container
      this.$main.width( width );
      this.$main.height( height );
      
      // set the container's clipping so anything outside won't show up
      // TODO: verify this clipping doesn't reduce performance!
      this.$main.css( 'clip', 'rect(0px,' + width + 'px,' + height + 'px,0px)' );
      
      this.sceneBounds = new Bounds2( 0, 0, width, height );
    },
    
    resize: function( width, height ) {
      if ( this.sceneBounds.width !== width || this.sceneBounds.height !== height ) {
        this.setSize( width, height );
        this.rebuildLayers(); // TODO: why? - change this to resize individual layers

        if ( accessibility ) {
          this.resizeAccessibilityLayer( width, height );
          this.resizeFocusRingSVGContainer( width, height );
          
          //Update the focus ring when the scene resizes.  Note: as of 5/10/2013 this only works properly when scaling up, and is buggy (off by a translation) when scaling down
          if ( this.updateFocusRing && this.activePeer) {
            // this.updateScene();
            this.updateFocusRing();
          }
        }
        
        if ( this.input ) {
          sceneryEventLog && sceneryEventLog( 'validatePointers from scene resize' );
          this.input.validatePointers();
        }
        
        this.fireEvent( 'resize', { width: width, height: height } );
      }
    },

    // TODO: Refactor the following methods into one to avoid code duplication.
    resizeAccessibilityLayer: function( width, height ) {
      if ( this.accessibilityLayer ) {
        this.accessibilityLayer.setAttribute( 'width', width );
        this.accessibilityLayer.setAttribute( 'height', height );
        this.accessibilityLayer.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
      }
    },
    
    resizeFocusRingSVGContainer: function( width, height ) {
      if ( this.focusRingSVGContainer ) {
        this.focusRingSVGContainer.setAttribute( 'width', width );
        this.focusRingSVGContainer.setAttribute( 'height', height );
        this.focusRingSVGContainer.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
      }
    },

    getSceneWidth: function() {
      return this.sceneBounds.getWidth();
    },
    
    getSceneHeight: function() {
      return this.sceneBounds.getHeight();
    },
    
    markSceneForLayerRefresh: function( instance ) {
      sceneryLayerLog && sceneryLayerLog( 'Scene: marking layer refresh: ' + instance.trail.toString() );
      this.markInterval( instance.trail );
    },
    
    markSceneForInsertion: function( instance, child, index ) {
      var affectedTrail = instance.trail.copy().addDescendant( child );
      sceneryLayerLog && sceneryLayerLog( 'Scene: marking insertion: ' + affectedTrail.toString() );
      
      sceneryLayerLog && sceneryLayerLog( 'inserting instances onto ' + instance.toString() + ' with child ' + child.id + ' and index ' + index );
      var baseInstance = instance.createChild( child, index );
      
      buildInstances( baseInstance );
      
      this.markInterval( affectedTrail );
    },
    
    markSceneForRemoval: function( instance, child, index ) {
      // mark the interval
      var affectedTrail = instance.trail.copy().addDescendant( child );
      sceneryLayerLog && sceneryLayerLog( 'Scene: marking removal: ' + affectedTrail.toString() );
      this.markInterval( affectedTrail );
      
      // remove the necessary instances
      var toRemove = [ instance.children[index] ];
      instance.removeInstance( index );
      while ( toRemove.length ) {
        var item = toRemove.pop();
        assert && assert( item, 'item instance should always exist' );
        
        // add its children
        Array.prototype.push.apply( toRemove, item.children );
        
        item.dispose(); // removes it from the node and sets it up for easy GC
      }
    },
    
    updateCursor: function() {
      if ( this.input && this.input.mouse && this.input.mouse.point ) {
        if ( this.input.mouse.cursor ) {
          return this.setSceneCursor( this.input.mouse.cursor );
        }
        
        var mouseTrail = this.trailUnderPoint( this.input.mouse.point, { isMouse: true } );
        
        if ( mouseTrail ) {
          for ( var i = mouseTrail.length - 1; i >= 0; i-- ) {
            var cursor = mouseTrail.nodes[i].getCursor();
            
            if ( cursor ) {
              return this.setSceneCursor( cursor );
            }
          }
        }
      }
      
      // fallback case
      this.setSceneCursor( this.defaultCursor );
    },
    
    setSceneCursor: function( cursor ) {
      if ( cursor !== this.lastCursor ) {
        this.lastCursor = cursor;
        var customCursors = Scene.customCursors[cursor];
        if ( customCursors ) {
          // go backwards, so the most desired cursor sticks
          for ( var i = customCursors.length - 1; i >= 0; i-- ) {
            this.main.style.cursor = customCursors[i];
          }
        } else {
          this.main.style.cursor = cursor;
        }
      }
    },
    
    updateOnRequestAnimationFrame: function( element ) {
      var scene = this;
      (function step() {
        window.requestAnimationFrame( step, element );
        scene.updateScene();
      })();
    },
    
    initializeStandaloneEvents: function( parameters ) {
      // TODO extract similarity between standalone and fullscreen!
      var element = this.$main[0];
      this.initializeEvents( _.extend( {}, {
        listenerTarget: element,
        pointFromEvent: function pointFromEvent( evt ) {
          var mainBounds = element.getBoundingClientRect();
          return Vector2.createFromPool( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );
        }
      }, parameters ) );
    },
    
    initializeFullscreenEvents: function( parameters ) {
      var element = this.$main[0];
      this.initializeEvents( _.extend( {}, {
        listenerTarget: document,
        pointFromEvent: function pointFromEvent( evt ) {
          var mainBounds = element.getBoundingClientRect();
          return Vector2.createFromPool( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );
        }
      }, parameters ) );
    },
    
    initializeWindowEvents: function( parameters ) {
      this.initializeEvents( _.extend( {}, {
        listenerTarget: window,
        pointFromEvent: function pointFromEvent( evt ) {
          return Vector2.createFromPool( evt.clientX, evt.clientY );
        }
      }, parameters ) );
    },
    
    initializeEvents: function( parameters ) {
      var scene = this;
      
      if ( scene.input ) {
        throw new Error( 'Attempt to attach events twice to the scene' );
      }
      
      // TODO: come up with more parameter names that have the same string length, so it looks creepier
      var pointFromEvent = parameters.pointFromEvent;
      var listenerTarget = parameters.listenerTarget;
      var batchDOMEvents = parameters.batchDOMEvents;
      
      var input = new scenery.Input( scene, listenerTarget, !!batchDOMEvents );
      scene.input = input;
      
      // maps the current MS pointer types onto the pointer spec
      function msPointerType( evt ) {
        if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_TOUCH ) {
          return 'touch';
        } else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_PEN ) {
          return 'pen';
        } else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_MOUSE ) {
          return 'mouse';
        } else {
          return evt.pointerType; // hope for the best
        }
      }
      
      function forEachChangedTouch( evt, callback ) {
        for ( var i = 0; i < evt.changedTouches.length; i++ ) {
          // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
          var touch = evt.changedTouches.item( i );
          
          callback( touch.identifier, pointFromEvent( touch ) );
        }
      }
      
      // TODO: massive boilerplate reduction! closures should help tons!
      
      var implementsPointerEvents = window.navigator && window.navigator.pointerEnabled; // W3C spec for pointer events
      var implementsMSPointerEvents = window.navigator && window.navigator.msPointerEnabled; // MS spec for pointer event
      if ( this.enablePointerEvents && implementsPointerEvents ) {
        sceneryEventLog && sceneryEventLog( 'Detected pointer events support, using that instead of mouse/touch events' );
        // accepts pointer events corresponding to the spec at http://www.w3.org/TR/pointerevents/
        input.addListener( 'pointerdown', function pointerDownCallback( domEvent ) {
          input.pointerDown( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'pointerup', function pointerUpCallback( domEvent ) {
          input.pointerUp( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'pointermove', function pointerMoveCallback( domEvent ) {
          input.pointerMove( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'pointerover', function pointerOverCallback( domEvent ) {
          input.pointerOver( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'pointerout', function pointerOutCallback( domEvent ) {
          input.pointerOut( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'pointercancel', function pointerCancelCallback( domEvent ) {
          input.pointerCancel( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
        // immediate version
        input.addImmediateListener( 'pointerup', function pointerUpCallback( domEvent ) {
          input.pointerUpImmediate( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );
        } );
      } else if ( this.enablePointerEvents && implementsMSPointerEvents ) {
        sceneryEventLog && sceneryEventLog( 'Detected MS pointer events support, using that instead of mouse/touch events' );
        input.addListener( 'MSPointerDown', function msPointerDownCallback( domEvent ) {
          input.pointerDown( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'MSPointerUp', function msPointerUpCallback( domEvent ) {
          input.pointerUp( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'MSPointerMove', function msPointerMoveCallback( domEvent ) {
          input.pointerMove( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'MSPointerOver', function msPointerOverCallback( domEvent ) {
          input.pointerOver( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'MSPointerOut', function msPointerOutCallback( domEvent ) {
          input.pointerOut( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'MSPointerCancel', function msPointerCancelCallback( domEvent ) {
          input.pointerCancel( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
        // immediate version
        input.addImmediateListener( 'MSPointerUp', function msPointerUpCallback( domEvent ) {
          input.pointerUpImmediate( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );
        } );
      } else {
        sceneryEventLog && sceneryEventLog( 'No pointer events support detected, using mouse/touch events' );
        input.addListener( 'mousedown', function mouseDownCallback( domEvent ) {
          input.mouseDown( pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'mouseup', function mouseUpCallback( domEvent ) {
          input.mouseUp( pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'mousemove', function mouseMoveCallback( domEvent ) {
          input.mouseMove( pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'mouseover', function mouseOverCallback( domEvent ) {
          input.mouseOver( pointFromEvent( domEvent ), domEvent );
        } );
        input.addListener( 'mouseout', function mouseOutCallback( domEvent ) {
          input.mouseOut( pointFromEvent( domEvent ), domEvent );
        } );
        // immediate version
        input.addImmediateListener( 'mouseup', function mouseUpCallback( domEvent ) {
          input.mouseUpImmediate( pointFromEvent( domEvent ), domEvent );
        } );
        
        input.addListener( 'touchstart', function touchStartCallback( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'touchstart (multiple events)' );
          forEachChangedTouch( domEvent, function touchStartTouch( id, point ) {
            input.touchStart( id, point, domEvent );
          } );
        } );
        input.addListener( 'touchend', function touchEndCallback( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'touchend (multiple events)' );
          forEachChangedTouch( domEvent, function touchEndTouch( id, point ) {
            input.touchEnd( id, point, domEvent );
          } );
        } );
        input.addListener( 'touchmove', function touchMoveCallback( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'touchmove (multiple events)' );
          forEachChangedTouch( domEvent, function touchMoveTouch( id, point ) {
            input.touchMove( id, point, domEvent );
          } );
        } );
        input.addListener( 'touchcancel', function touchCancelCallback( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'touchcancel (multiple events)' );
          forEachChangedTouch( domEvent, function touchCancelTouch( id, point ) {
            input.touchCancel( id, point, domEvent );
          } );
        } );
        // immediate version
        input.addImmediateListener( 'touchend', function touchEndCallback( domEvent ) {
          sceneryEventLog && sceneryEventLog( 'touchend immediate (multiple events)' );
          forEachChangedTouch( domEvent, function touchEndTouch( id, point ) {
            input.touchEndImmediate( id, point, domEvent );
          } );
        } );
      }
      
      input.addListener( 'keyup', function keyUpCallback( domEvent ) {
        input.keyUp( domEvent );
      } );
      input.addListener( 'keydown', function keyDownCallback( domEvent ) {
        input.keyDown( domEvent );
      } );
      input.addListener( 'keypress', function keyPressCallback( domEvent ) {
        input.keyPress( domEvent );
      } );
    },
    
    setPointerDisplayVisible: function( visible ) {
      if ( visible && !this.pointerOverlay ) {
        this.pointerOverlay = new scenery.PointerOverlay( this );
      } else if ( !visible && this.pointerOverlay ) {
        this.pointerOverlay.dispose();
        delete this.pointerOverlay;
      }
    },
    
    setPointerAreaDisplayVisible: function( visible ) {
      if ( visible && !this.mouseTouchAreaOverlay ) {
        this.mouseTouchAreaOverlay = new scenery.PointerAreaOverlay( this );
      } else if ( !visible && this.mouseTouchAreaOverlay ) {
        this.mouseTouchAreaOverlay.dispose();
        delete this.mouseTouchAreaOverlay;
      }
    },
    
    getTrailFromKeyboardFocus: function() {
      // return the root (scene) trail by default
      // TODO: fill in with actual keyboard focus
      return new scenery.Trail( this );
    },
    
    fireBatchedEvents: function() {
      this.input.fireBatchedEvents();
    },
    
    resizeOnWindowResize: function() {
      var scene = this;
      
      var resizer = function() {
        scene.resize( window.innerWidth, window.innerHeight );
      };
      $( window ).resize( resizer );
      resizer();
    },
    
    // in-depth check to make sure everything is layered properly
    layerAudit: function() {
      var scene = this;
      
      var boundaries = this.calculateBoundaries( null, null, null );
      assert && assert( boundaries.length === this.layers.length + 1, 'boundary count (' + boundaries.length + ') does not match layer count (' + this.layers.length + ') + 1' );
      
      // count how many 'self' trails there are
      var eachTrailUnderPaintedCount = 0;
      new scenery.Trail( this ).eachTrailUnder( function( trail ) {
        if ( trail.isPainted() ) {
          eachTrailUnderPaintedCount++;
          
          assert && assert( trail.getInstance(), 'every painted trail must have an instance' );
        }
        
        assert && assert( trail.getInstance() && trail.getInstance().trail.equals( trail ), 'every trail must have a single corresponding instance' );
      } );
      
      var layerPaintedCount = 0;
      _.each( this.layers, function( layer ) {
        layerPaintedCount += layer.getLayerTrails().length;
        
        // reindex now so we don't have problems later
        layer.startPaintedTrail.reindex();
        layer.endPaintedTrail.reindex();
      } );
      
      var layerIterationPaintedCount = 0;
      _.each( this.layers, function( layer ) {
        var selfCount = 0;
        scenery.Trail.eachPaintedTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {
          selfCount++;
        }, false, scene );
        assert && assert( selfCount > 0, 'every layer must have at least one self trail' );
        layerIterationPaintedCount += selfCount;
      } );
      
      assert && assert( eachTrailUnderPaintedCount === layerPaintedCount, 'cross-referencing self trail counts: layerPaintedCount, ' + eachTrailUnderPaintedCount + ' vs ' + layerPaintedCount );
      assert && assert( eachTrailUnderPaintedCount === layerIterationPaintedCount, 'cross-referencing self trail counts: layerIterationPaintedCount, ' + eachTrailUnderPaintedCount + ' vs ' + layerIterationPaintedCount );
      
      _.each( this.layers, function( layer ) {
        assert && assert( layer.startPaintedTrail.compare( layer.endPaintedTrail ) <= 0, 'proper ordering on layer trails' );
      } );
      
      for ( var i = 1; i < this.layers.length; i++ ) {
        assert && assert( this.layers[i-1].endPaintedTrail.compare( this.layers[i].startPaintedTrail ) === -1, 'proper ordering of layer trail boundaries in scene.layers array' );
        assert && assert( this.layers[i-1].endBoundary === this.layers[i].startBoundary, 'proper sharing of boundaries' );
      }
      
      _.each( this.layers, function( layer ) {
        // a list of trails that the layer tracks
        var layerTrails = layer.getLayerTrails();
        
        // a list of trails that the layer should be tracking (between painted trails)
        var computedTrails = [];
        scenery.Trail.eachPaintedTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {
          computedTrails.push( trail.copy() );
        }, false, scene );
        
        // verify that the layer has an identical record of trails compared to the trails inside its boundaries
        assert && assert( layerTrails.length === computedTrails.length, 'layer has incorrect number of tracked trails' );
        _.each( layerTrails, function( trail ) {
          assert && assert( _.some( computedTrails, function( otherTrail ) { return trail.equals( otherTrail ); } ), 'layer has a tracked trail discrepancy' );
        } );
        
        // verify that each trail has the same (or null) renderer as the layer
        scenery.Trail.eachTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {
          var node = trail.lastNode();
          assert && assert( !node.renderer || node.renderer.name === layer.type.name, 'specified renderers should match the layer renderer' );
        }, false, scene );
      } );
      
      // verify layer splits
      new scenery.Trail( this ).eachTrailUnder( function( trail ) {
        var beforeSplitTrail;
        var afterSplitTrail;
        if ( trail.lastNode().layerSplit ) {
          // for the "before" split
          beforeSplitTrail = trail.previousPainted();
          afterSplitTrail = trail.lastNode().isPainted() ? trail : trail.nextPainted();
          assert && assert( !beforeSplitTrail || !afterSplitTrail || beforeSplitTrail.getInstance().layer !== afterSplitTrail.getInstance().layer, 'layerSplit layers need to be different' );
          
          //for the "after" split
          // shift a pointer from the (nested) end of the trail to the next isBefore (if available)
          var ptr = new scenery.TrailPointer( trail.copy(), false );
          while ( ptr && ptr.isAfter ) {
            ptr = ptr.nestedForwards();
          }
          
          // if !ptr, we walked off the end of the graph (nothing after layer split, automatically ok)
          if ( ptr ) {
            beforeSplitTrail = ptr.trail.previousPainted();
            afterSplitTrail = ptr.trail.lastNode().isPainted() ? ptr.trail : ptr.trail.nextPainted();
            assert && assert( !beforeSplitTrail || !afterSplitTrail || beforeSplitTrail.getInstance().layer !== afterSplitTrail.getInstance().layer, 'layerSplit layers need to be different' );
          }
        }
      } );
      
      return true; // so we can assert( layerAudit() )
    },
    
    getDebugHTML: function() {
      var startPointer = new scenery.TrailPointer( new scenery.Trail( this ), true );
      var endPointer = new scenery.TrailPointer( new scenery.Trail( this ), false );
      
      function str( ob ) {
        return ob ? ob.toString() : ob;
      }
      
      var depth = 0;
      
      var result = '';
      
      var layerStartEntries = {};
      var layerEndEntries = {};
      _.each( this.layers, function( layer ) {
        var startIdx = layer.startPaintedTrail.getUniqueId();
        var endIndex = layer.endPaintedTrail.getUniqueId();
        layerStartEntries[startIdx] = '';
        layerEndEntries[endIndex] = '';
        layer.startPaintedTrail.reindex();
        layer.endPaintedTrail.reindex();
        var layerInfo = layer.getId() + ' <strong>' + layer.type.name + '</strong>' +
                        ' trails: ' + ( layer.startPaintedTrail ? str( layer.startPaintedTrail ) : layer.startPaintedTrail ) +
                        ',' + ( layer.endPaintedTrail ? str( layer.endPaintedTrail ) : layer.endPaintedTrail );
        layerInfo += '<span style="color: #008">';
        if ( layer.canUseDirtyRegions && !layer.canUseDirtyRegions() ) { layerInfo += ' dirtyRegionsDisabled'; }
        if ( layer.cssTranslation ) { layerInfo += ' cssTranslation'; }
        if ( layer.cssRotation ) { layerInfo += ' cssTranslation'; }
        if ( layer.cssScale ) { layerInfo += ' cssTranslation'; }
        if ( layer.cssTransform ) { layerInfo += ' cssTranslation'; }
        if ( layer.dirtyBounds && layer.dirtyBounds.isFinite() ) { layerInfo += ' dirtyBounds:' + layer.dirtyBounds.toString(); }
        layerInfo += '</span>';
        layerStartEntries[startIdx] += '<div style="color: #080">+Layer ' + layerInfo + '</div>';
        layerEndEntries[endIndex] += '<div style="color: #800">-Layer ' + layerInfo + '</div>';
      } );
      
      startPointer.depthFirstUntil( endPointer, function( pointer ) {
        var div;
        var node = pointer.trail.lastNode();
        
        function addQualifier( text ) {
            div += ' <span style="color: #008">' + text + '</span>';
          }
        
        if ( pointer.isBefore && layerStartEntries[pointer.trail.getUniqueId()] ) {
          result += layerStartEntries[pointer.trail.getUniqueId()];
        }
        if ( pointer.isBefore ) {
          div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';
          if ( node.constructor.name ) {
            div += ' ' + node.constructor.name; // see http://stackoverflow.com/questions/332422/how-do-i-get-the-name-of-an-objects-type-in-javascript
          }
          div += ' <span style="font-weight: ' + ( node.isPainted() ? 'bold' : 'normal' ) + '">' + pointer.trail.lastNode().getId() + '</span>';
          div += ' <span style="color: #888">' + str( pointer.trail ) + '</span>';
          if ( !node._visible ) {
            addQualifier( 'invisible' );
          }
          if ( node._pickable === true ) {
            addQualifier( 'pickable' );
          }
          if ( node._pickable === false ) {
            addQualifier( 'unpickable' );
          }
          if ( pointer.trail.isPickable() ) {
            addQualifier( '<span style="color: #808">hits</span>' );
          }
          if ( node._clipArea ) {
            addQualifier( 'clipArea' );
          }
          if ( node._mouseArea ) {
            addQualifier( 'mouseArea' );
          }
          if ( node._touchArea ) {
            addQualifier( 'touchArea' );
          }
          if ( node._inputListeners.length ) {
            addQualifier( 'inputListeners' );
          }
          if ( node._renderer ) {
            addQualifier( 'renderer:' + node._renderer.name );
          }
          if ( node._rendererOptions ) {
            // addQualifier( 'rendererOptions:' + _.each( node._rendererOptions, function( option, key ) { return key + ':' + str( option ); } ).join( ',' ) );
          }
          if ( node._layerSplit ) {
            addQualifier( 'layerSplit' );
          }
          if ( node._opacity < 1 ) {
            addQualifier( 'opacity:' + node._opacity );
          }
          
          var transformType = '';
          switch ( node.transform.getMatrix().type ) {
            case Matrix3.Types.IDENTITY:       transformType = '';           break;
            case Matrix3.Types.TRANSLATION_2D: transformType = 'translated'; break;
            case Matrix3.Types.SCALING:        transformType = 'scale';      break;
            case Matrix3.Types.AFFINE:         transformType = 'affine';     break;
            case Matrix3.Types.OTHER:          transformType = 'other';      break;
          }
          if ( transformType ) {
            div += ' <span style="color: #88f" title="' + node.transform.getMatrix().toString().replace( '\n', '&#10;' ) + '">' + transformType + '</span>';
          }
          div += '</div>';
          result += div;
        }
        if ( pointer.isAfter && layerEndEntries[pointer.trail.getUniqueId()] ) {
          result += layerEndEntries[pointer.trail.getUniqueId()];
        }
        depth += pointer.isBefore ? 1 : -1;
      }, false );
      
      return result;
    },
    
    popupDebug: function() {
      var htmlContent = '<!DOCTYPE html>' +
                        '<html lang="en">' +
                        '<head><title>Scenery Debug Snapshot</title></head>' +
                        '<body>' + this.getDebugHTML() + '</body>' +
                        '</html>';
      window.open( 'data:text/html;charset=utf-8,' + encodeURIComponent( htmlContent ) );
    },
    
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Scene( $( \'#main\' ), {' + propLines + '} )';
    },
    
    toStringWithChildren: function( mutateScene ) {
      var scene = this;
      var result = '';
      
      var nodes = this.getTopologicallySortedNodes().slice( 0 ).reverse(); // defensive slice, in case we store the order somewhere
      
      function name( node ) {
        return node === scene ? 'scene' : ( ( node.constructor.name ? node.constructor.name.toLowerCase() : '(node)' ) + node.id );
      }
      
      _.each( nodes, function( node ) {
        if ( result ) {
          result += '\n';
        }
        
        if ( mutateScene && node === scene ) {
          var props = scene.getPropString( '  ', false );
          result += 'scene.mutate( {' + ( props ? ( '\n' + props + '\n' ) : '' ) + '} )';
        } else {
          result += 'var ' + name( node ) + ' = ' + node.toString( '', false );
        }
        
        _.each( node.children, function( child ) {
          result += '\n' + name( node ) + '.addChild( ' + name( child ) + ' );';
        } );
      } );
      
      return result;
    }
  } );
  
  Scene.customCursors = {
    'scenery-grab-pointer': ['grab', '-moz-grab', '-webkit-grab', 'pointer'],
    'scenery-grabbing-pointer': ['grabbing', '-moz-grabbing', '-webkit-grabbing', 'pointer']
  };
  
  function applyCSSHacks( $main, options ) {
    // to use CSS3 transforms for performance, hide anything outside our bounds by default
    if ( !options.allowSceneOverflow ) {
      $main.css( 'overflow', 'hidden' );
    }
    
    // forward all pointer events
    $main.css( '-ms-touch-action', 'none' );
    
    if ( options.allowCSSHacks ) {
      // some css hacks (inspired from https://github.com/EightMedia/hammer.js/blob/master/hammer.js)
      (function() {
        var prefixes = [ '-webkit-', '-moz-', '-ms-', '-o-', '' ];
        var properties = {
          userSelect: 'none',
          touchCallout: 'none',
          touchAction: 'none',
          userDrag: 'none',
          tapHighlightColor: 'rgba(0,0,0,0)'
        };
        
        _.each( prefixes, function( prefix ) {
          _.each( properties, function( propertyValue, propertyName ) {
            $main.css( prefix + propertyName, propertyValue );
          } );
        } );
      })();
    }
  }
  
  return Scene;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Module that includes all Scenery dependencies, so that requiring this module will return an object
 * that consists of the entire exported 'scenery' namespace API.
 *
 * The API is actually generated by the 'scenery' module, so if this module (or all other modules) are
 * not included, the 'scenery' namespace may not be complete.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

define( 'main',[
    'SCENERY/scenery',
    'SCENERY/debug/DebugContext',
    
    'SCENERY/display/BackboneBlock',
    'SCENERY/display/Block',
    'SCENERY/display/Display',
    'SCENERY/display/DisplayInstance',
    'SCENERY/display/RenderState',
    
    'SCENERY/input/ButtonListener',
    'SCENERY/input/DownUpListener',
    'SCENERY/input/Event',
    'SCENERY/input/Input',
    'SCENERY/input/Key',
    'SCENERY/input/Mouse',
    'SCENERY/input/Pen',
    'SCENERY/input/Pointer',
    'SCENERY/input/SimpleDragHandler',
    'SCENERY/input/Touch',
    
    'SCENERY/layers/CanvasLayer',
    'SCENERY/layers/DOMLayer',
    'SCENERY/layers/Layer',
    'SCENERY/layers/LayerBoundary',
    'SCENERY/layers/LayerBuilder',
    'SCENERY/layers/LayerStrategy',
    'SCENERY/layers/LayerType',
    'SCENERY/layers/Renderer',
    'SCENERY/layers/SVGLayer',
    
    'SCENERY/nodes/CanvasNode',
    'SCENERY/nodes/Circle',
    'SCENERY/nodes/DOM',
    'SCENERY/nodes/Fillable',
    'SCENERY/nodes/HBox',
    'SCENERY/nodes/HTMLText',
    'SCENERY/nodes/Image',
    'SCENERY/nodes/LayoutNode',
    'SCENERY/nodes/Line',
    'SCENERY/nodes/Node',
    'SCENERY/nodes/Path',
    'SCENERY/nodes/Plane',
    'SCENERY/nodes/Rectangle',
    'SCENERY/nodes/Strokable',
    'SCENERY/nodes/Text',
    'SCENERY/nodes/VBox',

    'SCENERY/overlays/PointerOverlay',

    'SCENERY/util/AccessibilityPeer',
    'SCENERY/util/CanvasContextWrapper',
    'SCENERY/util/Color',
    'SCENERY/util/Features',
    'SCENERY/util/FixedNodeEvents',
    'SCENERY/util/Font',
    'SCENERY/util/Gradient',
    'SCENERY/util/LinearGradient',
    'SCENERY/util/LiveRegion',
    'SCENERY/util/Instance',
    'SCENERY/util/Pattern',
    'SCENERY/util/RadialGradient',
    'SCENERY/util/RenderInterval',
    'SCENERY/util/SceneImage',
    'SCENERY/util/SceneryStyle',
    'SCENERY/util/Trail',
    'SCENERY/util/TrailPointer',
    'SCENERY/util/Util',
    
    'SCENERY/util/gl/GLUtil',
    'SCENERY/util/gl/GLShader',
    'SCENERY/util/gl/GLShaderProgram',
    
    'SCENERY/Scene'
  ], function(
    scenery // note: we don't need any of the other parts, we just need to specify them as dependencies so they fill in the scenery namespace
  ) {
    
    
    return scenery;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Module that includes all Kite dependencies, so that requiring this module will return an object
 * that consists of the entire exported 'kite' namespace API.
 *
 * The API is actually generated by the 'kite' module, so if this module (or all other modules) are
 * not included, the 'kite' namespace may not be complete.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/main',[
    'KITE/kite',
    
    'KITE/Shape',
    'KITE/segments/Arc',
    'KITE/segments/Cubic',
    'KITE/segments/EllipticalArc',
    'KITE/segments/Line',
    'KITE/segments/Quadratic',
    'KITE/segments/Segment',
    'KITE/util/LineStyles',
    'KITE/util/Subpath',
    
    'KITE/../parser/svgPath'
  ], function(
    kite // note: we don't need any of the other parts, we just need to specify them as dependencies so they fill in the kite namespace
  ) {
  
  
  return kite;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * A 3D cuboid-shaped bounded area (bounding box)
 *
 * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not
 * store these with the Bounds3 instance, since we want to lower the memory footprint.
 *
 * minX, minY, minZ, maxX, maxY, and maxZ are actually stored. We don't do x,y,z,width,height,depth because this can't properly express
 * semi-infinite bounds (like a half-plane), or easily handle what Bounds3.NOTHING and Bounds3.EVERYTHING do with
 * the constructive solid areas.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Bounds3',['require','DOT/dot','DOT/Vector3'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  require( 'DOT/Vector3' );
  
  // not using x,y,width,height so that it can handle infinity-based cases in a better way
  dot.Bounds3 = function Bounds3( minX, minY, minZ, maxX, maxY, maxZ ) {
    assert && assert( maxY !== undefined, 'Bounds3 requires 4 parameters' );
    this.minX = minX;
    this.minY = minY;
    this.minZ = minZ;
    this.maxX = maxX;
    this.maxY = maxY;
    this.maxZ = maxZ;
    
    phetAllocation && phetAllocation( 'Bounds3' );
  };
  var Bounds3 = dot.Bounds3;

  Bounds3.prototype = {
    constructor: Bounds3,
    
    isBounds: true,
    dimension: 3,
    
    /*---------------------------------------------------------------------------*
    * Properties
    *----------------------------------------------------------------------------*/
    
    getWidth: function() { return this.maxX - this.minX; },
    get width() { return this.getWidth(); },
    
    getHeight: function() { return this.maxY - this.minY; },
    get height() { return this.getHeight(); },
    
    getDepth: function() { return this.maxZ - this.minZ; },
    get depth() { return this.getDepth(); },
    
    /* 
     * Convenience locations
     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
     *
     *             minX (x)     centerX        maxX
     *          ---------------------------------------
     * minY (y) | upperLeft   upperCenter   upperRight
     * centerY  | centerLeft    center      centerRight
     * maxY     | lowerLeft   lowerCenter   lowerRight
     */
    getX: function() { return this.minX; },
    get x() { return this.getX(); },
    getY: function() { return this.minY; },
    get y() { return this.getY(); },
    getZ: function() { return this.minZ; },
    get z() { return this.getZ(); },
    
    getMinX: function() { return this.minX; },
    get left() { return this.minX; },
    getMinY: function() { return this.minY; },
    get top() { return this.minY; },
    getMinZ: function() { return this.minZ; },
    get back() { return this.minZ; },
    getMaxX: function() { return this.maxX; },
    get right() { return this.maxX; },
    getMaxY: function() { return this.maxY; },
    get bottom() { return this.maxY; },
    getMaxZ: function() { return this.maxZ; },
    get front() { return this.maxZ; },
    
    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
    get centerX() { return this.getCenterX(); },
    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
    get centerY() { return this.getCenterY(); },
    getCenterZ: function() { return ( this.maxZ + this.minZ ) / 2; },
    get centerZ() { return this.getCenterZ(); },
    
    getCenter: function() { return new dot.Vector3( this.getCenterX(), this.getCenterY(), this.getCenterZ() ); },
    get center() { return this.getCenter(); },
    
    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0 || this.getDepth() < 0; },
    
    isFinite: function() {
      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.minZ ) && isFinite( this.maxX ) && isFinite( this.maxY ) && isFinite( this.maxZ );
    },
    
    isValid: function() {
      return !this.isEmpty() && this.isFinite();
    },
    
    // whether the coordinates are inside the bounding box (or on the boundary)
    containsCoordinates: function( x, y, z ) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY && this.minZ <= z && z <= this.maxZ;
    },
    
    // whether the point is inside the bounding box (or on the boundary)
    containsPoint: function( point ) {
      return this.containsCoordinates( point.x, point.y, point.z );
    },
    
    // whether this bounding box completely contains the argument bounding box
    containsBounds: function( bounds ) {
      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY && this.minZ <= bounds.minZ && this.maxZ >= bounds.maxZ;
    },
    
    // whether the intersection is non-empty (if they share any part of a boundary, this will be true)
    intersectsBounds: function( bounds ) {
      // TODO: more efficient way of doing this?
      return !this.intersection( bounds ).isEmpty();
    },
    
    toString: function() {
      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + '),z:(' + this.minZ + ',' + this.maxZ + ')]';
    },
    
    equals: function( other ) {
      return this.minX === other.minX && this.minY === other.minY && this.minZ === other.minZ && this.maxX === other.maxX && this.maxY === other.maxY && this.maxZ === other.maxZ;
    },
    
    equalsEpsilon: function( other, epsilon ) {
      epsilon = epsilon || 0;
      var thisFinite = this.isFinite();
      var otherFinite = other.isFinite();
      if ( thisFinite && otherFinite ) {
        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity
        return Math.abs( this.minX - other.minX ) < epsilon &&
               Math.abs( this.minY - other.minY ) < epsilon &&
               Math.abs( this.minZ - other.minZ ) < epsilon &&
               Math.abs( this.maxX - other.maxX ) < epsilon &&
               Math.abs( this.maxY - other.maxY ) < epsilon &&
               Math.abs( this.maxZ - other.maxZ ) < epsilon;
      } else if ( thisFinite !== otherFinite ) {
        return false; // one is finite, the other is not. definitely not equal
      } else if ( this === other ) {
        return true; // exact same instance, must be equal
      } else {
        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both
        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
               ( isFinite( this.minZ + other.minZ ) ? ( Math.abs( this.minZ - other.minZ ) < epsilon ) : ( this.minZ === other.minZ ) ) &&
               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) ) &&
               ( isFinite( this.maxZ + other.maxZ ) ? ( Math.abs( this.maxZ - other.maxZ ) < epsilon ) : ( this.maxZ === other.maxZ ) );
      }
    },
    
    /*---------------------------------------------------------------------------*
    * Immutable operations
    *----------------------------------------------------------------------------*/
    
    // create a copy, or if bounds is passed in, set that bounds to our value
    copy: function( bounds ) {
      if ( bounds ) {
        return bounds.set( this );
      } else {
        return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ );
      }
    },
    
    // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)
    union: function( bounds ) {
      return new Bounds3(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.min( this.minZ, bounds.minZ ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY ),
        Math.max( this.maxZ, bounds.maxZ )
      );
    },
    intersection: function( bounds ) {
      return new Bounds3(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.max( this.minZ, bounds.minZ ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY ),
        Math.min( this.maxZ, bounds.maxZ )
      );
    },
    // TODO: difference should be well-defined, but more logic is needed to compute
    
    withCoordinates: function( x, y, z ) {
      return new Bounds3(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.min( this.minZ, z ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y ),
        Math.max( this.maxZ, z )
      );
    },
    
    // like a union with a point-sized bounding box
    withPoint: function( point ) {
      return this.withCoordinates( point.x, point.y, point.z );
    },
    
    withMinX: function( minX ) { return new Bounds3( minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ ); },
    withMinY: function( minY ) { return new Bounds3( this.minX, minY, this.minZ, this.maxX, this.maxY, this.maxZ ); },
    withMinZ: function( minZ ) { return new Bounds3( this.minX, this.minY, minZ, this.maxX, this.maxY, this.maxZ ); },
    withMaxX: function( maxX ) { return new Bounds3( this.minX, this.minY, this.minZ, maxX, this.maxY, this.maxZ ); },
    withMaxY: function( maxY ) { return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, maxY, this.maxZ ); },
    withMaxZ: function( maxZ ) { return new Bounds3( this.minX, this.minY, this.minZ, this.maxX, this.maxY, maxZ ); },
    
    // copy rounded to integral values, expanding where necessary
    roundedOut: function() {
      return new Bounds3(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.floor( this.minZ ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY ),
        Math.ceil( this.maxZ )
      );
    },
    
    // copy rounded to integral values, contracting where necessary
    roundedIn: function() {
      return new Bounds3(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.ceil( this.minZ ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY ),
        Math.floor( this.maxZ )
      );
    },
    
    // transform a bounding box.
    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box
    transformed: function( matrix ) {
      return this.copy().transform( matrix );
    },
    
    // returns copy expanded on all sides by length d
    dilated: function( d ) {
      return new Bounds3( this.minX - d, this.minY - d, this.minZ - d, this.maxX + d, this.maxY + d, this.maxZ + d );
    },
    
    // dilates only in the x direction
    dilatedX: function( x ) {
      return new Bounds3( this.minX - x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },
    
    // dilates only in the y direction
    dilatedY: function( y ) {
      return new Bounds3( this.minX, this.minY - y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },
    
    // dilates only in the z direction
    dilatedZ: function( z ) {
      return new Bounds3( this.minX, this.minY, this.minZ - z, this.maxX, this.maxY, this.maxZ + z );
    },
    
    // dilate with different amounts in the x, y and z directions
    dilatedXYZ: function( x, y, z ) {
      return new Bounds3( this.minX - x, this.minY - y, this.minZ - z, this.maxX + x, this.maxY + y, this.maxZ + z );
    },
    
    // returns copy contracted on all sides by length d, or x/y/z separately
    eroded: function( d ) { return this.dilated( -d ); },
    erodedX: function( x ) { return this.dilatedX( -x ); },
    erodedY: function( y ) { return this.dilatedY( -y ); },
    erodedZ: function( z ) { return this.dilatedZ( -z ); },
    erodedXYZ: function( x, y, z ) { return this.dilatedXYZ( -x, -y, -z ); },
    
    shiftedX: function( x ) {
      return new Bounds3( this.minX + x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },
    
    shiftedY: function( y ) {
      return new Bounds3( this.minX, this.minY + y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },
    
    shiftedZ: function( z ) {
      return new Bounds3( this.minX, this.minY, this.minZ + z, this.maxX, this.maxY, this.maxZ + z );
    },
    
    shifted: function( x, y, z ) {
      return new Bounds3( this.minX + x, this.minY + y, this.minZ + z, this.maxX + x, this.maxY + y, this.maxZ + z );
    },
    
    /*---------------------------------------------------------------------------*
    * Mutable operations
    *----------------------------------------------------------------------------*/
    
    // core mutations (every other mutator should call one of these once)
    setMinMax: function( minX, minY, minZ, maxX, maxY, maxZ ) {
      this.minX = minX;
      this.minY = minY;
      this.minZ = minZ;
      this.maxX = maxX;
      this.maxY = maxY;
      this.maxZ = maxZ;
      return this;
    },
    setMinX: function( minX ) { this.minX = minX; return this; },
    setMinY: function( minY ) { this.minY = minY; return this; },
    setMinZ: function( minZ ) { this.minZ = minZ; return this; },
    setMaxX: function( maxX ) { this.maxX = maxX; return this; },
    setMaxY: function( maxY ) { this.maxY = maxY; return this; },
    setMaxZ: function( maxZ ) { this.maxZ = maxZ; return this; },
    
    set: function( bounds ) {
      return this.setMinMax( bounds.minX, bounds.minY, bounds.minZ, bounds.maxX, bounds.maxY, bounds.maxZ );
    },
    
    // mutable union
    includeBounds: function( bounds ) {
      return this.setMinMax(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.min( this.minZ, bounds.minZ ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY ),
        Math.max( this.maxZ, bounds.maxZ )
      );
    },
    
    // mutable intersection
    constrainBounds: function( bounds ) {
      return this.setMinMax(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.max( this.minZ, bounds.minZ ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY ),
        Math.min( this.maxZ, bounds.maxZ )
      );
    },
    
    addCoordinates: function( x, y, z ) {
      return this.setMinMax(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.min( this.minZ, z ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y ),
        Math.max( this.maxZ, z )
      );
    },
    
    addPoint: function( point ) {
      return this.addCoordinates( point.x, point.y, point.z );
    },
    
    // round to integral values, expanding where necessary
    roundOut: function() {
      return this.setMinMax(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.floor( this.minZ ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY ),
        Math.ceil( this.maxZ )
      );
    },
    
    // round to integral values, contracting where necessary
    roundIn: function() {
      return this.setMinMax(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.ceil( this.minZ ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY ),
        Math.floor( this.maxZ )
      );
    },
    
    // transform a bounding box.
    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box
    transform: function( matrix ) {
      // do nothing
      if ( this.isEmpty() ) {
        return this;
      }
      
      // optimization to bail for identity matrices
      if ( matrix.isIdentity() ) {
        return this;
      }
      
      var minX = Number.POSITIVE_INFINITY;
      var minY = Number.POSITIVE_INFINITY;
      var minZ = Number.POSITIVE_INFINITY;
      var maxX = Number.NEGATIVE_INFINITY;
      var maxY = Number.NEGATIVE_INFINITY;
      var maxZ = Number.NEGATIVE_INFINITY;
      
      // using mutable vector so we don't create excessive instances of Vector2 during this
      // make sure all 4 corners are inside this transformed bounding box
      var vector = new dot.Vector3();
      
      function withIt( vector ) {
        minX = Math.min( minX, vector.x );
        minY = Math.min( minY, vector.y );
        minZ = Math.min( minZ, vector.z );
        maxX = Math.max( maxX, vector.x );
        maxY = Math.max( maxY, vector.y );
        maxZ = Math.max( maxZ, vector.z );
      }
      
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.minY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.maxY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.minY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.maxY, this.minZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.minY, this.maxZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.minX, this.maxY, this.maxZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.minY, this.maxZ ) ) );
      withIt( matrix.multiplyVector3( vector.setXYZ( this.maxX, this.maxY, this.maxZ ) ) );
      return this.setMinMax( minX, minY, minZ, maxX, maxY, maxZ );
    },
    
    // expands on all sides by length d
    dilate: function( d ) {
      return this.setMinMax( this.minX - d, this.minY - d, this.minZ - d, this.maxX + d, this.maxY + d, this.maxZ + d );
    },
    
    // dilates only in the x direction
    dilateX: function( x ) {
      return this.setMinMax( this.minX - x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },
    
    // dilates only in the y direction
    dilateY: function( y ) {
      return this.setMinMax( this.minX, this.minY - y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },
    
    // dilates only in the z direction
    dilateZ: function( z ) {
      return this.setMinMax( this.minX, this.minY, this.minZ - z, this.maxX, this.maxY, this.maxZ + z );
    },
    
    // dilate with different amounts in the x, y and z directions
    dilateXYZ: function( x, y, z ) {
      return this.setMinMax( this.minX - x, this.minY - y, this.minZ - z, this.maxX + x, this.maxY + y, this.maxZ + z );
    },
    
    // contracts on all sides by length d, or x/y/z independently
    erode: function( d ) { return this.dilate( -d ); },
    erodeX: function( x ) { return this.dilateX( -x ); },
    erodeY: function( y ) { return this.dilateY( -y ); },
    erodeZ: function( z ) { return this.dilateZ( -z ); },
    erodeXYZ: function( x, y, z ) { return this.dilateXYZ( -x, -y, -z ); },
    
    shiftX: function( x ) {
      return this.setMinMax( this.minX + x, this.minY, this.minZ, this.maxX + x, this.maxY, this.maxZ );
    },
    
    shiftY: function( y ) {
      return this.setMinMax( this.minX, this.minY + y, this.minZ, this.maxX, this.maxY + y, this.maxZ );
    },
    
    shiftZ: function( z ) {
      return this.setMinMax( this.minX, this.minY, this.minZ + z, this.maxX, this.maxY, this.maxZ + z );
    },
    
    shift: function( x, y, z ) {
      return this.setMinMax( this.minX + x, this.minY + y, this.minZ + z, this.maxX + x, this.maxY + y, this.maxZ + z );
    }
  };
  
  Bounds3.cuboid = function( x, y, z, width, height, depth ) {
    return new Bounds3( x, y, z, x + width, y + height, z + depth );
  };
  
  // a volume-less point bounds, which can be dilated to form a centered bounds
  Bounds3.point = function( x, y, z ) {
    return new Bounds3( x, y, z, x, y, z );
  };
  
  // specific bounds useful for operations
  Bounds3.EVERYTHING = new Bounds3( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
  Bounds3.NOTHING = new Bounds3( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );
  
  return Bounds3;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Immutable complex number handling
 *
 * TODO: handle quaternions in a Quaternion.js!
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Chris Malley
 */

define( 'DOT/Complex',['require','DOT/dot','PHET_CORE/inherit','DOT/Vector2'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  
  // not using x,y,width,height so that it can handle infinity-based cases in a better way
  dot.Complex = function Complex( real, imaginary ) {
    Vector2.call( this, real, imaginary );
    this.real = real;
    this.imaginary = imaginary;
  };
  var Complex = dot.Complex;
  
  Complex.real = function( real ) {
    return new Complex( real, 0 );
  };
  
  Complex.imaginary = function( imaginary ) {
    return new Complex( 0, imaginary );
  };
  
  Complex.createPolar = function( magnitude, phase ) {
    return new Complex( magnitude * Math.cos( phase ), magnitude * Math.sin( phase ) );
  };
  
  // inheriting Vector2 for now since many times we may want to treat the complex number as a vector
  // ideally, we should have Vector2-likeness be a mixin?
  // we also inherit the immutable form since we add 'real' and 'imaginary' properties,
  // without adding extra logic to mutators in Vector2
  inherit( Vector2.Immutable, Complex, {
    phase: Vector2.prototype.angle,
    
    // TODO: remove times() from Vector2? or have it do this for vectors
    times: function( c ) {
      return new Complex( this.real * c.real - this.imaginary * c.imaginary, this.real * c.imaginary + this.imaginary * c.real );
    },
    
    dividedBy: function( c ) {
      var cMag = c.magnitudeSquared();
      return new Complex(
        ( this.real * c.real + this.imaginary * c.imaginary ) / cMag,
        ( this.imaginary * c.real - this.real * c.imaginary ) / cMag
      );
    },
    
    // TODO: pow()
    sqrt: function() {
      var mag = this.magnitude();
      return new Complex( Math.sqrt( ( mag + this.real ) / 2 ),
                          ( this.imaginary >= 0 ? 1 : -1 ) * Math.sqrt( ( mag - this.real ) / 2 ) );
    },
    
    conjugate: function() {
      return new Complex( this.real, -this.imaginary );
    },
    
    // e^(a+bi) = ( e^a ) * ( cos(b) + i * sin(b) )
    exponentiated: function() {
      return Complex.createPolar( Math.exp( this.real ), this.imaginary );
    },
    
    toString: function() {
      return "Complex(" + this.x + ", " + this.y + ")";
    }
  } );
  
  Complex.ZERO = new Complex( 0, 0 );
  Complex.ONE = new Complex( 1, 0 );
  Complex.I = new Complex( 0, 1 );
  
  return Complex;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * 2D convex hulls
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/ConvexHull2',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  // counter-clockwise turn if > 0, clockwise turn if < 0, collinear if === 0.
  function ccw( p1, p2, p3 ) {
    return p2.minus( p1 ).crossScalar( p3.minus( p1 ) );
  }
  
  dot.ConvexHull2 = {
    // test: all collinear, multiple ways of having same angle, etc.
    
    // points is an array of Vector2 instances. see http://en.wikipedia.org/wiki/Graham_scan
    grahamScan: function( points, includeCollinear ) {
      if ( points.length <= 2 ) {
        return points;
      }
      
      // find the point 'p' with the lowest y value
      var minY = Number.POSITIVE_INFINITY;
      var p = null;
      _.each( points, function( point ) {
        if ( point.y <= minY ) {
          // if two points have the same y value, take the one with the lowest x
          if ( point.y === minY && p ) {
            if ( point.x < p.x ) {
              p = point;
            }
          } else {
            minY = point.y;
            p = point;
          }
        }
      } );
      
      // sorts the points by their angle. Between 0 and PI
      points = _.sortBy( points, function( point ) {
        return point.minus( p ).angle();
      } );
      
      // remove p from points (relies on the above statement making a defensive copy)
      points.splice( _.indexOf( points, p ), 1 );
      
      // our result array
      var result = [p];
      
      _.each( points, function( point ) {
        // ignore points equal to our starting point
        if ( p.x === point.x && p.y === point.y ) { return; }
        
        function isRightTurn() {
          if ( result.length < 2 ) {
            return false;
          }
          var cross = ccw( result[result.length-2], result[result.length-1], point );
          return includeCollinear ? ( cross < 0 ) : ( cross <= 0 );
        }
        
        while ( isRightTurn() ) {
          result.pop();
        }
        result.push( point );
      } );
      
      return result;
    }
  };
  
  return dot.ConvexHull2;
} );


// Copyright 2002-2014, University of Colorado Boulder

/**
 * Basic width and height
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Dimension2',['require','DOT/dot','DOT/Bounds2'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  require( 'DOT/Bounds2' );
  
  dot.Dimension2 = function Dimension2( width, height ) {
    this.width = width;
    this.height = height;
  };
  var Dimension2 = dot.Dimension2;

  Dimension2.prototype = {
    constructor: Dimension2,

    toString: function() {
      return "[" + this.width + "w, " + this.height + "h]";
    },
    
    toBounds: function( x, y ) {
      x = x || 0;
      y = y || 0;
      return new dot.Bounds2( x, y, this.width + x, this.height + y );
    },

    equals: function( other ) {
      return this.width === other.width && this.height === other.height;
    }
  };
  
  return Dimension2;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Eigensystem decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * Eigenvalues and eigenvectors of a real matrix.
 * <P>
 * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is
 * diagonal and the eigenvector matrix V is orthogonal.
 * I.e. A = V.times(D.times(V.transpose())) and
 * V.times(V.transpose()) equals the identity matrix.
 * <P>
 * If A is not symmetric, then the eigenvalue matrix D is block diagonal
 * with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
 * lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
 * columns of V represent the eigenvectors in the sense that A*V = V*D,
 * i.e. A.times(V) equals V.times(D).  The matrix V may be badly
 * conditioned, or even singular, so the validity of the equation
 * A = V*D*inverse(V) depends upon V.cond().
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/EigenvalueDecomposition',['require','DOT/dot'],function( require ) {
  

  var dot = require( 'DOT/dot' );

  var Float32Array = window.Float32Array || Array;

  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  dot.EigenvalueDecomposition = function EigenvalueDecomposition( matrix ) {
    var i, j;

    var A = matrix.entries;
    this.n = matrix.getColumnDimension(); // Row and column dimension (square matrix).
    var n = this.n;
    this.V = new Float32Array( n * n ); // Array for internal storage of eigenvectors.

    // Arrays for internal storage of eigenvalues.
    this.d = new Float32Array( n );
    this.e = new Float32Array( n );

    this.issymmetric = true;
    for ( j = 0; (j < n) && this.issymmetric; j++ ) {
      for ( i = 0; (i < n) && this.issymmetric; i++ ) {
        this.issymmetric = (A[i * this.n + j] === A[j * this.n + i]);
      }
    }

    if ( this.issymmetric ) {
      for ( i = 0; i < n; i++ ) {
        for ( j = 0; j < n; j++ ) {
          this.V[i * this.n + j] = A[i * this.n + j];
        }
      }

      // Tridiagonalize.
      this.tred2();

      // Diagonalize.
      this.tql2();

    }
    else {
      this.H = new Float32Array( n * n ); // Array for internal storage of nonsymmetric Hessenberg form.
      this.ort = new Float32Array( n ); // // Working storage for nonsymmetric algorithm.

      for ( j = 0; j < n; j++ ) {
        for ( i = 0; i < n; i++ ) {
          this.H[i * this.n + j] = A[i * this.n + j];
        }
      }

      // Reduce to Hessenberg form.
      this.orthes();

      // Reduce Hessenberg to real Schur form.
      this.hqr2();
    }
  };
  var EigenvalueDecomposition = dot.EigenvalueDecomposition;

  EigenvalueDecomposition.prototype = {
    constructor: EigenvalueDecomposition,

    // Return the eigenvector matrix
    getV: function() {
      return this.V.copy();
    },

    // {Array} Return the real parts of the eigenvalues
    getRealEigenvalues: function() {
      return this.d;
    },

    // {Array} Return the imaginary parts of the eigenvalues
    getImagEigenvalues: function() {
      return this.e;
    },

    // Return the block diagonal eigenvalue matrix
    getD: function() {
      var n = this.n, d = this.d, e = this.e;

      var X = new dot.Matrix( n, n );
      var D = X.entries;
      for ( var i = 0; i < n; i++ ) {
        for ( var j = 0; j < n; j++ ) {
          D[i * this.n + j] = 0.0;
        }
        D[i * this.n + i] = d[i];
        if ( e[i] > 0 ) {
          D[i * this.n + i + 1] = e[i];
        }
        else if ( e[i] < 0 ) {
          D[i * this.n + i - 1] = e[i];
        }
      }
      return X;
    },

    // Symmetric Householder reduction to tridiagonal form.
    tred2: function() {
      var n = this.n, V = this.V, d = this.d, e = this.e;
      var i, j, k, f, g, h;

      //  This is derived from the Algol procedures tred2 by
      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutine in EISPACK.

      for ( j = 0; j < n; j++ ) {
        d[j] = V[(n - 1) * n + j];
      }

      // Householder reduction to tridiagonal form.

      for ( i = n - 1; i > 0; i-- ) {

        // Scale to avoid under/overflow.

        var scale = 0.0;
        h = 0.0;
        for ( k = 0; k < i; k++ ) {
          scale = scale + Math.abs( d[k] );
        }
        if ( scale === 0.0 ) {
          e[i] = d[i - 1];
          for ( j = 0; j < i; j++ ) {
            d[j] = V[(i - 1) * n + j];
            V[i * this.n + j] = 0.0;
            V[j * this.n + i] = 0.0;
          }
        }
        else {

          // Generate Householder vector.

          for ( k = 0; k < i; k++ ) {
            d[k] /= scale;
            h += d[k] * d[k];
          }
          f = d[i - 1];
          g = Math.sqrt( h );
          if ( f > 0 ) {
            g = -g;
          }
          e[i] = scale * g;
          h = h - f * g;
          d[i - 1] = f - g;
          for ( j = 0; j < i; j++ ) {
            e[j] = 0.0;
          }

          // Apply similarity transformation to remaining columns.

          for ( j = 0; j < i; j++ ) {
            f = d[j];
            V[j * this.n + i] = f;
            g = e[j] + V[j * n + j] * f;
            for ( k = j + 1; k <= i - 1; k++ ) {
              g += V[k * n + j] * d[k];
              e[k] += V[k * n + j] * f;
            }
            e[j] = g;
          }
          f = 0.0;
          for ( j = 0; j < i; j++ ) {
            e[j] /= h;
            f += e[j] * d[j];
          }
          var hh = f / (h + h);
          for ( j = 0; j < i; j++ ) {
            e[j] -= hh * d[j];
          }
          for ( j = 0; j < i; j++ ) {
            f = d[j];
            g = e[j];
            for ( k = j; k <= i - 1; k++ ) {
              V[k * n + j] -= (f * e[k] + g * d[k]);
            }
            d[j] = V[(i - 1) * n + j];
            V[i * this.n + j] = 0.0;
          }
        }
        d[i] = h;
      }

      // Accumulate transformations.

      for ( i = 0; i < n - 1; i++ ) {
        V[(n - 1) * n + i] = V[i * n + i];
        V[i * n + i] = 1.0;
        h = d[i + 1];
        if ( h !== 0.0 ) {
          for ( k = 0; k <= i; k++ ) {
            d[k] = V[k * n + (i + 1)] / h;
          }
          for ( j = 0; j <= i; j++ ) {
            g = 0.0;
            for ( k = 0; k <= i; k++ ) {
              g += V[k * n + (i + 1)] * V[k * n + j];
            }
            for ( k = 0; k <= i; k++ ) {
              V[k * n + j] -= g * d[k];
            }
          }
        }
        for ( k = 0; k <= i; k++ ) {
          V[k * n + (i + 1)] = 0.0;
        }
      }
      for ( j = 0; j < n; j++ ) {
        d[j] = V[(n - 1) * n + j];
        V[(n - 1) * n + j] = 0.0;
      }
      V[(n - 1) * n + (n - 1)] = 1.0;
      e[0] = 0.0;
    },

    // Symmetric tridiagonal QL algorithm.
    tql2: function() {
      var n = this.n, V = this.V, d = this.d, e = this.e;
      var i, j, k, l, g, p;
      var iter;

      //  This is derived from the Algol procedures tql2, by
      //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
      //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutine in EISPACK.

      for ( i = 1; i < n; i++ ) {
        e[i - 1] = e[i];
      }
      e[n - 1] = 0.0;

      var f = 0.0;
      var tst1 = 0.0;
      var eps = Math.pow( 2.0, -52.0 );
      for ( l = 0; l < n; l++ ) {

        // Find small subdiagonal element

        tst1 = Math.max( tst1, Math.abs( d[l] ) + Math.abs( e[l] ) );
        var m = l;
        while ( m < n ) {
          if ( Math.abs( e[m] ) <= eps * tst1 ) {
            break;
          }
          m++;
        }

        // If m === l, d[l] is an eigenvalue,
        // otherwise, iterate.

        if ( m > l ) {
          iter = 0;
          do {
            iter = iter + 1;  // (Could check iteration count here.)

            // Compute implicit shift

            g = d[l];
            p = (d[l + 1] - g) / (2.0 * e[l]);
            var r = dot.Matrix.hypot( p, 1.0 );
            if ( p < 0 ) {
              r = -r;
            }
            d[l] = e[l] / (p + r);
            d[l + 1] = e[l] * (p + r);
            var dl1 = d[l + 1];
            var h = g - d[l];
            for ( i = l + 2; i < n; i++ ) {
              d[i] -= h;
            }
            f = f + h;

            // Implicit QL transformation.

            p = d[m];
            var c = 1.0;
            var c2 = c;
            var c3 = c;
            var el1 = e[l + 1];
            var s = 0.0;
            var s2 = 0.0;
            for ( i = m - 1; i >= l; i-- ) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[i];
              h = c * p;
              r = dot.Matrix.hypot( p, e[i] );
              e[i + 1] = s * r;
              s = e[i] / r;
              c = p / r;
              p = c * d[i] - s * g;
              d[i + 1] = h + s * (c * g + s * d[i]);

              // Accumulate transformation.

              for ( k = 0; k < n; k++ ) {
                h = V[k * n + (i + 1)];
                V[k * n + (i + 1)] = s * V[k * n + i] + c * h;
                V[k * n + i] = c * V[k * n + i] - s * h;
              }
            }
            p = -s * s2 * c3 * el1 * e[l] / dl1;
            e[l] = s * p;
            d[l] = c * p;

            // Check for convergence.

          } while ( Math.abs( e[l] ) > eps * tst1 );
        }
        d[l] = d[l] + f;
        e[l] = 0.0;
      }

      // Sort eigenvalues and corresponding vectors.

      for ( i = 0; i < n - 1; i++ ) {
        k = i;
        p = d[i];
        for ( j = i + 1; j < n; j++ ) {
          if ( d[j] < p ) {
            k = j;
            p = d[j];
          }
        }
        if ( k !== i ) {
          d[k] = d[i];
          d[i] = p;
          for ( j = 0; j < n; j++ ) {
            p = V[j * this.n + i];
            V[j * this.n + i] = V[j * n + k];
            V[j * n + k] = p;
          }
        }
      }
    },

    // Nonsymmetric reduction to Hessenberg form.
    orthes: function() {
      var n = this.n, V = this.V, H = this.H, ort = this.ort;
      var i, j, m, f, g;

      //  This is derived from the Algol procedures orthes and ortran,
      //  by Martin and Wilkinson, Handbook for Auto. Comp.,
      //  Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutines in EISPACK.

      var low = 0;
      var high = n - 1;

      for ( m = low + 1; m <= high - 1; m++ ) {

        // Scale column.

        var scale = 0.0;
        for ( i = m; i <= high; i++ ) {
          scale = scale + Math.abs( H[i * n + (m - 1)] );
        }
        if ( scale !== 0.0 ) {

          // Compute Householder transformation.

          var h = 0.0;
          for ( i = high; i >= m; i-- ) {
            ort[i] = H[i * n + (m - 1)] / scale;
            h += ort[i] * ort[i];
          }
          g = Math.sqrt( h );
          if ( ort[m] > 0 ) {
            g = -g;
          }
          h = h - ort[m] * g;
          ort[m] = ort[m] - g;

          // Apply Householder similarity transformation
          // H = (I-u*u'/h)*H*(I-u*u')/h)

          for ( j = m; j < n; j++ ) {
            f = 0.0;
            for ( i = high; i >= m; i-- ) {
              f += ort[i] * H[i * this.n + j];
            }
            f = f / h;
            for ( i = m; i <= high; i++ ) {
              H[i * this.n + j] -= f * ort[i];
            }
          }

          for ( i = 0; i <= high; i++ ) {
            f = 0.0;
            for ( j = high; j >= m; j-- ) {
              f += ort[j] * H[i * this.n + j];
            }
            f = f / h;
            for ( j = m; j <= high; j++ ) {
              H[i * this.n + j] -= f * ort[j];
            }
          }
          ort[m] = scale * ort[m];
          H[m * n + (m - 1)] = scale * g;
        }
      }

      // Accumulate transformations (Algol's ortran).

      for ( i = 0; i < n; i++ ) {
        for ( j = 0; j < n; j++ ) {
          V[i * this.n + j] = (i === j ? 1.0 : 0.0);
        }
      }

      for ( m = high - 1; m >= low + 1; m-- ) {
        if ( H[m * n + (m - 1)] !== 0.0 ) {
          for ( i = m + 1; i <= high; i++ ) {
            ort[i] = H[i * n + (m - 1)];
          }
          for ( j = m; j <= high; j++ ) {
            g = 0.0;
            for ( i = m; i <= high; i++ ) {
              g += ort[i] * V[i * this.n + j];
            }
            // Double division avoids possible underflow
            g = (g / ort[m]) / H[m * n + (m - 1)];
            for ( i = m; i <= high; i++ ) {
              V[i * this.n + j] += g * ort[i];
            }
          }
        }
      }
    },

    // Complex scalar division.
    cdiv: function( xr, xi, yr, yi ) {
      var r, d;
      if ( Math.abs( yr ) > Math.abs( yi ) ) {
        r = yi / yr;
        d = yr + r * yi;
        this.cdivr = (xr + r * xi) / d;
        this.cdivi = (xi - r * xr) / d;
      }
      else {
        r = yr / yi;
        d = yi + r * yr;
        this.cdivr = (r * xr + xi) / d;
        this.cdivi = (r * xi - xr) / d;
      }
    },

    // Nonsymmetric reduction from Hessenberg to real Schur form.
    hqr2: function() {
      var n, V = this.V, d = this.d, e = this.e, H = this.H;
      var i, j, k, l, m;
      var iter;

      //  This is derived from the Algol procedure hqr2,
      //  by Martin and Wilkinson, Handbook for Auto. Comp.,
      //  Vol.ii-Linear Algebra, and the corresponding
      //  Fortran subroutine in EISPACK.

      // Initialize

      var nn = this.n;
      n = nn - 1;
      var low = 0;
      var high = nn - 1;
      var eps = Math.pow( 2.0, -52.0 );
      var exshift = 0.0;
      var p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;

      // Store roots isolated by balanc and compute matrix norm

      var norm = 0.0;
      for ( i = 0; i < nn; i++ ) {
        if ( i < low || i > high ) {
          d[i] = H[i * n + i];
          e[i] = 0.0;
        }
        for ( j = Math.max( i - 1, 0 ); j < nn; j++ ) {
          norm = norm + Math.abs( H[i * this.n + j] );
        }
      }

      // Outer loop over eigenvalue index

      iter = 0;
      while ( n >= low ) {

        // Look for single small sub-diagonal element

        l = n;
        while ( l > low ) {
          s = Math.abs( H[(l - 1) * n + (l - 1)] ) + Math.abs( H[l * n + l] );
          if ( s === 0.0 ) {
            s = norm;
          }
          if ( Math.abs( H[l * n + (l - 1)] ) < eps * s ) {
            break;
          }
          l--;
        }

        // Check for convergence
        // One root found

        if ( l === n ) {
          H[n * n + n] = H[n * n + n] + exshift;
          d[n] = H[n * n + n];
          e[n] = 0.0;
          n--;
          iter = 0;

          // Two roots found

        }
        else if ( l === n - 1 ) {
          w = H[n * n + n - 1] * H[(n - 1) * n + n];
          p = (H[(n - 1) * n + (n - 1)] - H[n * n + n]) / 2.0;
          q = p * p + w;
          z = Math.sqrt( Math.abs( q ) );
          H[n * n + n] = H[n * n + n] + exshift;
          H[(n - 1) * n + (n - 1)] = H[(n - 1) * n + (n - 1)] + exshift;
          x = H[n * n + n];

          // Real pair

          if ( q >= 0 ) {
            if ( p >= 0 ) {
              z = p + z;
            }
            else {
              z = p - z;
            }
            d[n - 1] = x + z;
            d[n] = d[n - 1];
            if ( z !== 0.0 ) {
              d[n] = x - w / z;
            }
            e[n - 1] = 0.0;
            e[n] = 0.0;
            x = H[n * n + n - 1];
            s = Math.abs( x ) + Math.abs( z );
            p = x / s;
            q = z / s;
            r = Math.sqrt( p * p + q * q );
            p = p / r;
            q = q / r;

            // Row modification

            for ( j = n - 1; j < nn; j++ ) {
              z = H[(n - 1) * n + j];
              H[(n - 1) * n + j] = q * z + p * H[n * n + j];
              H[n * n + j] = q * H[n * n + j] - p * z;
            }

            // Column modification

            for ( i = 0; i <= n; i++ ) {
              z = H[i * n + n - 1];
              H[i * n + n - 1] = q * z + p * H[i * n + n];
              H[i * n + n] = q * H[i * n + n] - p * z;
            }

            // Accumulate transformations

            for ( i = low; i <= high; i++ ) {
              z = V[i * n + n - 1];
              V[i * n + n - 1] = q * z + p * V[i * n + n];
              V[i * n + n] = q * V[i * n + n] - p * z;
            }

            // Complex pair

          }
          else {
            d[n - 1] = x + p;
            d[n] = x + p;
            e[n - 1] = z;
            e[n] = -z;
          }
          n = n - 2;
          iter = 0;

          // No convergence yet

        }
        else {

          // Form shift

          x = H[n * n + n];
          y = 0.0;
          w = 0.0;
          if ( l < n ) {
            y = H[(n - 1) * n + (n - 1)];
            w = H[n * n + n - 1] * H[(n - 1) * n + n];
          }

          // Wilkinson's original ad hoc shift

          if ( iter === 10 ) {
            exshift += x;
            for ( i = low; i <= n; i++ ) {
              H[i * n + i] -= x;
            }
            s = Math.abs( H[n * n + n - 1] ) + Math.abs( H[(n - 1) * n + n - 2] );
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }

          // MATLAB's new ad hoc shift

          if ( iter === 30 ) {
            s = (y - x) / 2.0;
            s = s * s + w;
            if ( s > 0 ) {
              s = Math.sqrt( s );
              if ( y < x ) {
                s = -s;
              }
              s = x - w / ((y - x) / 2.0 + s);
              for ( i = low; i <= n; i++ ) {
                H[i * n + i] -= s;
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }

          iter = iter + 1;   // (Could check iteration count here.)

          // Look for two consecutive small sub-diagonal elements

          m = n - 2;
          while ( m >= l ) {
            z = H[m * n + m];
            r = x - z;
            s = y - z;
            p = (r * s - w) / H[(m + 1) * n + m] + H[m * n + m + 1];
            q = H[(m + 1) * n + m + 1] - z - r - s;
            r = H[(m + 2) * n + m + 1];
            s = Math.abs( p ) + Math.abs( q ) + Math.abs( r );
            p = p / s;
            q = q / s;
            r = r / s;
            if ( m === l ) {
              break;
            }
            if ( Math.abs( H[m * n + (m - 1)] ) * (Math.abs( q ) + Math.abs( r )) <
                 eps * (Math.abs( p ) * (Math.abs( H[(m - 1) * n + m - 1] ) + Math.abs( z ) +
                                         Math.abs( H[(m + 1) * n + m + 1] ))) ) {
              break;
            }
            m--;
          }

          for ( i = m + 2; i <= n; i++ ) {
            H[i * n + i - 2] = 0.0;
            if ( i > m + 2 ) {
              H[i * n + i - 3] = 0.0;
            }
          }

          // Double QR step involving rows l:n and columns m:n

          for ( k = m; k <= n - 1; k++ ) {
            var notlast = (k !== n - 1);
            if ( k !== m ) {
              p = H[k * n + k - 1];
              q = H[(k + 1) * n + k - 1];
              r = (notlast ? H[(k + 2) * n + k - 1] : 0.0);
              x = Math.abs( p ) + Math.abs( q ) + Math.abs( r );
              if ( x !== 0.0 ) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }
            if ( x === 0.0 ) {
              break;
            }
            s = Math.sqrt( p * p + q * q + r * r );
            if ( p < 0 ) {
              s = -s;
            }
            if ( s !== 0 ) {
              if ( k !== m ) {
                H[k * n + k - 1] = -s * x;
              }
              else if ( l !== m ) {
                H[k * n + k - 1] = -H[k * n + k - 1];
              }
              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;

              // Row modification

              for ( j = k; j < nn; j++ ) {
                p = H[k * n + j] + q * H[(k + 1) * n + j];
                if ( notlast ) {
                  p = p + r * H[(k + 2) * n + j];
                  H[(k + 2) * n + j] = H[(k + 2) * n + j] - p * z;
                }
                H[k * n + j] = H[k * n + j] - p * x;
                H[(k + 1) * n + j] = H[(k + 1) * n + j] - p * y;
              }

              // Column modification

              for ( i = 0; i <= Math.min( n, k + 3 ); i++ ) {
                p = x * H[i * n + k] + y * H[i * n + k + 1];
                if ( notlast ) {
                  p = p + z * H[i * n + k + 2];
                  H[i * n + k + 2] = H[i * n + k + 2] - p * r;
                }
                H[i * n + k] = H[i * n + k] - p;
                H[i * n + k + 1] = H[i * n + k + 1] - p * q;
              }

              // Accumulate transformations

              for ( i = low; i <= high; i++ ) {
                p = x * V[i * n + k] + y * V[i * n + k + 1];
                if ( notlast ) {
                  p = p + z * V[i * n + k + 2];
                  V[i * n + k + 2] = V[i * n + k + 2] - p * r;
                }
                V[i * n + k] = V[i * n + k] - p;
                V[i * n + k + 1] = V[i * n + k + 1] - p * q;
              }
            }  // (s !== 0)
          }  // k loop
        }  // check convergence
      }  // while (n >= low)

      // Backsubstitute to find vectors of upper triangular form

      if ( norm === 0.0 ) {
        return;
      }

      for ( n = nn - 1; n >= 0; n-- ) {
        p = d[n];
        q = e[n];

        // Real vector

        if ( q === 0 ) {
          l = n;
          H[n * n + n] = 1.0;
          for ( i = n - 1; i >= 0; i-- ) {
            w = H[i * n + i] - p;
            r = 0.0;
            for ( j = l; j <= n; j++ ) {
              r = r + H[i * this.n + j] * H[j * n + n];
            }
            if ( e[i] < 0.0 ) {
              z = w;
              s = r;
            }
            else {
              l = i;
              if ( e[i] === 0.0 ) {
                if ( w !== 0.0 ) {
                  H[i * n + n] = -r / w;
                }
                else {
                  H[i * n + n] = -r / (eps * norm);
                }

                // Solve real equations

              }
              else {
                x = H[i * n + i + 1];
                y = H[(i + 1) * n + i];
                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                t = (x * s - z * r) / q;
                H[i * n + n] = t;
                if ( Math.abs( x ) > Math.abs( z ) ) {
                  H[(i + 1) * n + n] = (-r - w * t) / x;
                }
                else {
                  H[(i + 1) * n + n] = (-s - y * t) / z;
                }
              }

              // Overflow control

              t = Math.abs( H[i * n + n] );
              if ( (eps * t) * t > 1 ) {
                for ( j = i; j <= n; j++ ) {
                  H[j * n + n] = H[j * n + n] / t;
                }
              }
            }
          }

          // Complex vector

        }
        else if ( q < 0 ) {
          l = n - 1;

          // Last vector component imaginary so matrix is triangular

          if ( Math.abs( H[n * n + n - 1] ) > Math.abs( H[(n - 1) * n + n] ) ) {
            H[(n - 1) * n + (n - 1)] = q / H[n * n + n - 1];
            H[(n - 1) * n + n] = -(H[n * n + n] - p) / H[n * n + n - 1];
          }
          else {
            this.cdiv( 0.0, -H[(n - 1) * n + n], H[(n - 1) * n + (n - 1)] - p, q );
            H[(n - 1) * n + (n - 1)] = this.cdivr;
            H[(n - 1) * n + n] = this.cdivi;
          }
          H[n * n + n - 1] = 0.0;
          H[n * n + n] = 1.0;
          for ( i = n - 2; i >= 0; i-- ) {
            var ra, sa, vr, vi;
            ra = 0.0;
            sa = 0.0;
            for ( j = l; j <= n; j++ ) {
              ra = ra + H[i * this.n + j] * H[j * n + n - 1];
              sa = sa + H[i * this.n + j] * H[j * n + n];
            }
            w = H[i * n + i] - p;

            if ( e[i] < 0.0 ) {
              z = w;
              r = ra;
              s = sa;
            }
            else {
              l = i;
              if ( e[i] === 0 ) {
                this.cdiv( -ra, -sa, w, q );
                H[i * n + n - 1] = this.cdivr;
                H[i * n + n] = this.cdivi;
              }
              else {

                // Solve complex equations

                x = H[i * n + i + 1];
                y = H[(i + 1) * n + i];
                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                vi = (d[i] - p) * 2.0 * q;
                if ( vr === 0.0 && vi === 0.0 ) {
                  vr = eps * norm * (Math.abs( w ) + Math.abs( q ) +
                                     Math.abs( x ) + Math.abs( y ) + Math.abs( z ));
                }
                this.cdiv( x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi );
                H[i * n + n - 1] = this.cdivr;
                H[i * n + n] = this.cdivi;
                if ( Math.abs( x ) > (Math.abs( z ) + Math.abs( q )) ) {
                  H[(i + 1) * n + n - 1] = (-ra - w * H[i * n + n - 1] + q * H[i * n + n]) / x;
                  H[(i + 1) * n + n] = (-sa - w * H[i * n + n] - q * H[i * n + n - 1]) / x;
                }
                else {
                  this.cdiv( -r - y * H[i * n + n - 1], -s - y * H[i * n + n], z, q );
                  H[(i + 1) * n + n - 1] = this.cdivr;
                  H[(i + 1) * n + n] = this.cdivi;
                }
              }

              // Overflow control
              t = Math.max( Math.abs( H[i * n + n - 1] ), Math.abs( H[i * n + n] ) );
              if ( (eps * t) * t > 1 ) {
                for ( j = i; j <= n; j++ ) {
                  H[j * n + n - 1] = H[j * n + n - 1] / t;
                  H[j * n + n] = H[j * n + n] / t;
                }
              }
            }
          }
        }
      }

      // Vectors of isolated roots
      for ( i = 0; i < nn; i++ ) {
        if ( i < low || i > high ) {
          for ( j = i; j < nn; j++ ) {
            V[i * this.n + j] = H[i * this.n + j];
          }
        }
      }

      // Back transformation to get eigenvectors of original matrix
      for ( j = nn - 1; j >= low; j-- ) {
        for ( i = low; i <= high; i++ ) {
          z = 0.0;
          for ( k = low; k <= Math.min( j, high ); k++ ) {
            z = z + V[i * n + k] * H[k * n + j];
          }
          V[i * this.n + j] = z;
        }
      }
    }
  };
  
  return EigenvalueDecomposition;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Function for doing a linear mapping between two domains ('a' and 'b').
 * <p>
 * Example usage:
 * <code>
 * var f = new dot.LinearFunction( 0, 100, 0, 200 );
 * f( 50 ); // 100
 * f.inverse( 100 ); // 50
 * </code>
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  // imports
  require( 'DOT/Util' );
  
  /**
   * @param {Number} a1
   * @param {Number} a2
   * @param {Number} b1
   * @param {Number} b2
   * @param {Boolean} clamp clamp the result to the provided ranges, false by default
   * @constructor
   */
  dot.LinearFunction = function LinearFunction( a1, a2, b1, b2, clamp ) {
    
    clamp = _.isUndefined( clamp ) ? false : clamp;

    /*
     * Linearly interpolate two points and evaluate the line equation for a third point.
     * f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>
     * Optionally clamp the result to the range [b1,b2].
     */
    var map = function( a1, a2, b1, b2, a3, clamp ) {
      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );
      if ( clamp ) {
        var max = Math.max( b1, b2 );
        var min = Math.min( b1, b2 );
        b3 = dot.Util.clamp( b3, min, max );
      }
      return b3;
    };
    
    // Maps from a to b.
    var evaluate = function( a3 ) {
      return map( a1, a2, b1, b2, a3, clamp );
    };

    // Maps from b to a.
    evaluate.inverse = function( b3 ) {
      return map( b1, b2, a1, a2, b3, clamp );
    };
    
    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)
  };
  
  return dot.LinearFunction;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * LU decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/LUDecomposition',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var Float32Array = window.Float32Array || Array;
  
  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  dot.LUDecomposition = function LUDecomposition( matrix ) {
    var i, j, k;

    this.matrix = matrix;

    // TODO: size!
    this.LU = matrix.getArrayCopy();
    var LU = this.LU;
    this.m = matrix.getRowDimension();
    var m = this.m;
    this.n = matrix.getColumnDimension();
    var n = this.n;
    this.piv = new Uint32Array( m );
    for ( i = 0; i < m; i++ ) {
      this.piv[i] = i;
    }
    this.pivsign = 1;
    var LUcolj = new Float32Array( m );

    // Outer loop.

    for ( j = 0; j < n; j++ ) {

      // Make a copy of the j-th column to localize references.
      for ( i = 0; i < m; i++ ) {
        LUcolj[i] = LU[matrix.index( i, j )];
      }

      // Apply previous transformations.

      for ( i = 0; i < m; i++ ) {
        // Most of the time is spent in the following dot product.
        var kmax = Math.min( i, j );
        var s = 0.0;
        for ( k = 0; k < kmax; k++ ) {
          var ik = matrix.index( i, k );
          s += LU[ik] * LUcolj[k];
        }

        LUcolj[i] -= s;
        LU[matrix.index( i, j )] = LUcolj[i];
      }

      // Find pivot and exchange if necessary.

      var p = j;
      for ( i = j + 1; i < m; i++ ) {
        if ( Math.abs( LUcolj[i] ) > Math.abs( LUcolj[p] ) ) {
          p = i;
        }
      }
      if ( p !== j ) {
        for ( k = 0; k < n; k++ ) {
          var pk = matrix.index( p, k );
          var jk = matrix.index( j, k );
          var t = LU[pk];
          LU[pk] = LU[jk];
          LU[jk] = t;
        }
        k = this.piv[p];
        this.piv[p] = this.piv[j];
        this.piv[j] = k;
        this.pivsign = -this.pivsign;
      }

      // Compute multipliers.

      if ( j < m && LU[this.matrix.index( j, j )] !== 0.0 ) {
        for ( i = j + 1; i < m; i++ ) {
          LU[matrix.index( i, j )] /= LU[matrix.index( j, j )];
        }
      }
    }
  };
  var LUDecomposition = dot.LUDecomposition;

  LUDecomposition.prototype = {
    constructor: LUDecomposition,

    isNonsingular: function() {
      for ( var j = 0; j < this.n; j++ ) {
        var index = this.matrix.index( j, j );
        if ( this.LU[index] === 0 ) {
          return false;
        }
      }
      return true;
    },

    getL: function() {
      var result = new dot.Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i > j ) {
            result.entries[result.index( i, j )] = this.LU[this.matrix.index( i, j )];
          }
          else if ( i === j ) {
            result.entries[result.index( i, j )] = 1.0;
          }
          else {
            result.entries[result.index( i, j )] = 0.0;
          }
        }
      }
      return result;
    },

    getU: function() {
      var result = new dot.Matrix( this.n, this.n );
      for ( var i = 0; i < this.n; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i <= j ) {
            result.entries[result.index( i, j )] = this.LU[this.matrix.index( i, j )];
          }
          else {
            result.entries[result.index( i, j )] = 0.0;
          }
        }
      }
      return result;
    },

    getPivot: function() {
      var p = new Uint32Array( this.m );
      for ( var i = 0; i < this.m; i++ ) {
        p[i] = this.piv[i];
      }
      return p;
    },

    getDoublePivot: function() {
      var vals = new Float32Array( this.m );
      for ( var i = 0; i < this.m; i++ ) {
        vals[i] = this.piv[i];
      }
      return vals;
    },

    det: function() {
      if ( this.m !== this.n ) {
        throw new Error( "Matrix must be square." );
      }
      var d = this.pivsign;
      for ( var j = 0; j < this.n; j++ ) {
        d *= this.LU[this.matrix.index( j, j )];
      }
      return d;
    },

    solve: function( matrix ) {
      var i, j, k;
      if ( matrix.getRowDimension() !== this.m ) {
        throw new Error( "Matrix row dimensions must agree." );
      }
      if ( !this.isNonsingular() ) {
        throw new Error( "Matrix is singular." );
      }

      // Copy right hand side with pivoting
      var nx = matrix.getColumnDimension();
      var Xmat = matrix.getArrayRowMatrix( this.piv, 0, nx - 1 );

      // Solve L*Y = B(piv,:)
      for ( k = 0; k < this.n; k++ ) {
        for ( i = k + 1; i < this.n; i++ ) {
          for ( j = 0; j < nx; j++ ) {
            Xmat.entries[Xmat.index( i, j )] -= Xmat.entries[Xmat.index( k, j )] * this.LU[this.matrix.index( i, k )];
          }
        }
      }

      // Solve U*X = Y;
      for ( k = this.n - 1; k >= 0; k-- ) {
        for ( j = 0; j < nx; j++ ) {
          Xmat.entries[Xmat.index( k, j )] /= this.LU[this.matrix.index( k, k )];
        }
        for ( i = 0; i < k; i++ ) {
          for ( j = 0; j < nx; j++ ) {
            Xmat.entries[Xmat.index( i, j )] -= Xmat.entries[Xmat.index( k, j )] * this.LU[this.matrix.index( i, k )];
          }
        }
      }
      return Xmat;
    }
  };
  
  return LUDecomposition;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Tests whether a reference is to an array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/isArray',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  var isArray = core.isArray = function isArray( array ) {
    // yes, this is actually how to do this. see http://stackoverflow.com/questions/4775722/javascript-check-if-object-is-array
    return Object.prototype.toString.call( array ) === '[object Array]';
  };
  return isArray;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * SVD decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/SingularValueDecomposition',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var Float32Array = window.Float32Array || Array;
  
  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  dot.SingularValueDecomposition = function SingularValueDecomposition( matrix ) {
    this.matrix = matrix;

    var Arg = matrix;

    // Derived from LINPACK code.
    // Initialize.
    var A = Arg.getArrayCopy();
    this.m = Arg.getRowDimension();
    this.n = Arg.getColumnDimension();
    var m = this.m;
    var n = this.n;

    var min = Math.min;
    var max = Math.max;
    var pow = Math.pow;
    var abs = Math.abs;

    /* Apparently the failing cases are only a proper subset of (m<n),
     so let's not throw error.  Correct fix to come later?
     if (m<n) {
     throw new IllegalArgumentException("Jama SVD only works for m >= n"); }
     */
    var nu = min( m, n );
    this.s = new Float32Array( min( m + 1, n ) );
    var s = this.s;
    this.U = new Float32Array( m * nu );
    var U = this.U;
    this.V = new Float32Array( n * n );
    var V = this.V;
    var e = new Float32Array( n );
    var work = new Float32Array( m );
    var wantu = true;
    var wantv = true;

    var i, j, k, t, f;
    var cs,sn;

    var hypot = dot.Matrix.hypot;

    // Reduce A to bidiagonal form, storing the diagonal elements
    // in s and the super-diagonal elements in e.

    var nct = min( m - 1, n );
    var nrt = max( 0, min( n - 2, m ) );
    for ( k = 0; k < max( nct, nrt ); k++ ) {
      if ( k < nct ) {

        // Compute the transformation for the k-th column and
        // place the k-th diagonal in s[k].
        // Compute 2-norm of k-th column without under/overflow.
        s[k] = 0;
        for ( i = k; i < m; i++ ) {
          s[k] = hypot( s[k], A[i * n + k] );
        }
        if ( s[k] !== 0.0 ) {
          if ( A[k * n + k] < 0.0 ) {
            s[k] = -s[k];
          }
          for ( i = k; i < m; i++ ) {
            A[i * n + k] /= s[k];
          }
          A[k * n + k] += 1.0;
        }
        s[k] = -s[k];
      }
      for ( j = k + 1; j < n; j++ ) {
        if ( (k < nct) && (s[k] !== 0.0) ) {

          // Apply the transformation.

          t = 0;
          for ( i = k; i < m; i++ ) {
            t += A[i * n + k] * A[i * n + j];
          }
          t = -t / A[k * n + k];
          for ( i = k; i < m; i++ ) {
            A[i * n + j] += t * A[i * n + k];
          }
        }

        // Place the k-th row of A into e for the
        // subsequent calculation of the row transformation.

        e[j] = A[k * n + j];
      }
      if ( wantu && (k < nct) ) {

        // Place the transformation in U for subsequent back
        // multiplication.

        for ( i = k; i < m; i++ ) {
          U[i * nu + k] = A[i * n + k];
        }
      }
      if ( k < nrt ) {

        // Compute the k-th row transformation and place the
        // k-th super-diagonal in e[k].
        // Compute 2-norm without under/overflow.
        e[k] = 0;
        for ( i = k + 1; i < n; i++ ) {
          e[k] = hypot( e[k], e[i] );
        }
        if ( e[k] !== 0.0 ) {
          if ( e[k + 1] < 0.0 ) {
            e[k] = -e[k];
          }
          for ( i = k + 1; i < n; i++ ) {
            e[i] /= e[k];
          }
          e[k + 1] += 1.0;
        }
        e[k] = -e[k];
        if ( (k + 1 < m) && (e[k] !== 0.0) ) {

          // Apply the transformation.

          for ( i = k + 1; i < m; i++ ) {
            work[i] = 0.0;
          }
          for ( j = k + 1; j < n; j++ ) {
            for ( i = k + 1; i < m; i++ ) {
              work[i] += e[j] * A[i * n + j];
            }
          }
          for ( j = k + 1; j < n; j++ ) {
            t = -e[j] / e[k + 1];
            for ( i = k + 1; i < m; i++ ) {
              A[i * n + j] += t * work[i];
            }
          }
        }
        if ( wantv ) {

          // Place the transformation in V for subsequent
          // back multiplication.

          for ( i = k + 1; i < n; i++ ) {
            V[i * n + k] = e[i];
          }
        }
      }
    }

    // Set up the final bidiagonal matrix or order p.

    var p = min( n, m + 1 );
    if ( nct < n ) {
      s[nct] = A[nct * n + nct];
    }
    if ( m < p ) {
      s[p - 1] = 0.0;
    }
    if ( nrt + 1 < p ) {
      e[nrt] = A[nrt * n + p - 1];
    }
    e[p - 1] = 0.0;

    // If required, generate U.

    if ( wantu ) {
      for ( j = nct; j < nu; j++ ) {
        for ( i = 0; i < m; i++ ) {
          U[i * nu + j] = 0.0;
        }
        U[j * nu + j] = 1.0;
      }
      for ( k = nct - 1; k >= 0; k-- ) {
        if ( s[k] !== 0.0 ) {
          for ( j = k + 1; j < nu; j++ ) {
            t = 0;
            for ( i = k; i < m; i++ ) {
              t += U[i * nu + k] * U[i * nu + j];
            }
            t = -t / U[k * nu + k];
            for ( i = k; i < m; i++ ) {
              U[i * nu + j] += t * U[i * nu + k];
            }
          }
          for ( i = k; i < m; i++ ) {
            U[i * nu + k] = -U[i * nu + k];
          }
          U[k * nu + k] = 1.0 + U[k * nu + k];
          for ( i = 0; i < k - 1; i++ ) {
            U[i * nu + k] = 0.0;
          }
        }
        else {
          for ( i = 0; i < m; i++ ) {
            U[i * nu + k] = 0.0;
          }
          U[k * nu + k] = 1.0;
        }
      }
    }

    // If required, generate V.

    if ( wantv ) {
      for ( k = n - 1; k >= 0; k-- ) {
        if ( (k < nrt) && (e[k] !== 0.0) ) {
          for ( j = k + 1; j < nu; j++ ) {
            t = 0;
            for ( i = k + 1; i < n; i++ ) {
              t += V[i * n + k] * V[i * n + j];
            }
            t = -t / V[(k + 1) * n + k];
            for ( i = k + 1; i < n; i++ ) {
              V[i * n + j] += t * V[i * n + k];
            }
          }
        }
        for ( i = 0; i < n; i++ ) {
          V[i * n + k] = 0.0;
        }
        V[k * n + k] = 1.0;
      }
    }

    // Main iteration loop for the singular values.

    var pp = p - 1;
    var iter = 0;
    var eps = pow( 2.0, -52.0 );
    var tiny = pow( 2.0, -966.0 );
    while ( p > 0 ) {
      var kase;

      // Here is where a test for too many iterations would go.

      // This section of the program inspects for
      // negligible elements in the s and e arrays.  On
      // completion the variables kase and k are set as follows.

      // kase = 1   if s(p) and e[k-1] are negligible and k<p
      // kase = 2   if s(k) is negligible and k<p
      // kase = 3   if e[k-1] is negligible, k<p, and
      //        s(k), ..., s(p) are not negligible (qr step).
      // kase = 4   if e(p-1) is negligible (convergence).

      for ( k = p - 2; k >= -1; k-- ) {
        if ( k === -1 ) {
          break;
        }
        if ( abs( e[k] ) <=
           tiny + eps * (abs( s[k] ) + abs( s[k + 1] )) ) {
          e[k] = 0.0;
          break;
        }
      }
      if ( k === p - 2 ) {
        kase = 4;
      }
      else {
        var ks;
        for ( ks = p - 1; ks >= k; ks-- ) {
          if ( ks === k ) {
            break;
          }
          t = (ks !== p ? abs( e[ks] ) : 0) +
            (ks !== k + 1 ? abs( e[ks - 1] ) : 0);
          if ( abs( s[ks] ) <= tiny + eps * t ) {
            s[ks] = 0.0;
            break;
          }
        }
        if ( ks === k ) {
          kase = 3;
        }
        else if ( ks === p - 1 ) {
          kase = 1;
        }
        else {
          kase = 2;
          k = ks;
        }
      }
      k++;

      // Perform the task indicated by kase.

      switch( kase ) {

        // Deflate negligible s(p).

        case 1:
        {
          f = e[p - 2];
          e[p - 2] = 0.0;
          for ( j = p - 2; j >= k; j-- ) {
            t = hypot( s[j], f );
            cs = s[j] / t;
            sn = f / t;
            s[j] = t;
            if ( j !== k ) {
              f = -sn * e[j - 1];
              e[j - 1] = cs * e[j - 1];
            }
            if ( wantv ) {
              for ( i = 0; i < n; i++ ) {
                t = cs * V[i * n + j] + sn * V[i * n + p - 1];
                V[i * n + p - 1] = -sn * V[i * n + j] + cs * V[i * n + p - 1];
                V[i * n + j] = t;
              }
            }
          }
        }
          break;

        // Split at negligible s(k).

        case 2:
        {
          f = e[k - 1];
          e[k - 1] = 0.0;
          for ( j = k; j < p; j++ ) {
            t = hypot( s[j], f );
            cs = s[j] / t;
            sn = f / t;
            s[j] = t;
            f = -sn * e[j];
            e[j] = cs * e[j];
            if ( wantu ) {
              for ( i = 0; i < m; i++ ) {
                t = cs * U[i * nu + j] + sn * U[i * nu + k - 1];
                U[i * nu + k - 1] = -sn * U[i * nu + j] + cs * U[i * nu + k - 1];
                U[i * nu + j] = t;
              }
            }
          }
        }
          break;

        // Perform one qr step.

        case 3:
        {

          // Calculate the shift.

          var scale = max( max( max( max(
              abs( s[p - 1] ), abs( s[p - 2] ) ), abs( e[p - 2] ) ),
                          abs( s[k] ) ), abs( e[k] ) );
          var sp = s[p - 1] / scale;
          var spm1 = s[p - 2] / scale;
          var epm1 = e[p - 2] / scale;
          var sk = s[k] / scale;
          var ek = e[k] / scale;
          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
          var c = (sp * epm1) * (sp * epm1);
          var shift = 0.0;
          if ( (b !== 0.0) || (c !== 0.0) ) {
            shift = Math.sqrt( b * b + c );
            if ( b < 0.0 ) {
              shift = -shift;
            }
            shift = c / (b + shift);
          }
          f = (sk + sp) * (sk - sp) + shift;
          var g = sk * ek;

          // Chase zeros.

          for ( j = k; j < p - 1; j++ ) {
            t = hypot( f, g );
            cs = f / t;
            sn = g / t;
            if ( j !== k ) {
              e[j - 1] = t;
            }
            f = cs * s[j] + sn * e[j];
            e[j] = cs * e[j] - sn * s[j];
            g = sn * s[j + 1];
            s[j + 1] = cs * s[j + 1];
            if ( wantv ) {
              for ( i = 0; i < n; i++ ) {
                t = cs * V[i * n + j] + sn * V[i * n + j + 1];
                V[i * n + j + 1] = -sn * V[i * n + j] + cs * V[i * n + j + 1];
                V[i * n + j] = t;
              }
            }
            t = hypot( f, g );
            cs = f / t;
            sn = g / t;
            s[j] = t;
            f = cs * e[j] + sn * s[j + 1];
            s[j + 1] = -sn * e[j] + cs * s[j + 1];
            g = sn * e[j + 1];
            e[j + 1] = cs * e[j + 1];
            if ( wantu && (j < m - 1) ) {
              for ( i = 0; i < m; i++ ) {
                t = cs * U[i * nu + j] + sn * U[i * nu + j + 1];
                U[i * nu + j + 1] = -sn * U[i * nu + j] + cs * U[i * nu + j + 1];
                U[i * nu + j] = t;
              }
            }
          }
          e[p - 2] = f;
          iter = iter + 1;
        }
          break;

        // Convergence.

        case 4:
        {

          // Make the singular values positive.

          if ( s[k] <= 0.0 ) {
            s[k] = (s[k] < 0.0 ? -s[k] : 0.0);
            if ( wantv ) {
              for ( i = 0; i <= pp; i++ ) {
                V[i * n + k] = -V[i * n + k];
              }
            }
          }

          // Order the singular values.

          while ( k < pp ) {
            if ( s[k] >= s[k + 1] ) {
              break;
            }
            t = s[k];
            s[k] = s[k + 1];
            s[k + 1] = t;
            if ( wantv && (k < n - 1) ) {
              for ( i = 0; i < n; i++ ) {
                t = V[i * n + k + 1];
                V[i * n + k + 1] = V[i * n + k];
                V[i * n + k] = t;
              }
            }
            if ( wantu && (k < m - 1) ) {
              for ( i = 0; i < m; i++ ) {
                t = U[i * nu + k + 1];
                U[i * nu + k + 1] = U[i * nu + k];
                U[i * nu + k] = t;
              }
            }
            k++;
          }
          iter = 0;
          p--;
        }
          break;
      }
    }
  };
  var SingularValueDecomposition = dot.SingularValueDecomposition;

  SingularValueDecomposition.prototype = {
    constructor: SingularValueDecomposition,

    getU: function() {
      return new dot.Matrix( this.m, Math.min( this.m + 1, this.n ), this.U, true ); // the "fast" flag added, since U is Float32Array
    },

    getV: function() {
      return new dot.Matrix( this.n, this.n, this.V, true );
    },

    getSingularValues: function() {
      return this.s;
    },

    getS: function() {
      var result = new dot.Matrix( this.n, this.n );
      for ( var i = 0; i < this.n; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          result.entries[result.index( i, j )] = 0.0;
        }
        result.entries[result.index( i, i )] = this.s[i];
      }
      return result;
    },

    norm2: function() {
      return this.s[0];
    },

    cond: function() {
      return this.s[0] / this.s[Math.min( this.m, this.n ) - 1];
    },

    rank: function() {
      // changed to 23 from 52 (bits of mantissa), since we are using floats here!
      var eps = Math.pow( 2.0, -23.0 );
      var tol = Math.max( this.m, this.n ) * this.s[0] * eps;
      var r = 0;
      for ( var i = 0; i < this.s.length; i++ ) {
        if ( this.s[i] > tol ) {
          r++;
        }
      }
      return r;
    }
  };
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * QR decomposition, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/QRDecomposition',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var Float32Array = window.Float32Array || Array;
  
  // require( 'DOT/Matrix' ); // commented out so Require.js doesn't complain about the circular dependency

  dot.QRDecomposition = function QRDecomposition( matrix ) {
    this.matrix = matrix;

    // TODO: size!
    this.QR = matrix.getArrayCopy();
    var QR = this.QR;
    this.m = matrix.getRowDimension();
    var m = this.m;
    this.n = matrix.getColumnDimension();
    var n = this.n;

    this.Rdiag = new Float32Array( n );

    var i, j, k;

    // Main loop.
    for ( k = 0; k < n; k++ ) {
      // Compute 2-norm of k-th column without under/overflow.
      var nrm = 0;
      for ( i = k; i < m; i++ ) {
        nrm = dot.Matrix.hypot( nrm, QR[this.matrix.index( i, k )] );
      }

      if ( nrm !== 0.0 ) {
        // Form k-th Householder vector.
        if ( QR[this.matrix.index( k, k )] < 0 ) {
          nrm = -nrm;
        }
        for ( i = k; i < m; i++ ) {
          QR[this.matrix.index( i, k )] /= nrm;
        }
        QR[this.matrix.index( k, k )] += 1.0;

        // Apply transformation to remaining columns.
        for ( j = k + 1; j < n; j++ ) {
          var s = 0.0;
          for ( i = k; i < m; i++ ) {
            s += QR[this.matrix.index( i, k )] * QR[this.matrix.index( i, j )];
          }
          s = -s / QR[this.matrix.index( k, k )];
          for ( i = k; i < m; i++ ) {
            QR[this.matrix.index( i, j )] += s * QR[this.matrix.index( i, k )];
          }
        }
      }
      this.Rdiag[k] = -nrm;
    }
  };
  var QRDecomposition = dot.QRDecomposition;

  QRDecomposition.prototype = {
    constructor: QRDecomposition,

    isFullRank: function() {
      for ( var j = 0; j < this.n; j++ ) {
        if ( this.Rdiag[j] === 0 ) {
          return false;
        }
      }
      return true;
    },

    getH: function() {
      var result = new dot.Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i >= j ) {
            result.entries[result.index( i, j )] = this.QR[this.matrix.index( i, j )];
          }
          else {
            result.entries[result.index( i, j )] = 0.0;
          }
        }
      }
      return result;
    },

    getR: function() {
      var result = new dot.Matrix( this.n, this.n );
      for ( var i = 0; i < this.n; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          if ( i < j ) {
            result.entries[result.index( i, j )] = this.QR[this.matrix.index( i, j )];
          }
          else if ( i === j ) {
            result.entries[result.index( i, j )] = this.Rdiag[i];
          }
          else {
            result.entries[result.index( i, j )] = 0.0;
          }
        }
      }
      return result;
    },

    getQ: function() {
      var i, j, k;
      var result = new dot.Matrix( this.m, this.n );
      for ( k = this.n - 1; k >= 0; k-- ) {
        for ( i = 0; i < this.m; i++ ) {
          result.entries[result.index( i, k )] = 0.0;
        }
        result.entries[result.index( k, k )] = 1.0;
        for ( j = k; j < this.n; j++ ) {
          if ( this.QR[this.matrix.index( k, k )] !== 0 ) {
            var s = 0.0;
            for ( i = k; i < this.m; i++ ) {
              s += this.QR[this.matrix.index( i, k )] * result.entries[result.index( i, j )];
            }
            s = -s / this.QR[this.matrix.index( k, k )];
            for ( i = k; i < this.m; i++ ) {
              result.entries[result.index( i, j )] += s * this.QR[this.matrix.index( i, k )];
            }
          }
        }
      }
      return result;
    },

    solve: function( matrix ) {
      if ( matrix.getRowDimension() !== this.m ) {
        throw new Error( "Matrix row dimensions must agree." );
      }
      if ( !this.isFullRank() ) {
        throw new Error( "Matrix is rank deficient." );
      }

      var i, j, k;

      // Copy right hand side
      var nx = matrix.getColumnDimension();
      var X = matrix.getArrayCopy();

      // Compute Y = transpose(Q)*matrix
      for ( k = 0; k < this.n; k++ ) {
        for ( j = 0; j < nx; j++ ) {
          var s = 0.0;
          for ( i = k; i < this.m; i++ ) {
            s += this.QR[this.matrix.index( i, k )] * X[matrix.index( i, j )];
          }
          s = -s / this.QR[this.matrix.index( k, k )];
          for ( i = k; i < this.m; i++ ) {
            X[matrix.index( i, j )] += s * this.QR[this.matrix.index( i, k )];
          }
        }
      }

      // Solve R*X = Y;
      for ( k = this.n - 1; k >= 0; k-- ) {
        for ( j = 0; j < nx; j++ ) {
          X[matrix.index( k, j )] /= this.Rdiag[k];
        }
        for ( i = 0; i < k; i++ ) {
          for ( j = 0; j < nx; j++ ) {
            X[matrix.index( i, j )] -= X[matrix.index( k, j )] * this.QR[this.matrix.index( i, k )];
          }
        }
      }
      return new dot.Matrix( X, this.n, nx ).getMatrix( 0, this.n - 1, 0, nx - 1 );
    }
  };
  
  return QRDecomposition;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Arbitrary-dimensional matrix, based on Jama (http://math.nist.gov/javanumerics/jama/)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix',['require','DOT/dot','PHET_CORE/isArray','DOT/SingularValueDecomposition','DOT/LUDecomposition','DOT/QRDecomposition','DOT/EigenvalueDecomposition','DOT/Vector2','DOT/Vector3','DOT/Vector4'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var Float32Array = window.Float32Array || Array;
  
  var isArray = require( 'PHET_CORE/isArray' );
  
  require( 'DOT/SingularValueDecomposition' );
  require( 'DOT/LUDecomposition' );
  require( 'DOT/QRDecomposition' );
  require( 'DOT/EigenvalueDecomposition' );
  require( 'DOT/Vector2' );
  require( 'DOT/Vector3' );
  require( 'DOT/Vector4' );
  
  dot.Matrix = function Matrix( m, n, filler, fast ) {
    this.m = m;
    this.n = n;

    var size = m * n;
    this.size = size;
    var i;

    if ( fast ) {
      this.entries = filler;
    }
    else {
      if ( !filler ) {
        filler = 0;
      }

      // entries stored in row-major format
      this.entries = new Float32Array( size );

      if ( isArray( filler ) ) {
        assert && assert( filler.length === size );

        for ( i = 0; i < size; i++ ) {
          this.entries[i] = filler[i];
        }
      }
      else {
        for ( i = 0; i < size; i++ ) {
          this.entries[i] = filler;
        }
      }
    }
  };
  var Matrix = dot.Matrix;

  /** sqrt(a^2 + b^2) without under/overflow. **/
  Matrix.hypot = function hypot( a, b ) {
    var r;
    if ( Math.abs( a ) > Math.abs( b ) ) {
      r = b / a;
      r = Math.abs( a ) * Math.sqrt( 1 + r * r );
    }
    else if ( b !== 0 ) {
      r = a / b;
      r = Math.abs( b ) * Math.sqrt( 1 + r * r );
    }
    else {
      r = 0.0;
    }
    return r;
  };

  Matrix.prototype = {
    constructor: Matrix,

    copy: function() {
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.size; i++ ) {
        result.entries[i] = this.entries[i];
      }
      return result;
    },

    getArray: function() {
      return this.entries;
    },

    getArrayCopy: function() {
      return new Float32Array( this.entries );
    },

    getRowDimension: function() {
      return this.m;
    },

    getColumnDimension: function() {
      return this.n;
    },

    // TODO: inline this places if we aren't using an inlining compiler! (check performance)
    index: function( i, j ) {
      return i * this.n + j;
    },

    get: function( i, j ) {
      return this.entries[this.index( i, j )];
    },

    set: function( i, j, s ) {
      this.entries[this.index( i, j )] = s;
    },

    getMatrix: function( i0, i1, j0, j1 ) {
      var result = new Matrix( i1 - i0 + 1, j1 - j0 + 1 );
      for ( var i = i0; i <= i1; i++ ) {
        for ( var j = j0; j <= j1; j++ ) {
          result.entries[result.index( i - i0, j - j0 )] = this.entries[this.index( i, j )];
        }
      }
      return result;
    },

    // getMatrix (int[] r, int j0, int j1)
    getArrayRowMatrix: function( r, j0, j1 ) {
      var result = new Matrix( r.length, j1 - j0 + 1 );
      for ( var i = 0; i < r.length; i++ ) {
        for ( var j = j0; j <= j1; j++ ) {
          result.entries[result.index( i, j - j0 )] = this.entries[this.index( r[i], j )];
        }
      }
      return result;
    },

    transpose: function() {
      var result = new Matrix( this.n, this.m );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          result.entries[result.index( j, i )] = this.entries[this.index( i, j )];
        }
      }
      return result;
    },

    norm1: function() {
      var f = 0;
      for ( var j = 0; j < this.n; j++ ) {
        var s = 0;
        for ( var i = 0; i < this.m; i++ ) {
          s += Math.abs( this.entries[ this.index( i, j ) ] );
        }
        f = Math.max( f, s );
      }
      return f;
    },

    norm2: function() {
      return (new dot.SingularValueDecomposition( this ).norm2());
    },

    normInf: function() {
      var f = 0;
      for ( var i = 0; i < this.m; i++ ) {
        var s = 0;
        for ( var j = 0; j < this.n; j++ ) {
          s += Math.abs( this.entries[ this.index( i, j ) ] );
        }
        f = Math.max( f, s );
      }
      return f;
    },

    normF: function() {
      var f = 0;
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          f = Matrix.hypot( f, this.entries[ this.index( i, j ) ] );
        }
      }
      return f;
    },

    uminus: function() {
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          result.entries[result.index( i, j )] = -this.entries[ this.index( i, j ) ];
        }
      }
      return result;
    },

    plus: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = result.index( i, j );
          result.entries[index] = this.entries[index] + matrix.entries[index];
        }
      }
      return result;
    },

    plusEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = result.index( i, j );
          this.entries[index] = this.entries[index] + matrix.entries[index];
        }
      }
      return this;
    },

    minus: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          result.entries[index] = this.entries[index] - matrix.entries[index];
        }
      }
      return result;
    },

    minusEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[index] = this.entries[index] - matrix.entries[index];
        }
      }
      return this;
    },

    arrayTimes: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = result.index( i, j );
          result.entries[index] = this.entries[index] * matrix.entries[index];
        }
      }
      return result;
    },

    arrayTimesEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[index] = this.entries[index] * matrix.entries[index];
        }
      }
      return this;
    },

    arrayRightDivide: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          result.entries[index] = this.entries[index] / matrix.entries[index];
        }
      }
      return result;
    },

    arrayRightDivideEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[index] = this.entries[index] / matrix.entries[index];
        }
      }
      return this;
    },

    arrayLeftDivide: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      var result = new Matrix( this.m, this.n );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          result.entries[index] = matrix.entries[index] / this.entries[index];
        }
      }
      return result;
    },

    arrayLeftDivideEquals: function( matrix ) {
      this.checkMatrixDimensions( matrix );
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[index] = matrix.entries[index] / this.entries[index];
        }
      }
      return this;
    },

    times: function( matrixOrScalar ) {
      var result;
      var i, j, k, s;
      var matrix;
      if ( matrixOrScalar.isMatrix ) {
        matrix = matrixOrScalar;
        if ( matrix.m !== this.n ) {
          throw new Error( "Matrix inner dimensions must agree." );
        }
        result = new Matrix( this.m, matrix.n );
        var matrixcolj = new Float32Array( this.n );
        for ( j = 0; j < matrix.n; j++ ) {
          for ( k = 0; k < this.n; k++ ) {
            matrixcolj[k] = matrix.entries[ matrix.index( k, j ) ];
          }
          for ( i = 0; i < this.m; i++ ) {
            s = 0;
            for ( k = 0; k < this.n; k++ ) {
              s += this.entries[this.index( i, k )] * matrixcolj[k];
            }
            result.entries[result.index( i, j )] = s;
          }
        }
        return result;
      }
      else {
        s = matrixOrScalar;
        result = new Matrix( this.m, this.n );
        for ( i = 0; i < this.m; i++ ) {
          for ( j = 0; j < this.n; j++ ) {
            result.entries[result.index( i, j )] = s * this.entries[this.index( i, j )];
          }
        }
        return result;
      }
    },

    timesEquals: function( s ) {
      for ( var i = 0; i < this.m; i++ ) {
        for ( var j = 0; j < this.n; j++ ) {
          var index = this.index( i, j );
          this.entries[index] = s * this.entries[index];
        }
      }
      return this;
    },

    solve: function( matrix ) {
      return (this.m === this.n ? (new dot.LUDecomposition( this )).solve( matrix ) :
          (new dot.QRDecomposition( this )).solve( matrix ));
    },

    solveTranspose: function( matrix ) {
      return this.transpose().solve( matrix.transpose() );
    },

    inverse: function() {
      return this.solve( Matrix.identity( this.m, this.m ) );
    },

    det: function() {
      return new dot.LUDecomposition( this ).det();
    },

    rank: function() {
      return new dot.SingularValueDecomposition( this ).rank();
    },

    cond: function() {
      return new dot.SingularValueDecomposition( this ).cond();
    },

    trace: function() {
      var t = 0;
      for ( var i = 0; i < Math.min( this.m, this.n ); i++ ) {
        t += this.entries[ this.index( i, i ) ];
      }
      return t;
    },

    checkMatrixDimensions: function( matrix ) {
      if ( matrix.m !== this.m || matrix.n !== this.n ) {
        throw new Error( "Matrix dimensions must agree." );
      }
    },

    toString: function() {
      var result = "";
      result += "dim: " + this.getRowDimension() + "x" + this.getColumnDimension() + "\n";
      for ( var row = 0; row < this.getRowDimension(); row++ ) {
        for ( var col = 0; col < this.getColumnDimension(); col++ ) {
          result += this.get( row, col ) + " ";
        }
        result += "\n";
      }
      return result;
    },

    // returns a vector that is contained in the specified column
    extractVector2: function( column ) {
      assert && assert( this.m === 2 ); // rows should match vector dimension
      return new dot.Vector2( this.get( 0, column ), this.get( 1, column ) );
    },

    // returns a vector that is contained in the specified column
    extractVector3: function( column ) {
      assert && assert( this.m === 3 ); // rows should match vector dimension
      return new dot.Vector3( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ) );
    },

    // returns a vector that is contained in the specified column
    extractVector4: function( column ) {
      assert && assert( this.m === 4 ); // rows should match vector dimension
      return new dot.Vector4( this.get( 0, column ), this.get( 1, column ), this.get( 2, column ), this.get( 3, column ) );
    },

    isMatrix: true
  };

  Matrix.identity = function( m, n ) {
    var result = new Matrix( m, n );
    for ( var i = 0; i < m; i++ ) {
      for ( var j = 0; j < n; j++ ) {
        result.entries[result.index( i, j )] = (i === j ? 1.0 : 0.0);
      }
    }
    return result;
  };

  Matrix.rowVector2 = function( vector ) {
    return new Matrix( 1, 2, [vector.x, vector.y] );
  };

  Matrix.rowVector3 = function( vector ) {
    return new Matrix( 1, 3, [vector.x, vector.y, vector.z] );
  };

  Matrix.rowVector4 = function( vector ) {
    return new Matrix( 1, 4, [vector.x, vector.y, vector.z, vector.w] );
  };

  Matrix.rowVector = function( vector ) {
    if ( vector.isVector2 ) {
      return Matrix.rowVector2( vector );
    }
    else if ( vector.isVector3 ) {
      return Matrix.rowVector3( vector );
    }
    else if ( vector.isVector4 ) {
      return Matrix.rowVector4( vector );
    }
    else {
      throw new Error( "undetected type of vector: " + vector.toString() );
    }
  };

  Matrix.columnVector2 = function( vector ) {
    return new Matrix( 2, 1, [vector.x, vector.y] );
  };

  Matrix.columnVector3 = function( vector ) {
    return new Matrix( 3, 1, [vector.x, vector.y, vector.z] );
  };

  Matrix.columnVector4 = function( vector ) {
    return new Matrix( 4, 1, [vector.x, vector.y, vector.z, vector.w] );
  };

  Matrix.columnVector = function( vector ) {
    if ( vector.isVector2 ) {
      return Matrix.columnVector2( vector );
    }
    else if ( vector.isVector3 ) {
      return Matrix.columnVector3( vector );
    }
    else if ( vector.isVector4 ) {
      return Matrix.columnVector4( vector );
    }
    else {
      throw new Error( "undetected type of vector: " + vector.toString() );
    }
  };

  /**
   * Create a Matrix where each column is a vector
   */

  Matrix.fromVectors2 = function( vectors ) {
    var dimension = 2;
    var n = vectors.length;
    var data = new Float32Array( dimension * n );

    for ( var i = 0; i < n; i++ ) {
      var vector = vectors[i];
      data[i] = vector.x;
      data[i + n] = vector.y;
    }

    return new Matrix( dimension, n, data, true );
  };

  Matrix.fromVectors3 = function( vectors ) {
    var dimension = 3;
    var n = vectors.length;
    var data = new Float32Array( dimension * n );

    for ( var i = 0; i < n; i++ ) {
      var vector = vectors[i];
      data[i] = vector.x;
      data[i + n] = vector.y;
      data[i + 2 * n] = vector.z;
    }

    return new Matrix( dimension, n, data, true );
  };

  Matrix.fromVectors4 = function( vectors ) {
    var dimension = 4;
    var n = vectors.length;
    var data = new Float32Array( dimension * n );

    for ( var i = 0; i < n; i++ ) {
      var vector = vectors[i];
      data[i] = vector.x;
      data[i + n] = vector.y;
      data[i + 2 * n] = vector.z;
      data[i + 3 * n] = vector.w;
    }

    return new Matrix( dimension, n, data, true );
  };
  
  return Matrix;
} );

// Copyright 2002-2013, University of Colorado Boulder

define( 'AXON/axon',['require'],function( require ) {
  

  var axon = {};

  // will be filled in by other modules
  return axon;
} );

// Copyright 2002-2013, University of Colorado Boulder

/**
 * An observable property, notifies registered observers when the value changes.
 *
 * Uses the 'Constructor' pattern for object creation, which has the downside that
 * all properties are created once for each instance. It would be nice if our functions
 * were shared. But since the only way to create private fields is in the constructor,
 * and the functions need access to those private fields, there doesn't seem to be
 * any choice but to define the functions in the constructor.
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'AXON/Property',['require','AXON/axon'],function( require ) {
  

  var axon = require( 'AXON/axon' );

  /**
   * @param {*} value
   * @constructor
   */
  axon.Property = function Property( value ) {

    //Store the internal value and the initial value
    this.storeValue( value );        // typically sets this._value
    this.storeInitialValue( value ); // typically sets this._initialValue
    this._observers = [];
  };

  axon.Property.prototype = {

    /**
     * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
     * @return {*}
     */
    get: function() {
      return this._value;
    },

    /**
     * Sets the value and notifies registered observers.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
     * If the value hasn't changed, this is a no-op.
     *
     * @param {*} value
     */
    set: function( value ) {
      if ( !this.equalsValue( value ) ) {
        this._setAndNotifyObservers( value );
      }
      return this;
    },

    // whether this property will not "change" when the passed-in value is set
    equalsValue: function( value ) {
      return value === this._value;
    },

    // store the current (new) value
    storeValue: function( value ) {
      this._value = value;
    },

    // store the initial value
    storeInitialValue: function( value ) {
      this._initialValue = value;
    },

    get initialValue() {
      return this._initialValue;
    },

    _setAndNotifyObservers: function( value ) {
      var oldValue = this.get();
      this.storeValue( value );
      this._notifyObservers( oldValue );
    },

    _notifyObservers: function( oldValue ) {
      var value = this.get();
      // TODO: JO: avoid slice() by storing observers array correctly
      var observersCopy = this._observers.slice(); // make a copy, in case notification results in removeObserver
      for ( var i = 0; i < observersCopy.length; i++ ) {
        observersCopy[i]( value, oldValue );
      }
    },

    //Use this method when mutating a value (not replacing with a new instance) and you want to send notifications about the change.
    //This is different from the normal axon strategy, but may be necessary to prevent memory allocations.
    //This method is unsafe for removing observers because it assumes the observer list not modified, to save another allocation
    //Only provides the new reference as a callback (no oldvalue)
    //See https://github.com/phetsims/axon/issues/6
    notifyObserversStatic: function() {
      var value = this.get();
      for ( var i = 0; i < this._observers.length; i++ ) {
        this._observers[i]( value );
      }
    },

    /**
     * Resets the value to the initial value.
     */
    reset: function() {
      this.set( this._initialValue );
    },

    /**
     * This function returns a bound function that sets the specified value.  For use in creating closures e.g. with gui classes.
     * For instance, to have a button that sets a property to true, instead of using
     * button.click(function(){property.set(true);});
     * you could use
     * button.click(property._set(true));
     * @param value the value to use when the setter is called.
     * @return a function that can be used to set the specified value.
     */
    _set: function( value ) {
      return this.set.bind( this, value );
    },

    get value() { return this.get(); },

    set value( newValue ) { this.set( newValue ); },

    /**
     * Adds an observer and notifies it immediately.
     * If observer is already registered, this is a no-op.
     * The initial notification provides the current value for newValue and null for oldValue.
     *
     * @param {Function} observer a function of the form observer(newValue,oldValue)
     */
    link: function( observer ) {
      if ( this._observers.indexOf( observer ) === -1 ) {
        this._observers.push( observer );
        observer( this.get(), null ); // null should be used when an object is expected but unavailable
      }
    },

    /**
     * Removes an observer.
     * If observer is not registered, this is a no-op.
     *
     * @param {Function} observer
     */
    unlink: function( observer ) {
      var index = this._observers.indexOf( observer );
      if ( index !== -1 ) {
        this._observers.splice( index, 1 );
      }
    },

    /**
     * Add an observer to the Property, without calling it back right away.  This is used when you need to register a listener without an immediate callback.
     * @param {Function} observer  a function with a single argument, which is the value of the property at the time the function is called.
     */
    lazyLink: function( observer ) {
      if ( this._observers.indexOf( observer ) === -1 ) {
        this._observers.push( observer );
      }
    },

    //Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript
    toString: function() {return 'Property{' + this.get() + '}'; },
    valueOf: function() {return this.toString();},

    /**
     * Add a listener so that it will only fire once (and not on registration)
     *
     * I can see two ways to implement this:
     * (a) add a field to the observer so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'
     * (b) wrap the observer in a new function which will call the observer and then remove itself.  Disadvantage: cannot remove an observer added using 'once'
     * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' listener must be removed before it is called once
     *
     * @param observer the listener which should be called back only for one property change (and not on registration)
     * @returns {Function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once
     */
    once: function( observer ) {
      var property = this;
      var wrapper = function( newValue, oldValue ) {
        observer( newValue, oldValue );
        property.unlink( wrapper );
      };
      this.lazyLink( wrapper );
      return wrapper;
    },

    /**
     * Links an object's named attribute to this property.  Returns a handle so it can be removed using Property.unlink();
     * Example: modelVisibleProperty.linkAttribute(view,'visible');
     *
     * @param object
     * @param attributeName
     */
    linkAttribute: function( object, attributeName ) {
      var handle = function( value ) {object[attributeName] = value;};
      this.link( handle );
      return handle;
    },

    /**
     * Returns a new DerivedProperty which is true/false based on whether the value matches (based on ===) the passed in argument.
     * @param value
     * @returns {axon.DerivedProperty}
     */
    valueEquals: function( value ) {
      return new axon.DerivedProperty( [this], function( propertyValue ) { return propertyValue === value; } );
    },

    /**
     * Returns a new boolean DerivedProperty which is true/false based on && operator.
     * @param otherProperty
     * @returns {DerivedProperty<boolean>}
     */
    and: function( otherProperty ) {
      return new axon.DerivedProperty( [this, otherProperty], function( thisValue, otherValue ) { return thisValue && otherValue; } );
    },

    /**
     * Returns a new boolean DerivedProperty which is true/false based on || operator.
     * @param otherProperty
     * @returns {DerivedProperty<boolean>}
     */
    or: function( otherProperty ) {
      return new axon.DerivedProperty( [this, otherProperty], function( thisValue, otherValue ) { return thisValue || otherValue; } );
    },

    /**
     * Multiply this property's value by a constant scalar number, and return the derived property.
     *
     * @param scalar
     * @returns {axon.DerivedProperty}
     */
    times: function( scalar ) {
      return new axon.DerivedProperty( [this], function( thisValue ) { return thisValue * scalar; } );
    },

    /**
     * Not property, which does not propagate changes to dependents.
     * @returns {DerivedProperty}
     */
    derivedNot: function() {
      return new axon.DerivedProperty( [this], function( thisValue ) { return !thisValue; } );
    },

    /**
     * Two way communication for not, so you can set the value and have it come back to the parent
     * Note that noting about the following code is specific to booleans, although this should probably be used mostly for booleans.
     * To unlink both listeners attached unlink a property created with not(), use detach()
     */
    not: function() {
      var parentProperty = this;
      var childProperty = new axon.Property( !this.value );

      var setParentToChild = function( value ) {childProperty.set( !value );};
      parentProperty.link( setParentToChild );

      var setChildToParent = function( value ) {parentProperty.set( !value );};
      childProperty.link( setChildToParent );

      childProperty.detach = function() {
        parentProperty.unlink( setParentToChild );
        childProperty.unlink( setChildToParent );
      };
      return childProperty;
    },

    /**
     * Convenience function for debugging a property values.  It prints the new value on registration and when changed.
     * @param name debug name to be printed on the console
     * @returns {Function} the handle to the linked listener in case it needs to be removed later
     */
    debug: function( name ) {
      var listener = function( value ) { console.log( name, value ); };
      this.link( listener );
      return listener;
    },

    //Returns a new Property that maps its values using the specified lookup table.
    //If the parent property value does not appear as a key in the lookup table, the returned property value is undefined
    mapValues: function( values ) {
      return new axon.DerivedProperty( [this], function( thisValue ) { return values[thisValue];} );
    },

    //Returns a new Property that maps its values using the specified function
    //See https://github.com/phetsims/axon/issues/25
    map: function( f ) {
      return new axon.DerivedProperty( [this], function( thisValue ) {return f( thisValue );} );
    },

    /**
     * Returns a function that can be used to toggle the property (using !)
     * @returns {f}
     */
    get toggleFunction() {
      return this.toggle.bind( this );
    },

    /**
     * Modifies the value of this Property with the ! operator.  Works for booleans and non-booleans.
     */
    toggle: function() {
      this.value = !this.value;
    },

    /**
     * Adds a listener that is fired when the property takes the specified value.  If the property has the value already, the listener is called back
     * immediately.  A reference to the listener is returned so that it can be removed.
     *
     * @param value the value to match
     * @param the listener that is called when this Property
     */
    onValue: function( value, listener ) {
      var observer = function( v ) {
        if ( v === value ) {
          listener();
        }
      };
      this.link( observer );
      return observer;
    }
  };

  return axon.Property;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Observable version of the basic 2-dimensional bounding box (Bounds2)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/ObservableBounds2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/Poolable','AXON/Property','DOT/Bounds2'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Property = require( 'AXON/Property' );
  require( 'DOT/Bounds2' );
  
  dot.ObservableBounds2 = function ObservableBounds2( minX, minY, maxX, maxY ) {
    dot.Bounds2.call( this, minX, minY, maxX, maxY );
    
    this._oldValue = this.copy();
    Property.call( this, this );
  };
  var ObservableBounds2 = dot.ObservableBounds2;
  
  inherit( dot.Bounds2, ObservableBounds2, extend( {}, Property.prototype, {
    // returns this value directly
    get: function() {
      return this;
    },
    
    /*---------------------------------------------------------------------------*
    * Overriding the core mutable methods (any mutable operation should call one of these)
    *----------------------------------------------------------------------------*/
    setMinMax: function( minX, minY, maxX, maxY ) {
      if ( this.minX !== minX || this.minY !== minY || this.maxX !== maxX || this.maxY !== maxY ) {
        this._oldValue.minX = this.minX;
        this._oldValue.minY = this.minY;
        this._oldValue.maxX = this.maxX;
        this._oldValue.maxY = this.maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    setMinX: function( minX ) {
      if ( this.minX !== minX ) {
        this._oldValue.minX = this.minX;
        this.minX = minX;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    setMinY: function( minY ) {
      if ( this.minY !== minY ) {
        this._oldValue.minY = this.minY;
        this.minY = minY;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    setMaxX: function( maxX ) {
      if ( this.maxX !== maxX ) {
        this._oldValue.maxX = this.maxX;
        this.maxX = maxX;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    setMaxY: function( maxY ) {
      if ( this.maxY !== maxY ) {
        this._oldValue.maxY = this.maxY;
        this.maxY = maxY;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    set: dot.Bounds2.prototype.set,
    
    // override with vector equality instead of instance equality
    equalsValue: function( value ) {
      return this.equals( value );
    },
    
    // we are not storing a separate value field (_value), so we leave this blank
    storeValue: function( value ) {
    },
    
    // to prevent a user from modifying the passed in initial value, we store the x/y here
    storeInitialValue: function( value ) {
      this._initialMinX = value.minX;
      this._initialMinY = value.minY;
      this._initialMaxX = value.maxX;
      this._initialMaxY = value.maxY;
    },
    
    reset: function() {
      this.setMinMax( this._initialMinX, this._initialMinY, this._initialMaxX, this._initialMaxY );
    },
    
    toString: function() {
      return 'ObservableBounds2(' + this.minX + ', ' + this.minY + ', ' + this.maxX + ', ' + this.maxY + ')';
    }
  } ) );
  
  // experimental object pooling
  /* jshint -W064 */
  Poolable( ObservableBounds2, {
    defaultFactory: function() { return new ObservableBounds2(); },
    constructorDuplicateFactory: function( pool ) {
      return function( minX, minY, maxX, maxY ) {
        if ( pool.length ) {
          return pool.pop().setMinMax( minX, minY, maxX, maxY );
        } else {
          return new ObservableBounds2( minX, minY, maxX, maxY );
        }
      };
    }
  } );
  
  return ObservableBounds2;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Observable version of the basic 3-dimensional matrix (Matrix3)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/ObservableMatrix3',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/Poolable','AXON/Property','DOT/Matrix3'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Property = require( 'AXON/Property' );
  require( 'DOT/Matrix3' );
  
  dot.ObservableMatrix3 = function ObservableMatrix3( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
    dot.Matrix3.call( this, v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
    
    this._oldValue = this.copy();
    this._skipChecks = false;
    Property.call( this, this );
  };
  var ObservableMatrix3 = dot.ObservableMatrix3;
  
  inherit( dot.Matrix3, ObservableMatrix3, extend( {}, Property.prototype, {
    // returns this value directly
    get: function() {
      return this;
    },
    
    /*---------------------------------------------------------------------------*
    * Overriding the core mutable methods (any mutable operation should call one of these)
    *----------------------------------------------------------------------------*/
    // every mutable method goes through rowMajor
    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
      var skip = this._skipChecks;
      var modified = skip ||
                     v00 !== this.entries[0] ||
                     v10 !== this.entries[1] ||
                     v20 !== this.entries[2] ||
                     v01 !== this.entries[3] ||
                     v11 !== this.entries[4] ||
                     v21 !== this.entries[5] ||
                     v02 !== this.entries[6] ||
                     v12 !== this.entries[7] ||
                     v22 !== this.entries[8] ||
                     type !== this.type;
      if ( modified ) {
        
        if ( !skip && this._oldValue ) {
          this._oldValue.entries[0] = this.entries[0];
          this._oldValue.entries[1] = this.entries[1];
          this._oldValue.entries[2] = this.entries[2];
          this._oldValue.entries[3] = this.entries[3];
          this._oldValue.entries[4] = this.entries[4];
          this._oldValue.entries[5] = this.entries[5];
          this._oldValue.entries[6] = this.entries[6];
          this._oldValue.entries[7] = this.entries[7];
          this._oldValue.entries[8] = this.entries[8];
          this._oldValue.type = this.type;
        }
        
        this.entries[0] = v00;
        this.entries[1] = v10;
        this.entries[2] = v20;
        this.entries[3] = v01;
        this.entries[4] = v11;
        this.entries[5] = v21;
        this.entries[6] = v02;
        this.entries[7] = v12;
        this.entries[8] = v22;
        
        // TODO: consider performance of the affine check here
        this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? dot.Matrix3.Types.AFFINE : dot.Matrix3.Types.OTHER ) : type;
        
        // if this isn't initialization, fire off changes and update the old value
        if ( this._observers ) {
          this._notifyObservers( skip ? null : this._oldValue );
        }
      }
      
      return this;
    },
    
    // override set, since it is overridden by property
    set: dot.Matrix3.prototype.set,
    
    // override with vector equality instead of instance equality
    equalsValue: function( value ) {
      return this.equals( value );
    },
    
    // we are not storing a separate value field (_value), so we leave this blank
    storeValue: function( value ) {
    },
    
    // to prevent a user from modifying the passed in initial value, we store the x/y here
    storeInitialValue: function( value ) {
      this._initial00 = value.m00();
      this._initial01 = value.m01();
      this._initial02 = value.m02();
      this._initial10 = value.m10();
      this._initial11 = value.m11();
      this._initial12 = value.m12();
      this._initial20 = value.m20();
      this._initial21 = value.m21();
      this._initial22 = value.m22();
      this._initialType = value.type;
    },
    
    reset: function() {
      this.rowMajor( this._initial00, this._initial01, this._initial02,
                     this._initial10, this._initial11, this._initial12,
                     this._initial20, this._initial21, this._initial22,
                     this._initialType );
    },
    
    toString: dot.Matrix3.prototype.toString
  } ) );
  
  // experimental object pooling
  /* jshint -W064 */
  Poolable( ObservableMatrix3, {
    defaultFactory: function() { return new ObservableMatrix3(); },
    constructorDuplicateFactory: function( pool ) {
      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
        if ( pool.length ) {
          return pool.pop().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
        } else {
          return new ObservableMatrix3( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
        }
      };
    }
  } );
  
  return ObservableMatrix3;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Observable version of the basic 2-dimensional vector
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/ObservableVector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/extend','PHET_CORE/Poolable','AXON/Property','DOT/Vector2'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Property = require( 'AXON/Property' );
  require( 'DOT/Vector2' );
  
  dot.ObservableVector2 = function ObservableVector2( x, y ) {
    dot.Vector2.call( this, x, y );
    
    this._oldValue = this.copy();
    Property.call( this, this );
  };
  var ObservableVector2 = dot.ObservableVector2;
  
  inherit( dot.Vector2, ObservableVector2, extend( {}, Property.prototype, {
    // returns this value directly
    get: function() {
      return this;
    },
    
    /*---------------------------------------------------------------------------*
    * Overriding the core mutable methods (any mutable operation should call one of these)
    *----------------------------------------------------------------------------*/
    setXY: function( x, y ) {
      if ( this.x !== x || this.y !== y ) {
        this._oldValue.x = this.x;
        this._oldValue.y = this.y;
        this.x = x;
        this.y = y;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    setX: function( x ) {
      if ( this.x !== x ) {
        this._oldValue.x = this.x;
        this.x = x;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    setY: function( y ) {
      if ( this.y !== y ) {
        this._oldValue.y = this.y;
        this.y = y;
        this._notifyObservers( this._oldValue );
      }
      return this;
    },
    set: dot.Vector2.prototype.set,
    
    // override with vector equality instead of instance equality
    equalsValue: function( value ) {
      return this.equals( value );
    },
    
    // we are not storing a separate value field (_value), so we leave this blank
    storeValue: function( value ) {
    },
    
    // to prevent a user from modifying the passed in initial value, we store the x/y here
    storeInitialValue: function( value ) {
      this._initialX = value.x;
      this._initialY = value.y;
    },
    
    reset: function() {
      this.setXY( this._initialX, this._initialY );
    },
    
    toString: function() {
      return 'ObservableVector2(' + this.x + ', ' + this.y + ')';
    }
  } ) );
  
  // experimental object pooling
  /* jshint -W064 */
  Poolable( ObservableVector2, {
    defaultFactory: function() { return new ObservableVector2(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y );
        } else {
          return new ObservableVector2( x, y );
        }
      };
    }
  } );
  
  return ObservableVector2;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * An immutable permutation that can permute an array
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Permutation',['require','DOT/dot','PHET_CORE/isArray','DOT/Util'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  var isArray = require( 'PHET_CORE/isArray' );
  require( 'DOT/Util' ); // for rangeInclusive
  
  // Creates a permutation that will rearrange a list so that newList[i] = oldList[permutation[i]]
  var Permutation = dot.Permutation = function Permutation( indices ) {
    this.indices = indices;
  };

  // An identity permutation with a specific number of elements
  Permutation.identity = function( size ) {
    assert && assert( size >= 0 );
    var indices = new Array( size );
    for ( var i = 0; i < size; i++ ) {
      indices[i] = i;
    }
    return new Permutation( indices );
  };

  // lists all permutations that have a given size
  Permutation.permutations = function( size ) {
    var result = [];
    Permutation.forEachPermutation( dot.rangeInclusive( 0, size - 1 ), function( integers ) {
      result.push( new Permutation( integers ) );
    } );
    return result;
  };

  /**
   * Call our function with each permutation of the provided list PREFIXED by prefix, in lexicographic order
   *
   * @param array   List to generate permutations of
   * @param prefix   Elements that should be inserted at the front of each list before each call
   * @param callback Function to call
   */
  function recursiveForEachPermutation( array, prefix, callback ) {
    if ( array.length === 0 ) {
      callback.call( undefined, prefix );
    }
    else {
      for ( var i = 0; i < array.length; i++ ) {
        var element = array[i];

        // remove the element from the array
        var nextArray = array.slice( 0 );
        nextArray.splice( i, 1 );

        // add it into the prefix
        var nextPrefix = prefix.slice( 0 );
        nextPrefix.push( element );

        recursiveForEachPermutation( nextArray, nextPrefix, callback );
      }
    }
  }

  Permutation.forEachPermutation = function( array, callback ) {
    recursiveForEachPermutation( array, [], callback );
  };

  Permutation.prototype = {
    constructor: Permutation,

    size: function() {
      return this.indices.length;
    },

    apply: function( arrayOrInt ) {
      if ( isArray( arrayOrInt ) ) {
        if ( arrayOrInt.length !== this.size() ) {
          throw new Error( "Permutation length " + this.size() + " not equal to list length " + arrayOrInt.length );
        }

        // permute it as an array
        var result = new Array( arrayOrInt.length );
        for ( var i = 0; i < arrayOrInt.length; i++ ) {
          result[i] = arrayOrInt[ this.indices[i] ];
        }
        return result;
      }
      else {
        // permute a single index
        return this.indices[ arrayOrInt ];
      }
    },

    // The inverse of this permutation
    inverted: function() {
      var newPermutation = new Array( this.size() );
      for ( var i = 0; i < this.size(); i++ ) {
        newPermutation[this.indices[i]] = i;
      }
      return new Permutation( newPermutation );
    },

    withIndicesPermuted: function( indices ) {
      var result = [];
      var that = this;
      Permutation.forEachPermutation( indices, function( integers ) {
        var oldIndices = that.indices;
        var newPermutation = oldIndices.slice( 0 );

        for ( var i = 0; i < indices.length; i++ ) {
          newPermutation[indices[i]] = oldIndices[integers[i]];
        }
        result.push( new Permutation( newPermutation ) );
      } );
      return result;
    },

    toString: function() {
      return "P[" + this.indices.join( ", " ) + "]";
    }
  };

  Permutation.testMe = function( console ) {
    var a = new Permutation( [ 1, 4, 3, 2, 0 ] );
    console.log( a.toString() );

    var b = a.inverted();
    console.log( b.toString() );

    console.log( b.withIndicesPermuted( [ 0, 3, 4 ] ).toString() );

    console.log( Permutation.permutations( 4 ).toString() );
  };
  
  return Permutation;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Quaternion, see http://en.wikipedia.org/wiki/Quaternion
 *
 * TODO: convert from JME-style parameterization into classical mathematical description?
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Quaternion',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector3','DOT/Matrix3','DOT/Util'],function( require ) {
  

  var dot = require( 'DOT/dot' );

  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Vector3' );
  require( 'DOT/Matrix3' );
  require( 'DOT/Util' );

  dot.Quaternion = function Quaternion( x, y, z, w ) {
    this.setXYZW( x, y, z, w );

    phetAllocation && phetAllocation( 'Quaternion' );
  };
  var Quaternion = dot.Quaternion;

  Quaternion.prototype = {
    constructor: Quaternion,

    isQuaternion: true,

    setXYZW: function( x, y, z, w ) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = w !== undefined ? w : 1;
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *----------------------------------------------------------------------------*/

    plus: function( quat ) {
      return new Quaternion( this.x + quat.x, this.y + quat.y, this.z + quat.z, this.w + quat.w );
    },

    timesScalar: function( s ) {
      return new Quaternion( this.x * s, this.y * s, this.z * s, this.w * s );
    },

    // standard quaternion multiplication (hamilton product)
    timesQuaternion: function( quat ) {
      // TODO: note why this is the case? product noted everywhere is the other one mentioned!
      // mathematica-style
//        return new Quaternion(
//                this.x * quat.x - this.y * quat.y - this.z * quat.z - this.w * quat.w,
//                this.x * quat.y + this.y * quat.x + this.z * quat.w - this.w * quat.z,
//                this.x * quat.z - this.y * quat.w + this.z * quat.x + this.w * quat.y,
//                this.x * quat.w + this.y * quat.z - this.z * quat.y + this.w * quat.x
//        );

      // JME-style
      return new Quaternion(
          this.x * quat.w - this.z * quat.y + this.y * quat.z + this.w * quat.x,
          -this.x * quat.z + this.y * quat.w + this.z * quat.x + this.w * quat.y,
          this.x * quat.y - this.y * quat.x + this.z * quat.w + this.w * quat.z,
          -this.x * quat.x - this.y * quat.y - this.z * quat.z + this.w * quat.w
      );

      /*
       Mathematica!
       In[13]:= Quaternion[-0.0, -0.0024999974, 0.0, 0.9999969] ** Quaternion[-0.9864071, 0.0016701065, -0.0050373166, 0.16423558]
       Out[13]= Quaternion[-0.164231, 0.00750332, 0.00208069, -0.986391]

       In[17]:= Quaternion[-0.0024999974, 0.0, 0.9999969, 0] ** Quaternion[0.0016701065, -0.0050373166, 0.16423558, -0.9864071]
       Out[17]= Quaternion[-0.164239, -0.986391, 0.00125951, 0.00750332]

       JME contains the rearrangement of what is typically called {w,x,y,z}
       */
    },

    timesVector3: function( v ) {
      if ( v.magnitude() === 0 ) {
        return new dot.Vector3();
      }

      // TODO: optimization?
      return new dot.Vector3F(
          this.w * this.w * v.x + 2 * this.y * this.w * v.z - 2 * this.z * this.w * v.y + this.x * this.x * v.x + 2 * this.y * this.x * v.y + 2 * this.z * this.x * v.z - this.z * this.z * v.x - this.y * this.y * v.x,
          2 * this.x * this.y * v.x + this.y * this.y * v.y + 2 * this.z * this.y * v.z + 2 * this.w * this.z * v.x - this.z * this.z * v.y + this.w * this.w * v.y - 2 * this.x * this.w * v.z - this.x * this.x * v.y,
          2 * this.x * this.z * v.x + 2 * this.y * this.z * v.y + this.z * this.z * v.z - 2 * this.w * this.y * v.x - this.y * this.y * v.z + 2 * this.w * this.x * v.y - this.x * this.x * v.z + this.w * this.w * v.z
      );
    },

    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },

    normalized: function() {
      var magnitude = this.magnitude();
      assert && assert( magnitude !== 0, 'Cannot normalize a zero-magnitude quaternion' );
      return this.timesScalar( 1 / magnitude );
    },

    negated: function() {
      return new Quaternion( -this.x, -this.y, -this.z, -this.w );
    },

    toRotationMatrix: function() {
      // see http://en.wikipedia.org/wiki/Rotation_matrix#Quaternion

      var norm = this.magnitudeSquared();
      var flip = ( norm === 1 ) ? 2 : ( norm > 0 ) ? 2 / norm : 0;

      var xx = this.x * this.x * flip;
      var xy = this.x * this.y * flip;
      var xz = this.x * this.z * flip;
      var xw = this.w * this.x * flip;
      var yy = this.y * this.y * flip;
      var yz = this.y * this.z * flip;
      var yw = this.w * this.y * flip;
      var zz = this.z * this.z * flip;
      var zw = this.w * this.z * flip;

      return dot.Matrix3.dirtyFromPool().columnMajor(
          1 - ( yy + zz ),
        ( xy + zw ),
        ( xz - yw ),
        ( xy - zw ),
          1 - ( xx + zz ),
        ( yz + xw ),
        ( xz + yw ),
        ( yz - xw ),
          1 - ( xx + yy )
      );
    }
  };

  Quaternion.fromEulerAngles = function( yaw, roll, pitch ) {
    var sinPitch = Math.sin( pitch * 0.5 );
    var cosPitch = Math.cos( pitch * 0.5 );
    var sinRoll = Math.sin( roll * 0.5 );
    var cosRoll = Math.cos( roll * 0.5 );
    var sinYaw = Math.sin( yaw * 0.5 );
    var cosYaw = Math.cos( yaw * 0.5 );

    var a = cosRoll * cosPitch;
    var b = sinRoll * sinPitch;
    var c = cosRoll * sinPitch;
    var d = sinRoll * cosPitch;

    return new Quaternion(
        a * sinYaw + b * cosYaw,
        d * cosYaw + c * sinYaw,
        c * cosYaw - d * sinYaw,
        a * cosYaw - b * sinYaw
    );
  };

  Quaternion.fromRotationMatrix = function( matrix ) {
    var v00 = matrix.m00();
    var v01 = matrix.m01();
    var v02 = matrix.m02();
    var v10 = matrix.m10();
    var v11 = matrix.m11();
    var v12 = matrix.m12();
    var v20 = matrix.m20();
    var v21 = matrix.m21();
    var v22 = matrix.m22();

    // from graphics gems code
    var trace = v00 + v11 + v22;
    var sqt;

    // we protect the division by s by ensuring that s>=1
    if ( trace >= 0 ) {
      sqt = Math.sqrt( trace + 1 );
      return new Quaternion(
          ( v21 - v12 ) * 0.5 / sqt,
          ( v02 - v20 ) * 0.5 / sqt,
          ( v10 - v01 ) * 0.5 / sqt,
          0.5 * sqt
      );
    }
    else if ( ( v00 > v11 ) && ( v00 > v22 ) ) {
      sqt = Math.sqrt( 1 + v00 - v11 - v22 );
      return new Quaternion(
          sqt * 0.5,
          ( v10 + v01 ) * 0.5 / sqt,
          ( v02 + v20 ) * 0.5 / sqt,
          ( v21 - v12 ) * 0.5 / sqt
      );
    }
    else if ( v11 > v22 ) {
      sqt = Math.sqrt( 1 + v11 - v00 - v22 );
      return new Quaternion(
          ( v10 + v01 ) * 0.5 / sqt,
          sqt * 0.5,
          ( v21 + v12 ) * 0.5 / sqt,
          ( v02 - v20 ) * 0.5 / sqt
      );
    }
    else {
      sqt = Math.sqrt( 1 + v22 - v00 - v11 );
      return new Quaternion(
          ( v02 + v20 ) * 0.5 / sqt,
          ( v21 + v12 ) * 0.5 / sqt,
          sqt * 0.5,
          ( v10 - v01 ) * 0.5 / sqt
      );
    }
  };

  /**
   * Find a quaternion that transforms a unit vector A into a unit vector B. There
   * are technically multiple solutions, so this only picks one.
   *
   * @param a Unit vector A
   * @param b Unit vector B
   * @return A quaternion s.t. Q * A = B
   */
  Quaternion.getRotationQuaternion = function( a, b ) {
    return Quaternion.fromRotationMatrix( dot.Matrix3.rotateAToB( a, b ) );
  };

  // spherical linear interpolation - blending two quaternions
  Quaternion.slerp = function( a, b, t ) {
    // if they are identical, just return one of them
    if ( a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w ) {
      return a;
    }

    var dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;

    if ( dot < 0 ) {
      b = b.negated();
      dot = -dot;
    }

    // how much of each quaternion should be contributed
    var ratioA = 1 - t;
    var ratioB = t;

    // tweak them if necessary
    if ( ( 1 - dot ) > 0.1 ) {
      var theta = Math.acos( dot );
      var invSinTheta = ( 1 / Math.sin( theta ) );

      ratioA = ( Math.sin( ( 1 - t ) * theta ) * invSinTheta );
      ratioB = ( Math.sin( ( t * theta ) ) * invSinTheta );
    }

    return new Quaternion(
        ratioA * a.x + ratioB * b.x,
        ratioA * a.y + ratioB * b.y,
        ratioA * a.z + ratioB * b.z,
        ratioA * a.w + ratioB * b.w
    );
  };

  // experimental object pooling
  /* jshint -W064 */
  Poolable( Quaternion, {
    defaultFactory: function() { return new Quaternion(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z, w ) {
        if ( pool.length ) {
          return pool.pop().set( x, y, z, w );
        }
        else {
          return new Quaternion( x, y, z, w );
        }
      };
    }
  } );

  return Quaternion;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * 3-dimensional ray
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Ray3',['require','DOT/dot'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  dot.Ray3 = function Ray3( pos, dir ) {
    this.pos = pos;
    this.dir = dir;
  };
  var Ray3 = dot.Ray3;
  
  Ray3.prototype = {
    constructor: Ray3,

    shifted: function( distance ) {
      return new Ray3( this.pointAtDistance( distance ), this.dir );
    },

    pointAtDistance: function( distance ) {
      return this.pos.plus( this.dir.timesScalar( distance ) );
    },

    toString: function() {
      return this.pos.toString() + " => " + this.dir.toString();
    }
  };
  
  return Ray3;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * A 2D rectangle-shaped bounded area, with a convenience name and constructor. Totally functionally
 * equivalent to Bounds2, but with a different constructor.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Rectangle',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  
  dot.Rectangle = function Rectangle( x, y, width, height ) {
    assert && assert( height !== undefined, 'Rectangle requires 4 parameters' );
    Bounds2.call( this, x, y, x + width, y + height );
  };
  var Rectangle = dot.Rectangle;
  
  inherit( Bounds2, Rectangle );
  
  return Rectangle;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Forward and inverse transforms with 4x4 matrices, allowing flexibility including affine and perspective transformations.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Transform4',['require','DOT/dot','DOT/Matrix4','DOT/Vector3','DOT/Ray3'],function( require ) {
  
  
  var dot = require( 'DOT/dot' );
  
  require( 'DOT/Matrix4' );
  require( 'DOT/Vector3' );
  require( 'DOT/Ray3' );
  
  // takes a 4x4 matrix
  dot.Transform4 = function Transform4( matrix ) {
    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices
    this.setMatrix( matrix === undefined ? dot.Matrix4.IDENTITY : matrix );
  };
  var Transform4 = dot.Transform4;
  
  Transform4.prototype = {
    constructor: Transform4,
    
    setMatrix: function( matrix ) {
      this.matrix = matrix;
      
      // compute these lazily
      this.inverse = null;
      this.matrixTransposed = null; // since WebGL won't allow transpose == true
      this.inverseTransposed = null;
    },
    
    getMatrix: function() {
      return this.matrix;
    },
    
    getInverse: function() {
      if ( this.inverse === null ) {
        this.inverse = this.matrix.inverted();
      }
      return this.inverse;
    },
    
    getMatrixTransposed: function() {
      if ( this.matrixTransposed === null ) {
        this.matrixTransposed = this.matrix.transposed();
      }
      return this.matrixTransposed;
    },
    
    getInverseTransposed: function() {
      if ( this.inverseTransposed === null ) {
        this.inverseTransposed = this.getInverse().transposed();
      }
      return this.inverseTransposed;
    },
    
    prepend: function( matrix ) {
      this.setMatrix( matrix.timesMatrix( this.matrix ) );
    },
    
    append: function( matrix ) {
      this.setMatrix( this.matrix.timesMatrix( matrix ) );
    },
    
    prependTransform: function( transform ) {
      this.prepend( transform.matrix );
    },
    
    appendTransform: function( transform ) {
      this.append( transform.matrix );
    },
    
    isIdentity: function() {
      return this.matrix.type === dot.Matrix4.Types.IDENTITY;
    },
    
    // applies the 2D affine transform part of the transformation
    applyToCanvasContext: function( context ) {
      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m03(), this.matrix.m13() );
    },
    
    /*---------------------------------------------------------------------------*
     * forward transforms (for Vector3 or scalar)
     *----------------------------------------------------------------------------*/
     
    // transform a position (includes translation)
    transformPosition3: function( vec3 ) {
      return this.matrix.timesVector3( vec3 );
    },
    
    // transform a vector (exclude translation)
    transformDelta3: function( vec3 ) {
      return this.matrix.timesRelativeVector3( vec3 );
    },
    
    // transform a normal vector (different than a normal vector)
    transformNormal3: function( vec3 ) {
      return this.getInverse().timesTransposeVector3( vec3 );
    },
    
    transformDeltaX: function( x ) {
      return this.transformDelta3( new dot.Vector3( x, 0, 0 ) ).x;
    },
    
    transformDeltaY: function( y ) {
      return this.transformDelta3( new dot.Vector3( 0, y, 0 ) ).y;
    },
    
    transformDeltaZ: function( z ) {
      return this.transformDelta3( new dot.Vector3( 0, 0, z ) ).z;
    },
    
    transformRay: function( ray ) {
      return new dot.Ray3(
          this.transformPosition3( ray.pos ),
          this.transformPosition3( ray.pos.plus( ray.dir ) ).minus( this.transformPosition3( ray.pos ) ) );
    },
    
    /*---------------------------------------------------------------------------*
     * inverse transforms (for Vector3 or scalar)
     *----------------------------------------------------------------------------*/
     
    inversePosition3: function( vec3 ) {
      return this.getInverse().timesVector3( vec3 );
    },
    
    inverseDelta3: function( vec3 ) {
      // inverse actually has the translation rolled into the other coefficients, so we have to make this longer
      return this.inversePosition3( vec3 ).minus( this.inversePosition3( dot.Vector3.ZERO ) );
    },
    
    inverseNormal3: function( vec3 ) {
      return this.matrix.timesTransposeVector3( vec3 );
    },
    
    inverseDeltaX: function( x ) {
      return this.inverseDelta3( new dot.Vector3( x, 0, 0 ) ).x;
    },
    
    inverseDeltaY: function( y ) {
      return this.inverseDelta3( new dot.Vector3( 0, y, 0 ) ).y;
    },
    
    inverseDeltaZ: function( z ) {
      return this.inverseDelta3( new dot.Vector3( 0, 0, z ) ).z;
    },
    
    inverseRay: function( ray ) {
      return new dot.Ray3(
          this.inversePosition3( ray.pos ),
          this.inversePosition3( ray.pos.plus( ray.dir ) ).minus( this.inversePosition3( ray.pos ) )
      );
    }
  };
  
  return Transform4;
} );


// Copyright 2002-2014, University of Colorado Boulder

define( 'DOT/main',[
  'DOT/dot',
  'DOT/Bounds2',
  'DOT/Bounds3',
  'DOT/Complex',
  'DOT/ConvexHull2',
  'DOT/Dimension2',
  'DOT/EigenvalueDecomposition',
  'DOT/LinearFunction',
  'DOT/LUDecomposition',
  'DOT/Matrix',
  'DOT/Matrix3',
  'DOT/Matrix4',
  'DOT/ObservableBounds2',
  'DOT/ObservableMatrix3',
  'DOT/ObservableVector2',
  'DOT/Permutation',
  'DOT/QRDecomposition',
  'DOT/Quaternion',
  'DOT/Ray2',
  'DOT/Ray3',
  'DOT/Rectangle',
  'DOT/SingularValueDecomposition',
  'DOT/Transform3',
  'DOT/Transform4',
  'DOT/Util',
  'DOT/Vector2',
  'DOT/Vector3',
  'DOT/Vector4'
  ], function( dot ) {
    
    return dot;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * If given an Array, removes all of its elements and returns it. Otherwise, if given a falsy value
 * (null/undefined/etc.), it will create and return a fresh Array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/cleanArray',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  var cleanArray = core.cleanArray = function cleanArray( arr ) {
    assert && assert( !arr || ( arr instanceof Array ), 'cleanArray either takes an Array' );
    
    if ( arr ) {
      // fastest way to clear an array (http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript, http://jsperf.com/array-destroy/32)
      // also, better than length=0, since it doesn't create significant garbage collection (like length=0), tested on Chrome 34.
      while ( arr.length ) {
        arr.pop();
      }
      return arr;
    } else {
      return [];
    }
  };
  return cleanArray;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Creates an array of results from an iterator that takes a callback.
 *
 * For instance, if calling a function f( g ) will call g( 1 ), g( 2 ), and g( 3 ),
 * collect( function( callback ) { f( callback ); } );
 * will return [1,2,3].
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/collect',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  var collect = core.collect = function collect( iterate ) {
    assert && assert( typeof iterate === 'function' );
    var result = [];
    iterate( function( ob ) {
      result.push( ob );
    } );
    return result;
  };
  return collect;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Loads a script
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/loadScript',['require','PHET_CORE/core'],function( require ) {
  
  
  var core = require( 'PHET_CORE/core' );
  
  /*
   * Load a script. The only required argument is src, and can be specified either as
   * loadScript( "<url>" ) or loadScript( { src: "<url>", ... other options ... } ).
   *
   * Arguments:
   *   src:         The source of the script to load
   *   callback:    A callback to call (with no arguments) once the script is loaded and has been executed
   *   async:       Whether the script should be loaded asynchronously. Defaults to true
   *   cacheBuster: Whether the URL should have an appended query string to work around caches
   */
  var loadScript = core.loadScript = function loadScript( args ) {
    // handle a string argument
    if ( typeof args === 'string' ) {
      args = { src: args };
    }
    
    var src         = args.src;
    var callback    = args.callback;
    var async       = args.async === undefined ? true : args.async;
    var cacheBuster = args.cacheBuster === undefined ? false : args.cacheBuster;
    
    var called = false;
    
    var script = document.createElement( 'script' );
    script.type = 'text/javascript';
    script.async = async;
    script.onload = script.onreadystatechange = function() {
      var state = this.readyState;
      if ( state && state !== "complete" && state !== "loaded" ) {
        return;
      }
      
      if ( !called ) {
        called = true;
        
        if ( callback ) {
          callback();
        }
      }
    };
    
    // make sure things aren't cached, just in case
    script.src = src + ( cacheBuster ? '?random=' + Math.random().toFixed( 10 ) : '' );
    
    var other = document.getElementsByTagName( 'script' )[0];
    other.parentNode.insertBefore( script, other );
  };
  return loadScript;
} );

// Copyright 2002-2014, University of Colorado Boulder

/**
 * Simple profiler which handles nested calls which provides a composite view, to help for micro-optimization.
 * Usage:
 * profiler.start('updateScene');
 * ...
 * profiler.start('moveObjects');
 * ...
 * profiler.stop();
 * ...
 * profiler.stop();
 * See testSelf() for a larger example. This could be used on ipad for instance.
 *
 * @author Sam Reid
 */
define( 'PHET_CORE/profiler',['require','PHET_CORE/core'],function( require ) {
  

  var core = require( 'PHET_CORE/core' );

  var stack = [];
  var results = {};
  var count = 0;
  var listeners = [];
  var profiler = core.profiler = {
    displayCount: 1000,
    start: function( name ) {
      var time = Date.now();
      stack.push( {name: name, time: time} );
    },
    addListener: function( listener ) {
      listeners.push( listener );
    },
    stop: function() {
      var end = Date.now();
      var top = stack.pop();
      var elapsed = end - top.time;
      if ( !results[top.name] ) {
        results[top.name] = [];
      }
      //TODO: this may be a memory problem, consider coalescing (averaging or summing) values here
      results[top.name].push( elapsed );
      count++;
      if ( count % this.displayCount === 0 ) {
        var summary = JSON.stringify( this.toJSON() );

        console.log( summary );

        //Also notify listeners that a new result was obtained
        for ( var i = 0; i < listeners.length; i++ ) {
          listeners[i]( summary );
        }
        results = {};
      }
    },
    toJSON: function() {
      var summary = {};
      var sum;
      for ( var property in results ) {
        sum = 0;
        for ( var i = 0; i < results[property].length; i++ ) {
          var time = results[property][i];
          sum += time;
        }
        var average = sum / results[property].length;
        summary[property] = {average: average, count: results[property].length};
      }
      return summary;
    },

    //sanity test
    testSelf: function() {
      var a, b;
      var profiler = this;
      this.displayCount = 10000000;//Only show final result
      for ( var i = 0; i < 10; i++ ) {
        profiler.start( 'physics' );
        for ( var k = 0; k < 10000; k++ ) {
          profiler.start( 'mloop' );
          for ( var m = 0; m < 10000; m++ ) {
            a = 100 * 200;
          }
          profiler.stop();
          profiler.start( 'xloop' );
          for ( var x = 0; x < 20000; x++ ) {
            b = 100 * 200;
          }
          profiler.stop();
        }
        profiler.stop();
      }

      console.log( 'results: ', a, b );
      console.log( JSON.stringify( this.toJSON() ) );

      //sample correct output on chrome: {"mloop":{"average":0.01675,"count":100000},"xloop":{"average":0.03254,"count":100000},"physics":{"average":498.9,"count":10}}
    }
  };
//  profiler.testSelf();
  return profiler;
} );

// Copyright 2002-2014, University of Colorado Boulder

define( 'PHET_CORE/main',[
  'PHET_CORE/core',
  'PHET_CORE/cleanArray',
  'PHET_CORE/collect',
  'PHET_CORE/escapeHTML',
  'PHET_CORE/extend',
  'PHET_CORE/inherit',
  'PHET_CORE/isArray',
  'PHET_CORE/loadScript',
  'PHET_CORE/phetAllocation',
  'PHET_CORE/platform',
  'PHET_CORE/Poolable',
  'PHET_CORE/profiler'
  ], function( core ) {
    
    return core;
} );

// Copyright 2002-2013, University of Colorado

/**
 * Configuration file for development purposes, NOT for production deployments.
 *
 * @author Jonathan Olson <olsonsjc@gmail.com>
 */

// if has.js is included, set assertion flags to true (so we can catch errors during development)
if ( window.has ) {
  // default config only enables basic assertions
  window.has.add( 'assert.basic', function( global, document, anElement ) {  return true; } );
  // window.has.add( 'assert.slow', function( global, document, anElement ) {  return true; } );
}

// flag is set so we can ensure that the config has executed. This prevents various Require.js dynamic loading timeouts and script errors
window.loadedSceneryConfig = true;

require.config( {
  // depends on all of Scenery, Kite, and Dot
  deps: [ 'main', 'KITE/main', 'DOT/main', 'PHET_CORE/main' ],
  
  paths: {
    underscore: '../../sherpa/lodash-2.4.1',
    jquery: '../../sherpa/jquery-2.1.0',
    SCENERY: '.',
    KITE: '../../kite/js',
    DOT: '../../dot/js',
    PHET_CORE: '../../phet-core/js',
    ASSERT: '../../assert/js',
    AXON: '../../axon/js'
  },
  
  shim: {
    underscore: { exports: '_' },
    jquery: { exports: '$' }
  },
  
  urlArgs: new Date().getTime() // add cache buster query string to make browser refresh actually reload everything
} );

define("config", function(){});
 window.scenery = require( 'main' ); window.kite = require( 'KITE/main' ); window.dot = require( 'DOT/main' ); window.core = require( 'PHET_CORE/main' ); scenery.Util.polyfillRequestAnimationFrame(); }());
